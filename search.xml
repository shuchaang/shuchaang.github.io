<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2019总结反思</title>
      <link href="/2020/01/01/2019%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/"/>
      <url>/2020/01/01/2019%E6%80%BB%E7%BB%93%E5%8F%8D%E6%80%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="起点"><a href="#起点" class="headerlink" title="起点"></a>起点</h2><p>当年高考报志愿的时候,我爸问我想学什么。我下定决心要学高新技术,计算机类的,而当时最热门的专业是土木。虽然家人当时并不觉得这是个好专业,但还是没有干涉我的选择。</p><p>浑浑噩噩在重庆度过了大学时光,大学的最后一年才发现自己还一事无成。于是和女朋友双双准备考研,并且最后双双落榜。</p><h2 id="第一份工作"><a href="#第一份工作" class="headerlink" title="第一份工作"></a>第一份工作</h2><p>大学唯一给我的 gift 就是一个本科学历和一个和计算机专业相关的学位证书。17年3月才开始找工作,为了等考研成绩出来,当时已经是春招的尾巴了,也并没有什么可选择的余地。于是到了杭州娃哈哈,作为一名综合开发专员。工作的内容就是一些企业ERP系统,代码很老,桌面端是C#,后端是java。虽然工资并不高,但是工作非常清闲。在实现日常业务之余的所有的时间，我都用来提升自己。那时一位同事经常拿着盗版视频来问我要不要一起学,并且一起买了阿里云的服务器练手。当时的状态就是，白天写公司代码，中午看书，下午再写会公司代码，然后写一些有意思的项目，一直到晚上九点才回去。这样的生活持续了大概半年时间,学习了很多东西当然就不在满足于现状,就想去看看更大的世界。现在想来虽然当时觉得那位同事的代码烂的不行,但还是很感谢他带我入了门,心里认为他或许才是我的第一个师傅。</p><p>于是在18年4月到了深圳,也算是和女朋友重逢了。</p><h2 id="第二份工作"><a href="#第二份工作" class="headerlink" title="第二份工作"></a>第二份工作</h2><p>第二份工作去了招商局金融科技有限公司,当时初来乍到,听到”金融科技”感觉很吊的样子,有是个国企,也就没多想就签了。来之后才发现这里也是个初创公司,人员水平也参差不齐。我的工作也是零零散散,先做过一段时间的python,当时是一个人脸识别的考勤项目,算法也是个毕业生给的,不过效果一直不怎么样,但是部门还在一直往里面砸钱。事情做到一半就去了博时基金出差,相当于写了个没什么用的定时任务,当然也是环境所限,并不允许太多的发挥。不过博时的饭是真的好吃。 </p><p> 回公司后好在公司架构调整,把我调到了另一个部门,做的是金融风控的项目,我也算是开始真正的融入集体,这时才知道前端,UI,产品,项目经理这些人的工作流程,开始真正的团队合作。这段时间认识了很多朋友,也是我到深圳以来过得最开心的一段时光。在工作上,个人能力还是比较受肯定的,逐渐的很多东西我都负责起来,也作一些简单的架构设计,帮同事解决一些问题。但是后来随着项目的发展和个人理想的一些偏差,还是选择了离开。</p><h2 id="第三份工作"><a href="#第三份工作" class="headerlink" title="第三份工作"></a>第三份工作</h2><p> 当时面了阿里,OPPO,VIVO这几个在深圳比较有名气的公司。腾讯一直简历都没能过,也算是我的一个心结。像我这么要强的人,以后有机会一定要了却这个心愿。</p><p> 最终在18年11月入职了OPPO,OPPO对于我来说是一个巨大的鼓励。一路走来,随着自己的提升,也获得了相应的回报。同时在入职一段时间后才发现自己的懂得还完全不够,过去能处理的是单体架构,对于分布式大多停留在理论层面,而在OPPO需要解决很多线上实际的问题。很多问题没有头绪,优化不知从何下手,而这些又不是看看视频课看看博客可以学到的东西了,需要自己积累沉淀。希望自己可以早日突破。</p><p> 在角色上,发现自己做成了一颗小螺丝钉,业务逻辑复杂,线上问题定位,对接业务方,答疑解惑每天消耗了大量的时间,周末也感觉很疲惫,自己学习的时间越来越少,当然这也有自己怠惰的原因,换了新工作膨胀了。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>时至今日已经适应了新的环境,有时候会很想念老同事。希望新的一年能够深入了解技术,不要浮于表面,积累一些自己独有的问题处理经验。</p><p>周末能安安静静写一下代码，如果每周都坚持抽一点时间精进自己，你就已经超过绝大部分的人了</p><p>生活上希望能够开始做一些理财计划,防止中年危机。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>String.intern</title>
      <link href="/2019/08/04/String-intern/"/>
      <url>/2019/08/04/String-intern/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="external">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></p></blockquote><p>在美团技术博客上看到了这篇文章,涨了见识,简单总结一下。</p><ul><li>如果是用双引号初始化的字符串会直接放在常量池中</li><li>其他初始化字符串的方式可以通过调用inern方法放入常量池</li></ul><p>常量池的大小是有限的,结果类似于hashmap,一旦产生hash冲突就会使用链地址法,所以当数据量非常大并且会发生改变的时候,频繁调用intern会导致链表过长,性能降低。jdk6默认大小是1066,可以通过jvm参数调整这个hashmap的大小。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Eureka源码浅析</title>
      <link href="/2019/08/04/Eureka%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
      <url>/2019/08/04/Eureka%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5hmytu3exj30k80qywht.jpg" width="50%" height="50%"></p><p>首先eureka整体使用了gradle构建,从依赖上来看,使用的http作为通讯协议,内部使用了guice作为ioc框架,不少中间件都会使用guice,例如es。web容器使用jersey,国内还是很少使用这些依赖。 </p><p>大概了解了一下框架情况,打算从eureka几个关键功能去看一下源码的具体实现</p><ul><li>eureka server</li><li>eureka client</li><li>注册</li><li>续租</li><li>下线</li><li>自我保护</li></ul><h2 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h2><p>server 的启动类在</p><blockquote><p>com.netflix.eureka.EurekaBootStrap</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public EurekaBootStrap(EurekaClient eurekaClient) &#123;</div><div class="line">    this.eurekaClient = eurekaClient;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过构造函数来看,server内部传入了一个client,可以猜到server其实也是一个client,只是增加了一些特殊的功能,eureka的核心功能都在client模块。这也比较符合一个p2p集群的设计。</p><p>server实现了ServletContextListener接口,在servelet容器启动时会调用contextInitialized方法初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public void contextInitialized(ServletContextEvent event) &#123;</div><div class="line">        try &#123;</div><div class="line">            initEurekaEnvironment();</div><div class="line">            initEurekaServerContext();</div><div class="line"></div><div class="line">            ServletContext sc = event.getServletContext();</div><div class="line">            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">            logger.error(&quot;Cannot bootstrap eureka server :&quot;, e);</div><div class="line">            throw new RuntimeException(&quot;Cannot bootstrap eureka server :&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>第一行代码主要是根据配置文件初始化eureka的环境,非常简单。主要关注第二行,eureka上下文的初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">protected void initEurekaServerContext() throws Exception &#123;</div><div class="line">    </div><div class="line">    //创建配置</div><div class="line">        EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();</div><div class="line">// 请求和响应数据</div><div class="line">JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div><div class="line">        XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);</div><div class="line"></div><div class="line">        //编解码器</div><div class="line">        ServerCodecs serverCodecs = new DefaultServerCodecs(eurekaServerConfig);</div><div class="line"></div><div class="line">       //根据配置创建eureka client和applicationInfoManager</div><div class="line">        ApplicationInfoManager applicationInfoManager = null;</div><div class="line">        if (eurekaClient == null) &#123;</div><div class="line">            EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())</div><div class="line">                    ? new CloudInstanceConfig()</div><div class="line">                    : new MyDataCenterInstanceConfig();</div><div class="line">            </div><div class="line">            applicationInfoManager = new ApplicationInfoManager(</div><div class="line">                    instanceConfig, new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());</div><div class="line">            </div><div class="line">            EurekaClientConfig eurekaClientConfig = new DefaultEurekaClientConfig();</div><div class="line">            eurekaClient = new DiscoveryClient(applicationInfoManager, eurekaClientConfig);</div><div class="line">        &#125; else &#123;</div><div class="line">            applicationInfoManager = eurekaClient.getApplicationInfoManager();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//创建应用实例注册表</div><div class="line">        PeerAwareInstanceRegistry registry;</div><div class="line">        if (isAws(applicationInfoManager.getInfo())) &#123;</div><div class="line">            // aws相关</div><div class="line">        &#125; else &#123;</div><div class="line">            registry = new PeerAwareInstanceRegistryImpl(</div><div class="line">                    eurekaServerConfig,</div><div class="line">                    eurekaClient.getEurekaClientConfig(),</div><div class="line">                    serverCodecs,</div><div class="line">                    eurekaClient</div><div class="line">            );</div><div class="line">        &#125;</div><div class="line">//加入server集群</div><div class="line">        PeerEurekaNodes peerEurekaNodes = getPeerEurekaNodes(</div><div class="line">                registry,</div><div class="line">                eurekaServerConfig,</div><div class="line">                eurekaClient.getEurekaClientConfig(),</div><div class="line">                serverCodecs,</div><div class="line">                applicationInfoManager</div><div class="line">        );</div><div class="line"></div><div class="line">//将上面的信息封装为server上下文</div><div class="line">        serverContext = new DefaultEurekaServerContext(</div><div class="line">                eurekaServerConfig,</div><div class="line">                serverCodecs,</div><div class="line">                registry,</div><div class="line">                peerEurekaNodes,</div><div class="line">                applicationInfoManager</div><div class="line">        );</div><div class="line">//将上下文信息给EurekaServerContextHolder,可以通过这个类进行外部访问</div><div class="line">        EurekaServerContextHolder.initialize(serverContext);</div><div class="line"></div><div class="line">        serverContext.initialize();</div><div class="line">        logger.info(&quot;Initialized server context&quot;);</div><div class="line"></div><div class="line">        //获取其他server节点的注册信息</div><div class="line">        int registryCount = registry.syncUp();</div><div class="line">        registry.openForTraffic(applicationInfoManager, registryCount);</div><div class="line"></div><div class="line">        //注册监控信息</div><div class="line">        EurekaMonitors.registerAllStats();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">```    </div><div class="line"></div><div class="line">通过上面的过程就完成了server节点的初始化工作</div><div class="line"></div><div class="line">## Eureka Client</div></pre></td></tr></table></figure><p>public class DiscoveryClient implements EurekaClient {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">eurekaClient默认只有一个实现类就是DiscoveryClient,根据接口方法信息,client提供的功能有:</div><div class="line"></div><div class="line">* 实例注册</div><div class="line">* 刷新租约</div><div class="line">* 释放租约</div><div class="line">* 实例信息查询</div></pre></td></tr></table></figure></p><p>DiscoveryClient(<br>ApplicationInfoManager applicationInfoManager,<br>EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,<br>Provider<backupregistry> backupRegistryProvider,<br>EndpointRandomizer endpointRandomizer){}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">client的构造函数默认需要提供五个参数,其中ApplicationInfo比较重要,其他几个都属于配置类的参数,根据相关配置封装为dao传入就可以了。</div><div class="line"></div><div class="line">代码逻辑都比较简单,根据配置初始化信息,创建一个2个线程的线程池,一个线程执行心跳定时任务,一个定时刷新任务。</div><div class="line"></div><div class="line"></div><div class="line">## 注册</div><div class="line"></div><div class="line">### client端</div><div class="line"></div><div class="line">注册发生的时机有两个,一个时client刚启动去server注册,另一个就是更新了client的关键信息,如host,instanceId等要重新到server注册</div></pre></td></tr></table></figure></backupregistry></p><p>boolean register() throws Throwable {<br>        EurekaHttpResponse<void> httpResponse;<br>        try {<br>            httpResponse = eurekaTransport.registrationClient.register(instanceInfo);<br>        } catch (Exception e) {<br>            logger.warn(PREFIX + “{} - registration failed {}”, appPathIdentifier, e.getMessage(), e);<br>            throw e;<br>        }<br>        return httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注册传入的参数就是instanceInfo,也就是当前client节点的信息</div></pre></td></tr></table></figure></void></p><pre><code>@Overridepublic EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) {    String urlPath = &quot;apps/&quot; + info.getAppName();    Response response = null;    try {        Builder resourceBuilder = jerseyClient.target(serviceUrl).path(urlPath).request();        addExtraProperties(resourceBuilder);        addExtraHeaders(resourceBuilder);        response = resourceBuilder                .accept(MediaType.APPLICATION_JSON)                .acceptEncoding(&quot;gzip&quot;)                .post(Entity.json(info));        return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();    } finally {        if (logger.isDebugEnabled()) {            logger.debug(&quot;Jersey2 HTTP POST {}/{} with instance {}; statusCode={}&quot;, serviceUrl, urlPath, info.getId(),                    response == null ? &quot;N/A&quot; : response.getStatus());        }        if (response != null) {            response.close();        }    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">实际执行的代码也比较简单,类似于使用restTemplate发送到一个json接口</div><div class="line"></div><div class="line"></div><div class="line">### server端</div><div class="line"></div><div class="line">server端的接收在</div><div class="line"></div><div class="line">&gt;com.netflix.eureka.resources.ApplicationResource#addInstance</div><div class="line"></div><div class="line"></div><div class="line">核心代码只有一行</div></pre></td></tr></table></figure><p>registry.register(info, “true”.equals(isReplication));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p><p>@Override<br>    public void register(final InstanceInfo info, final boolean isReplication) {<br>        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;<br>        if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) {<br>            leaseDuration = info.getLeaseInfo().getDurationInSecs();<br>        }<br>        super.register(info, leaseDuration, isReplication);<br>        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">内部执行逻辑首先初始化租约时间,默认90s。如果info自带了租约信息,则使用带过来的。执行父类的注册方法完成注册,接着向其他server扩散这个注册信息。</div></pre></td></tr></table></figure></p><p>public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {<br>        try {<br>        //获取读锁 这里其实非常烧脑,对于注册操作明明是个写操作,却使用了读锁,<br>        //后面会针对读写锁的使用专门分析一下<br>            read.lock();<br>        //判断这个instanceId是否有租约信息,有的话就不是第一次注册<br>            Map<string, lease<instanceinfo="">&gt; gMap = registry.get(registrant.getAppName());<br>            REGISTER.increment(isReplication);<br>            if (gMap == null) {<br>                final ConcurrentHashMap<string, lease<instanceinfo="">&gt; gNewMap = new ConcurrentHashMap<string, lease<instanceinfo="">&gt;();<br>                //注册应用<br>                gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);<br>                if (gMap == null) {<br>                    gMap = gNewMap;<br>                }<br>            }<br>            Lease<instanceinfo> existingLease = gMap.get(registrant.getId());<br>            // instance已经有租约信息<br>            if (existingLease != null &amp;&amp; (existingLease.getHolder() != null)) {<br>                Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();<br>                Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();</instanceinfo></string,></string,></string,></p><pre><code>   //如果server已经有这个instance的注册信息,   //并且有效时间大于这次注册的有效时间,则使用server的替换传进来的参数,   //这次的注册可能是因为网络延迟导致的过期注册信息传过来    if (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) {        registrant = existingLease.getHolder();    }} else {    // instance第一次注册,先调整一些参数,与自我保护机制有关    synchronized (lock) {        if (this.expectedNumberOfClientsSendingRenews &gt; 0) {            this.expectedNumberOfClientsSendingRenews = this.expectedNumberOfClientsSendingRenews + 1;            updateRenewsPerMinThreshold();        }    }}//封装租约信息Lease&lt;InstanceInfo&gt; lease = new Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);if (existingLease != null) {    lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());}gMap.put(registrant.getId(), lease);//这个队列的信息只是用于server界面展示用,没有实际业务意义synchronized (recentRegisteredQueue) {    recentRegisteredQueue.add(new Pair&lt;Long, String&gt;(            System.currentTimeMillis(),            registrant.getAppName() + &quot;(&quot; + registrant.getId() + &quot;)&quot;));}</code></pre><p>//设置应用实例的覆盖状态,可以在不关闭应用的情况下,关闭某些服务<br>            if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) {</p><pre><code>    if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) {        overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());    }}InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());if (overriddenStatusFromMap != null) {    logger.info(&quot;Storing overridden status {} from map&quot;, overriddenStatusFromMap);    registrant.setOverriddenStatus(overriddenStatusFromMap);}InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);registrant.setStatusWithoutDirty(overriddenInstanceStatus);</code></pre><p> //服务上线<br>            if (InstanceStatus.UP.equals(registrant.getStatus())) {<br>                lease.serviceUp();<br>            }<br>            registrant.setActionType(ActionType.ADDED);<br>            recentlyChangedQueue.add(new RecentlyChangedItem(lease));<br>            //设置租约的更新时间 并清空缓存<br>            registrant.setLastUpdatedTimestamp();<br>            invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());<br>        } finally {<br>            read.unlock();<br>        }<br>    }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">服务注册的逻辑还是比较复杂,主要是租约和覆盖状态相关的逻辑判断比较多,又涉及到缓存的处理。</div><div class="line"></div><div class="line"></div><div class="line">## 下线&amp;过期</div><div class="line"></div><div class="line"></div><div class="line">下线和过期操作是完全不同的两个逻辑,下线操作是由client主动发起的,过期操作则可能是一些网络异常导致的,所以server端会提供一些保护机制。</div><div class="line"></div><div class="line">对于下线的client操作比较简单,封装结构体然后post到server端就可以了,主要看一下server端的处理逻辑</div><div class="line"></div><div class="line">###下线</div><div class="line"></div><div class="line">&gt;com.netflix.eureka.resources.InstanceResource#cancelLease</div></pre></td></tr></table></figure><p>protected boolean internalCancel(String appName, String id, boolean isReplication) {<br>        try {<br>        //获取读锁<br>            read.lock();<br>            CANCEL.increment(isReplication);<br>       //获取租约信息 并清除<br>            Map<string, lease<instanceinfo="">&gt; gMap = registry.get(appName);<br>            Lease<instanceinfo> leaseToCancel = null;<br>            if (gMap != null) {<br>                leaseToCancel = gMap.remove(id);<br>            }<br>       //加入队列,方便进行增量同步到其他server<br>            synchronized (recentCanceledQueue) {<br>                recentCanceledQueue.add(new Pair<long, string="">(System.currentTimeMillis(), appName + “(“ + id + “)”));<br>            }<br>       //删除相关覆盖状态信息<br>            InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);<br>            if (instanceStatus != null) {<br>                logger.debug(“Removed instance id {} from the overridden map which has value {}”, id, instanceStatus.name());<br>            }</long,></instanceinfo></string,></p><pre><code>        //instance没有相关租约信息        if (leaseToCancel == null) {            CANCEL_NOT_FOUND.increment(isReplication);            logger.warn(&quot;DS: Registry: cancel failed because Lease is not registered for: {}/{}&quot;, appName, id);            return false;        } else {       //instance租约信息存在,进行取消             leaseToCancel.cancel();            InstanceInfo instanceInfo = leaseToCancel.getHolder();            String vip = null;            String svip = null;            if (instanceInfo != null) {                instanceInfo.setActionType(ActionType.DELETED);                recentlyChangedQueue.add(new RecentlyChangedItem(leaseToCancel));                instanceInfo.setLastUpdatedTimestamp();                vip = instanceInfo.getVIPAddress();                svip = instanceInfo.getSecureVipAddress();            }            //清除缓存            invalidateCache(appName, vip, svip);            return true;        }    } finally {        read.unlock();    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">相比注册逻辑,取消操作简单许多。</div><div class="line"></div><div class="line">### 过期</div><div class="line"></div><div class="line">过期逻辑发生在servder端的定时检测,是在server端启动的时候就进行了初始化。</div><div class="line"></div><div class="line">&gt;com.netflix.eureka.registry.AbstractInstanceRegistry.EvictionTask</div><div class="line"></div><div class="line">主要代码逻辑如下:</div></pre></td></tr></table></figure><p>public void evict(long additionalLeaseMs) {<br>        logger.debug(“Running the evict task”);</p><pre><code>    if (!isLeaseExpirationEnabled()) {        logger.debug(&quot;DS: lease expiration is currently disabled.&quot;);        return;    }    //获取所有过期的instance    List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = new ArrayList&lt;&gt;();    for (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) {        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();        if (leaseMap != null) {            for (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) {                Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();                if (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != null) {                    expiredLeases.add(lease);                }            }        }    }    //因为可能受到gc或者本地时间的影响,造成一些instance租约超时,    //这时应该引入一些容错机制,就是eureka的自我保护机制,    //会根据公式计算出一个阈值,过期的数量不能超过这个阈值    int registrySize = (int) getLocalRegistrySize();    int registrySizeThreshold = (int) (registrySize * serverConfig.getRenewalPercentThreshold());    int evictionLimit = registrySize - registrySizeThreshold;    //得到最终的驱逐数量    int toEvict = Math.min(expiredLeases.size(), evictionLimit);    if (toEvict &gt; 0) {        //随机驱逐        Random random = new Random(System.currentTimeMillis());        for (int i = 0; i &lt; toEvict; i++) {            // Pick a random item (Knuth shuffle algorithm)            int next = i + random.nextInt(expiredLeases.size() - i);            Collections.swap(expiredLeases, i, next);            Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);            String appName = lease.getHolder().getAppName();            String id = lease.getHolder().getId();            EXPIRED.increment();            internalCancel(appName, id, false);        }    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里如果关闭了保护模式,效果就分批驱逐,默认参数是0.85</div></pre></td></tr></table></figure><p>// 假设 20 个租约，其中有 10 个租约过期。</p><p>// 第一轮执行开始<br>int registrySize = 20;<br>int registrySizeThreshold = (int) (20 * 0.85) = 17;<br>int evictionLimit = 20 - 17 = 3;<br>int toEvict = Math.min(10, 3) = 3;<br>// 第一轮执行结束，剩余 17 个租约，其中有 7 个租约过期。</p><p>// 第二轮执行开始<br>int registrySize = 17;<br>int registrySizeThreshold = (int) (17 * 0.85) = 14;<br>int evictionLimit = 17 - 14 = 3;<br>int toEvict = Math.min(7, 3) = 3;<br>// 第二轮执行结束，剩余 14 个租约，其中有 4 个租约过期。</p><p>// 第三轮执行开始<br>int registrySize = 14;<br>int registrySizeThreshold = (int) (14 * 0.85) = 11;<br>int evictionLimit = 14 - 11 = 3;<br>int toEvict = Math.min(4, 3) = 3;<br>// 第三轮执行结束，剩余 11 个租约，其中有 1 个租约过期。</p><p>// 第四轮执行开始<br>int registrySize = 11;<br>int registrySizeThreshold = (int) (11 * 0.85) = 9;<br>int evictionLimit = 11 - 9 = 2;<br>int toEvict = Math.min(1, 2) = 1;<br>// 第四轮执行结束，剩余 10 个租约，其中有 0 个租约过期。结束。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里使用随机清理的好出就是,可以防止一个应用的服务一次全部过期。</div><div class="line"></div><div class="line"></div><div class="line">## 自我保护机制</div><div class="line"></div><div class="line">当Eureka Server节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该Eureka Server节点会自动退出自我保护模式。</div><div class="line"></div><div class="line"></div><div class="line">### 触发条件</div><div class="line"></div><div class="line">&gt;com.netflix.eureka.registry.AbstractInstanceRegistry#evict(long)</div><div class="line"></div><div class="line">这里在驱逐过期服务之前会进行判断,如果过期enable才可以清除。enable包括两种判断,第一就是在配置上打开了保护模式,另一种就是下面的判断:</div><div class="line"></div><div class="line">每分钟允许更新的数量&gt;0&amp;&amp;上一分钟更新的数量&gt;每分钟允许更新的数量</div></pre></td></tr></table></figure></p><p>public boolean isLeaseExpirationEnabled() {<br>        if (!isSelfPreservationModeEnabled()) {<br>            // The self preservation mode is disabled, hence allowing the instances to expire.<br>            return true;<br>        }<br>        return numberOfRenewsPerMinThreshold &gt; 0 &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">当每分钟心跳次数( renewsLastMin ) 小于 numberOfRenewsPerMinThreshold 时,</div><div class="line">并且开启自动保护模式开关( eureka.enableSelfPreservation = true ) 时,</div><div class="line">触发自动保护机制，不再自动过期租约。</div><div class="line"></div><div class="line">### 公式</div><div class="line"></div><div class="line">* expectedNumberOfRenewsPerMin=当前应用注册数*2</div><div class="line">* numberOfRenewsPerMinThreshold= numberOfRenewsPerMinThreshold* eureka.renewalPercentThreshold</div><div class="line"></div><div class="line"></div><div class="line">这里×2是因为默认每30s注册一次,所以每分钟就要×2。eureka.renewalPercentThreshold默认是0.85。所以除非有特殊情况,不要去修改心跳频率,因为这会影响自我保护机制。</div><div class="line"></div><div class="line"></div><div class="line">## 续租</div><div class="line"></div><div class="line">服务第一次到server可以获得一个90s的租约,此后每30s通过心跳进行续租。</div><div class="line"></div><div class="line">&gt; com.netflix.discovery.DiscoveryClient#initScheduledTasks</div></pre></td></tr></table></figure></p><p>scheduler.schedule(<br>                    new TimedSupervisorTask(<br>                            “heartbeat”,<br>                            scheduler,<br>                            heartbeatExecutor,<br>                            renewalIntervalInSecs,<br>                            TimeUnit.SECONDS,<br>                            expBackOffBound,<br>                            new HeartbeatThread()<br>                    ),<br>                    renewalIntervalInSecs, TimeUnit.SECONDS);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">初始化定时任务,内容在HeartBeat线程</div></pre></td></tr></table></figure></p><pre><code>boolean renew() {    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;    try {        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);        logger.debug(PREFIX + &quot;{} - Heartbeat status: {}&quot;, appPathIdentifier, httpResponse.getStatusCode());        if (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) {            REREGISTER_COUNTER.increment();            logger.info(PREFIX + &quot;{} - Re-registering apps/{}&quot;, appPathIdentifier, instanceInfo.getAppName());            long timestamp = instanceInfo.setIsDirtyWithTime();            boolean success = register();            if (success) {                instanceInfo.unsetIsDirty(timestamp);            }            return success;        }        return httpResponse.getStatusCode() == Status.OK.getStatusCode();    } catch (Throwable e) {        logger.error(PREFIX + &quot;{} - was unable to send heartbeat!&quot;, appPathIdentifier, e);        return false;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过put一个rest接口实现续租</div><div class="line"></div><div class="line">server端通过renewLease接口接受rest参数</div><div class="line"></div><div class="line">&gt;com.netflix.eureka.resources.InstanceResource#renewLease</div></pre></td></tr></table></figure><p>public boolean renew(final String appName, final String id, final boolean isReplication) {<br>        if (super.renew(appName, id, isReplication)) {<br>            replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);<br>            return true;<br>        }<br>        return false;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server接到参数后首先会renew自己的服务信息,接着发布到server集群。</div></pre></td></tr></table></figure></p><p>public boolean renew(String appName, String id, boolean isReplication) {<br>        RENEW.increment(isReplication);<br>        Map<string, lease<instanceinfo="">&gt; gMap = registry.get(appName);<br>        Lease<instanceinfo> leaseToRenew = null;<br>        if (gMap != null) {<br>            leaseToRenew = gMap.get(id);<br>        }<br>        //租约不存在 返回false<br>        if (leaseToRenew == null) {<br>            RENEW_NOT_FOUND.increment(isReplication);<br>            return false;<br>        } else {<br>            InstanceInfo instanceInfo = leaseToRenew.getHolder();<br>            if (instanceInfo != null) {<br>                InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus(<br>                        instanceInfo, leaseToRenew, isReplication);<br>                 //UNKNOWN状态无法续约<br>                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {<br>                    RENEW_NOT_FOUND.increment(isReplication);<br>                    return false;<br>                }<br>                //使用最终状态覆盖应用的状态<br>                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {<br>                instanceInfo.getOverriddenStatus().name(),<br>                instanceInfo.getId());<br>                instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);<br>                }<br>            }<br>            //续约成功<br>            renewsLastMin.increment();<br>            leaseToRenew.renew();<br>            return true;<br>        }<br>    }<br>```    </instanceinfo></string,></p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><blockquote><p>com.netflix.eureka.registry.AbstractInstanceRegistry</p></blockquote><p>涉及读写锁的方法如下,可以看到对于注册,取消,过期,这类的写操作使用了读锁。而get这种读操作使用写锁。</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5ithbxgcwj31hy0o4jta.jpg" alt=""></p><p>getApplicationDeltasFromMultipleRegions这是唯一一个使用了写锁的方法,这个方法需要保证recentChangedQueue和registry的状态一致,不然会导致增量应用实例的集合不准确。为了达到这个效果,需要和使用了读锁的几个方法做互斥。这时有几个方案:</p><ol><li>全部加锁</li><li>getApplicationDeltasFromMultipleRegions使用读锁,其他五个使用写锁</li><li>getApplicationDeltasFromMultipleRegions使用写锁,其他五个使用读锁</li></ol><p>如果其他五个方法使用了写锁,那必然造成很大的冲突影响性能,并且getApplicationDeltasFromMultipleRegions使用了缓存,只有过期才会调用写锁,所以使用写锁的频率会降低,因此使用了这样的设计方案。</p><p>由于renew方法每次心跳都会执行这里的逻辑,因此加锁的性能损耗比较大,所以没有使用锁,在某些极端情况下可能会造成数据不一致,但是在下一次心跳过来的时候会修正这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次jvm参数优化过程</title>
      <link href="/2019/07/27/%E8%AE%B0%E4%B8%80%E6%AC%A1jvm%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/07/27/%E8%AE%B0%E4%B8%80%E6%AC%A1jvm%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个功能,将pdf转成html然后上传到es进行文档检索。在做大批量的文件解析时,发现内存消耗的厉害,平时项目<br>内存占用一般在2G左右,现在飙升到了8G。这时任务才跑了1/3,担心生产会有问题,所以决定排查一下内存消耗。</p><p><img src="https://s2.ax1x.com/2019/07/26/emzF2D.png" alt="emzF2D.png"></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>首先检查了一下错误日志,发现没有报错,说明都是正常消耗,还没有OOM等要命的问题</li><li>看了一下gc日志,发现gc日志在疯狂打印,比较明显的提示就是 Allocation Failed</li><li>dump了一下内存快照: jmap–dump:live,format=b,file=dump.bin 1</li></ol><p>将gc.log 和 dump.bin文件下载到本地</p><p>dump文件使用MAT分析</p><blockquote><p><a href="https://www.eclipse.org/mat/" target="_blank" rel="external">https://www.eclipse.org/mat/</a></p></blockquote><p>gc.log使用人工没有智能来分析,首先确定一下现有的jvm参数,因为公司的Dockerfile封装了java的启动参数，所以使用</p><blockquote><p>ps aux|grep java</p></blockquote><p>清除一些没有用的内容后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar  -XX:+UseConcMarkSweepGC</div></pre></td></tr></table></figure><p>竟然只指定了使用cms gc - -,有点坑爹</p><blockquote><p>优化目标: 主要降低full gc的时间和次数,minor gc 随缘优化,总时间减少就可以</p></blockquote><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="GC-LOG分析"><a href="#GC-LOG分析" class="headerlink" title="GC LOG分析"></a>GC LOG分析</h2><p>大概看了一下GC日志内容,是以cms的gc过程循环打印的，所以截取一份较早时间的日志和较晚的比较一下:</p><ol><li>早</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">9.411: [GC (Allocation Failure) 9.411: [ParNew: 73185K-&gt;3665K(76800K), 0.0178127 secs] 96691K-&gt;27510K(247488K), 0.0179101 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] </div><div class="line">9.602: [GC (Allocation Failure) 9.602: [ParNew: 71953K-&gt;7230K(76800K), 0.0092362 secs] 95798K-&gt;31284K(247488K), 0.0093250 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">9.712: [GC (Allocation Failure) 9.712: [ParNew: 75518K-&gt;4273K(76800K), 0.0154785 secs] 99572K-&gt;30230K(247488K), 0.0155762 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] </div><div class="line">9.986: [GC (Allocation Failure) 9.986: [ParNew: 72561K-&gt;4198K(76800K), 0.0077535 secs] 98518K-&gt;30155K(247488K), 0.0078248 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">10.101: [GC (Allocation Failure) 10.101: [ParNew: 72486K-&gt;3239K(76800K), 0.0061450 secs] 98443K-&gt;29196K(247488K), 0.0062183 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">10.210: [GC (Allocation Failure) 10.210: [ParNew: 71527K-&gt;4158K(76800K), 0.0086700 secs] 97484K-&gt;30115K(247488K), 0.0087512 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">10.386: [GC (Allocation Failure) 10.386: [ParNew: 72446K-&gt;3962K(76800K), 0.0208521 secs] 98403K-&gt;29919K(247488K), 0.0209370 secs] [Times: user=0.07 sys=0.00, real=0.03 secs] </div><div class="line">10.619: [GC (Allocation Failure) 10.619: [ParNew: 72250K-&gt;4710K(76800K), 0.0101005 secs] 98207K-&gt;31336K(247488K), 0.0101816 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] </div><div class="line">10.786: [GC (Allocation Failure) 10.786: [ParNew: 72998K-&gt;8511K(76800K), 0.0167864 secs] 99624K-&gt;36963K(247488K), 0.0168856 secs] [Times: user=0.07 sys=0.00, real=0.02 secs] </div><div class="line">10.949: [GC (Allocation Failure) 10.949: [ParNew: 76799K-&gt;8512K(76800K), 0.0215472 secs] 105251K-&gt;41344K(247488K), 0.0216415 secs] [Times: user=0.07 sys=0.00, real=0.02 secs] </div><div class="line">11.122: [GC (Allocation Failure) 11.123: [ParNew: 76800K-&gt;6231K(76800K), 0.0065761 secs] 109632K-&gt;39403K(247488K), 0.0066749 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </div><div class="line">11.278: [GC (Allocation Failure) 11.279: [ParNew: 74519K-&gt;6285K(76800K), 0.0182307 secs] 107691K-&gt;39504K(247488K), 0.0183195 secs] [Times: user=0.07 sys=0.00, real=0.02 secs]</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">9.012: [GC (CMS Initial Mark) [1 CMS-initial-mark: 24438K(170688K)] 31453K(247488K), 0.0030023 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </div><div class="line">9.015: [CMS-concurrent-mark-start]</div><div class="line">9.077: [CMS-concurrent-mark: 0.056/0.062 secs] [Times: user=0.23 sys=0.00, real=0.07 secs] </div><div class="line">9.078: [CMS-concurrent-preclean-start]</div><div class="line">9.080: [CMS-concurrent-preclean: 0.002/0.002 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </div><div class="line">9.080: [CMS-concurrent-abortable-preclean-start]</div><div class="line">9.215: [GC (Allocation Failure) 9.215: [ParNew: 71219K-&gt;4897K(76800K), 0.0104260 secs] 95658K-&gt;29670K(247488K), 0.0105128 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </div><div class="line">9.328: [CMS-concurrent-abortable-preclean: 0.113/0.248 secs] [Times: user=0.75 sys=0.01, real=0.25 secs] </div><div class="line">9.328: [GC (CMS Final Remark) [YG occupancy: 49393 K (76800 K)]9.328: [Rescan (parallel) , 0.0083639 secs]</div><div class="line">       [weak refs processing, 0.0000296 secs]9.337: [class unloading, 0.0079019 secs]</div><div class="line">       [scrub symbol table, 0.0054243 secs]9.350: [scrub string table, 0.0009452 secs][1 CMS-remark: 24772K(170688K)] 74165K(247488K), 0.0238257 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] </div><div class="line">9.353: [CMS-concurrent-sweep-start]</div><div class="line">9.363: [CMS-concurrent-sweep: 0.010/0.010 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] </div><div class="line">9.363: [CMS-concurrent-reset-start]</div><div class="line">9.372: [CMS-concurrent-reset: 0.009/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</div></pre></td></tr></table></figure><p>分析:</p><p>首先可以确定的是gc的组合: 年轻代ParNew,老年代CMS</p><p>cms垃圾收集器gc有4个过程: 初始化标记(stw)-&gt;并发标记-&gt;重新标记(stw)-&gt;并发清除。但是从gc日志上来看并没有那么简单,实际上有</p><p>Initial Mark(初始标记)-&gt;concurrent-mark(并发标记)-&gt;preclean(预清理)-&gt;abortable-preclean(可中断预清理)-&gt;<br>Final Remark(重新标记)-&gt;concurrent-sweep(并发清理)-&gt;concurrent-reset(并发重置)共7个阶段。</p><p>如果在面试的时候告诉面试官这7个阶段而不是4个阶段,一定可以超过80%的面试者。</p><h3 id="第一个片段表示的是Minor-GC"><a href="#第一个片段表示的是Minor-GC" class="headerlink" title="第一个片段表示的是Minor GC"></a>第一个片段表示的是Minor GC</h3><blockquote><p>[GC (Allocation Failure) 9.411: [ParNew: 73185K-&gt;3665K(76800K), 0.0178127 secs] 96691K-&gt;27510K(247488K), 0.0179101 secs] [Times: user=0.03 sys=0.00, real=0.02 secs]</p></blockquote><ul><li>GC 表示进行的是年轻代的GC</li><li>Allocation Failure GC原因,由于年轻代分配空间不足,触发了Minor gc</li><li>73185K-&gt;3665K 经过Minor GC,年轻代从71mb减少到了3mb</li><li>76800K 年轻代的总大小75mb    </li><li>0.0178127 secs 年轻代GC耗时</li><li>96691K-&gt;27510K 堆空间占用情况94mb-&gt;26m</li><li>247488K 整个堆得大小约240mb</li><li>0.0179101 GC+清理的总共耗时</li></ul><p>分析一下gc情况:开始的时候堆是96mb,年轻代71mb，那么老年代94-71=23mb。结束时堆26mb,年轻代3mb，那么老年代23mb。<br>那么这次gc其实效率是非常高的,几乎没有对象晋升到老年代。GC时间基本都在0.01s左右,所以这里不需要怎么调整。<br>或者可以尝试增大年轻代,减少gc次数,但是有可能会增加每一次的gc时间。</p><h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>由cms引起的gc都是老年代的gc,是主要关注点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9.012: [GC (CMS Initial Mark) [1 CMS-initial-mark: 24438K(170688K)] 31453K(247488K), 0.0030023 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure><ul><li>初始化标记阶段,根据gc root标记可回收对象,会产生stw。</li><li>24438K(170688K) 老年代使用了24mb,共有170mb空间</li><li>31453K(247488K) 整个堆使用了31mb,公有240mb的空间</li><li>0.0030023 secs 并发标记阶段的耗时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">9.015: [CMS-concurrent-mark-start]</div><div class="line">9.077: [CMS-concurrent-mark: 0.056/0.062 secs] [Times: user=0.23 sys=0.00, real=0.07 secs]</div></pre></td></tr></table></figure><p>这个阶段会遍历整个老年代并且标记所有存活的对象，从“初始化标记”阶段找到的GC Roots开始。<br>并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">9.078: [CMS-concurrent-preclean-start]</div><div class="line">9.080: [CMS-concurrent-preclean: 0.002/0.002 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure><p>并发预清理,上面一个阶段在并发标记的时候,可能某些对象状态发生了变化，被jvm标记为dirty。preClean会对这些对象进行可达性分析,然后清除dirty标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">9.080: [CMS-concurrent-abortable-preclean-start]</div><div class="line">9.215: [GC (Allocation Failure) 9.215: [ParNew: 71219K-&gt;4897K(76800K), 0.0104260 secs] 95658K-&gt;29670K(247488K), 0.0105128 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </div><div class="line">9.328: [CMS-concurrent-abortable-preclean: 0.113/0.248 secs] [Times: user=0.75 sys=0.01, real=0.25 secs]</div></pre></td></tr></table></figure><p>可中断的预清理,这里在等待重新标记的间隙进行一些清理工作。可以减少Final Remark阶段的stw时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">9.328: [GC (CMS Final Remark) [YG occupancy: 49393 K (76800 K)]9.328: [Rescan (parallel) , 0.0083639 secs]</div><div class="line">       [weak refs processing, 0.0000296 secs]9.337: [class unloading, 0.0079019 secs]</div><div class="line">       [scrub symbol table, 0.0054243 secs]9.350: [scrub string table, 0.0009452 secs]</div><div class="line">       [1 CMS-remark: 24772K(170688K)] 74165K(247488K), 0.0238257 secs] [Times: user=0.06 sys=0.00, real=0.02 secs]</div></pre></td></tr></table></figure><p>重新标记,会产生stw</p><ul><li>YG occupancy: 49393 K (76800 K) 年轻代使用了49393,容量为76800</li><li>Rescan 停顿并标记</li><li>weak refs processing 处理弱引用</li><li>class unloading 卸载一些不要的类</li><li>scrub symbol table  应该是清理一些符号链接表</li><li>scrub string table 清理一些字符串的引用</li><li>24772K(170688K) 老年带的使用和容量</li><li>74165K(247488K) 整个堆得使用和容量</li><li>0.0238257 secs 耗时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">9.353: [CMS-concurrent-sweep-start]</div><div class="line">9.363: [CMS-concurrent-sweep: 0.010/0.010 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</div></pre></td></tr></table></figure><p>并发清理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">9.363: [CMS-concurrent-reset-start]</div><div class="line">9.372: [CMS-concurrent-reset: 0.009/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]</div></pre></td></tr></table></figure><p>重置一些参数,准备下一次gc。</p><p>这是项目刚启动不久的gc情况,发现这时gc耗时都还可以接受,都只有10ms,20ms。</p><ol><li>晚</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">20725.412: [GC (CMS Initial Mark) [1 CMS-initial-mark: 3352734K(3643636K)] 3361558K(3720436K), 0.0074892 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </div><div class="line">20725.420: [CMS-concurrent-mark-start]</div><div class="line">20725.580: [CMS-concurrent-mark: 0.160/0.160 secs] [Times: user=0.32 sys=0.00, real=0.16 secs] </div><div class="line">20725.580: [CMS-concurrent-preclean-start]</div><div class="line">20725.587: [CMS-concurrent-preclean: 0.007/0.007 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </div><div class="line">20725.587: [CMS-concurrent-abortable-preclean-start]</div><div class="line">20726.825: [GC (Allocation Failure) 20726.825: [ParNew: 75590K-&gt;4377K(76800K), 0.0141963 secs] 3428324K-&gt;3357111K(3720436K), 0.0143311 secs] [Times: user=0.04 sys=0.00, real=0.02 secs] </div><div class="line">20726.894: [GC (Allocation Failure) 20726.894: [ParNew: 71723K-&gt;8002K(76800K), 0.0118239 secs] 3424457K-&gt;3360736K(3720436K), 0.0119725 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </div><div class="line">20726.954: [CMS-concurrent-abortable-preclean: 0.490/1.367 secs] [Times: user=1.90 sys=0.01, real=1.36 secs] </div><div class="line">20726.955: [GC (CMS Final Remark) [YG occupancy: 54892 K (76800 K)]20726.955: [Rescan (parallel) , 0.0182664 secs]20726.973: [weak refs processing, 0.0144155 secs]20726.987: [class unloading, 0.0349071 secs]20727.022: [scrub symbol table, 0.0116247 secs]20727.034: [scrub string table, 0.0015885 secs][1 CMS-remark: 3352734K(3643636K)] 3407626K(3720436K), 0.0830734 secs] [Times: user=0.10 sys=0.00, real=0.09 secs] </div><div class="line">20727.038: [CMS-concurrent-sweep-start]</div><div class="line">20727.694: [GC (Allocation Failure) 20727.694: [ParNew: 76290K-&gt;8512K(76800K), 0.0414213 secs] 2895898K-&gt;2838568K(3720436K), 0.0415563 secs] [Times: user=0.09 sys=0.00, real=0.04 secs] </div><div class="line">20728.550: [GC (Allocation Failure) 20728.550: [ParNew: 76800K-&gt;8512K(76800K), 0.0259377 secs] 2060111K-&gt;2000178K(3720436K), 0.0260683 secs] [Times: user=0.07 sys=0.00, real=0.02 secs] </div><div class="line">20729.426: [GC (Allocation Failure) 20729.426: [ParNew: 76800K-&gt;7522K(76800K), 0.0357161 secs] 812595K-&gt;751373K(3720436K), 0.0358904 secs] [Times: user=0.10 sys=0.00, real=0.04 secs] </div><div class="line">20729.797: [CMS-concurrent-sweep: 2.653/2.759 secs] [Times: user=5.55 sys=0.00, real=2.76 secs] </div><div class="line">20729.797: [CMS-concurrent-reset-start]</div><div class="line">20729.805: [CMS-concurrent-reset: 0.008/0.008 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">19388.266: [GC (Allocation Failure) 19388.266: [ParNew: 71444K-&gt;8512K(76800K), 0.0580897 secs] 2977856K-&gt;2928817K(3720436K), 0.0582062 secs] [Times: user=0.14 sys=0.00, real=0.06 secs] </div><div class="line">19388.397: [GC (Allocation Failure) 19388.397: [ParNew: 76800K-&gt;8512K(76800K), 0.0352685 secs] 2936085K-&gt;2880630K(3720436K), 0.0353905 secs] [Times: user=0.10 sys=0.00, real=0.03 secs] </div><div class="line">19388.506: [GC (Allocation Failure) 19388.506: [ParNew: 76800K-&gt;7459K(76800K), 0.0280484 secs] 2887098K-&gt;2825976K(3720436K), 0.0281762 secs] [Times: user=0.06 sys=0.00, real=0.03 secs] </div><div class="line">19388.596: [GC (Allocation Failure) 19388.596: [ParNew: 73066K-&gt;7391K(76800K), 0.0142430 secs] 2831575K-&gt;2765900K(3720436K), 0.0143670 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] </div><div class="line">19388.663: [GC (Allocation Failure) 19388.663: [ParNew: 75662K-&gt;6742K(76800K), 0.0136076 secs] 2788394K-&gt;2721039K(3720436K), 0.0136992 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] </div><div class="line">19388.717: [GC (Allocation Failure) 19388.717: [ParNew: 73206K-&gt;5184K(76800K), 0.0092950 secs] 2743990K-&gt;2700422K(3720436K), 0.0094194 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] </div><div class="line">19388.802: [GC (Allocation Failure) 19388.803: [ParNew: 73472K-&gt;8512K(76800K), 0.0526273 secs] 2695157K-&gt;2648144K(3720436K), 0.0527772 secs] [Times: user=0.11 sys=0.00, real=0.05 secs] </div><div class="line">19388.921: [GC (Allocation Failure) 19388.921: [ParNew: 76800K-&gt;8512K(76800K), 0.0359122 secs] 2659652K-&gt;2607475K(3720436K), 0.0360345 secs] [Times: user=0.11 sys=0.00, real=0.04 secs]</div></pre></td></tr></table></figure><p>上面是运行了大概6个小时后的情况,对比年轻代,gc时间虽然有些增大,但还可以接受,没有超过100ms。<br>年轻代的大小也没有变化,大概75mb。但是堆得大小明显增长，<br>从240mb变成了3.5G,也就是说老年代增大了3G左右。所以继续看cms的gc过程,在预清理阶段消耗了1.36s,在并发清理阶段消耗了2.76s,所以这次gc大概造成了4-5s的停顿。<br>所以这是主要的优化目标。</p><h2 id="内存dump分析"><a href="#内存dump分析" class="headerlink" title="内存dump分析"></a>内存dump分析</h2><p>因为并没有OOM,Stack OverFlow等错误,所以dump分析的主要目的是看看哪里的对象占用内存较多</p><p><a href="https://imgchr.com/i/enINxx" target="_blank" rel="external"><img src="https://s2.ax1x.com/2019/07/26/enINxx.png" alt="enINxx.png"></a></p><p><a href="https://imgchr.com/i/enoAOK" target="_blank" rel="external"><img src="https://s2.ax1x.com/2019/07/26/enoAOK.png" alt="enoAOK.png"></a></p><p>通过首页的饼图可以发现是我写的pdf-es-worker线程占用内存较多。白色的66Mb是remainder线程,不知道是干嘛的，不用管它。</p><p>接着打开线程分析,排在第一个仍然是pdf-es-worker。这里要提的就是重命名线程池的一个好处,很快就能定位问题。<br>打开这个线程栈,不出所料持有大量的string对象无法释放。接着看string的引用栈,看类名猜到是pdf转html需要的样式库,<br>很多与font相关的内容,猜测是格式转换时需要引用字体库,而字体库又是很大的资源,所以读取的pdf越多,就有越多的样式需要转换。<br>造成了老年代空间猛涨。</p><p>经过上面的分析,从代码层面去优化是没有什么空间了，所以只能优化一下jvm参数,看看能不能有效果。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>首先就是设置xmx和xms,防止对伸缩带来的性能影响。看了一下机器内存是16G,但是用的是docker应该是虚拟机有16G内存,<br>16G分给了N个镜像,每个拿到的就不多了,所以不能给的太多,防止机器异常。<br>因为默认没有设置xmx,所以jvm会根据拿到的环境的内存进行增长,记得好像会增长到内存的1/4?目前最大跑到了3.6G,所以就定到4G吧。</p><p>整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小（元数据区）。</p><p>年轻代GC有些频繁,之前是76800K,大约75M。基本上都是从75000k左右gc到800K,所以这里一个survivor区大约要给1000K,<br>防止放不下引起一次full gc。所以这里可以给年轻代256M,应该够用了。</p><p>加一些cms常用的配置</p><ul><li>UseCMSInitiatingOccupancyOnly </li><li>CMSParallelRemarkEnabled</li><li>XX:CMSInitiatingOccupancyFraction=70 默认68,可以适当调高</li></ul><p>总结一下需要添加的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-server</div><div class="line">-Xmx4g </div><div class="line">-Xms4g </div><div class="line">-Xmn256m </div><div class="line">-XX:+DisableExplicitGC </div><div class="line">-XX:+UseConcMarkSweepGC </div><div class="line">-XX:+CMSParallelRemarkEnabled </div><div class="line">-XX:+UseCMSInitiatingOccupancyOnly </div><div class="line">-XX:CMSInitiatingOccupancyFraction=70</div><div class="line">-Duser.timezone=GMT+8</div></pre></td></tr></table></figure><p>剩下的就是把参数配上去,然后再跑一边这个流程,观察gc变化。</p></the>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类隔离器方案调研</title>
      <link href="/2019/07/15/%E7%B1%BB%E9%9A%94%E7%A6%BB%E5%99%A8%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/"/>
      <url>/2019/07/15/%E7%B1%BB%E9%9A%94%E7%A6%BB%E5%99%A8%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<p>最近在项目中遇到了一个问题,项目原本引用了POI-3.8,为了做一些复杂的报表功能。但是后面再做导入导出功能的时候,发现有很多第三方的包封装的更好,例如阿里的easyexcel,所以打算用在项目中,但是引入之后编译时并没有问题在运行时会抛出ClassNotFound,NoSuchMethod等问题。发现是因为easyexcel引用了高版本的poi与poi3.8不兼容,这种问题maven也没有办法解决。考虑到迁移成本太高,所以自告奋勇准备搞一个类隔离工具,兼容不同版本poi。</p><h2 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h2><h3 id="代码内嵌"><a href="#代码内嵌" class="headerlink" title="代码内嵌"></a>代码内嵌</h3><p>这是个简单粗暴的办法。把缺少的方法或者类抄到自己的项目中,但是这种做法对有代码洁癖的人来说很难接受。</p><h3 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h3><p>工作了两年偶尔会听到这个名词,但是从来没有在工作中接触过。发现OSGI貌似能解决这种问题,所以大概看了一下。</p><blockquote><p><a href="https://blog.csdn.net/acmman/article/details/50848595" target="_blank" rel="external">https://blog.csdn.net/acmman/article/details/50848595</a></p></blockquote><p>这篇文章讲的比较容易理解,简单来说就是把一个项目拆分为若干模块:</p><ol><li>程序运行在一个容器中，由容器来启动和管理各个业务组件。</li><li>每个业务组件有一个独立的ClassLoader，因此不同业务组件之间的依赖不会互相影响.</li><li>支持组件向容器进行服务的注册，以及服务的互相调用。</li></ol><p>不过其实大家采用这个技术主要还是为了做应用的热加载和热更新，仅仅用来做依赖隔离确实有点杀鸡用牛刀了。而且目前大家比较熟悉的就是spring这一套东西,没有理由去换osgi。</p><h3 id="sofa-ark"><a href="#sofa-ark" class="headerlink" title="sofa-ark"></a>sofa-ark</h3><p>sofa-ark是蚂蚁金服开源的一个轻量级的类隔离工具。自称是用fat-jar实现osgi的功能。</p><p>所谓fat—jar技术,简单来说就是将所有依赖打包成一个jar并且可执行的jar,典型的就是springboot。如果打开springboot打包的jar,可以找到一个<strong>MANIFEST.MF</strong>文件,这个文件维护了这个项目的元数据信息,包括依赖jar的路径,启动类路径等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Manifest-Version: 1.0</div><div class="line">Start-Class: mycompany.project.YourClasses</div><div class="line">Spring-Boot-Classes: BOOT-INF/classes/</div><div class="line">Spring-Boot-Lib: BOOT-INF/lib/</div><div class="line">Spring-Boot-Version: 1.5.4.RELEASE</div><div class="line">Main-Class: org.springframework.boot.loader.JarLauncher</div></pre></td></tr></table></figure><p>也就是说，jar包在启动时实际上启动的是springboot自己的JarLauncher，通过这个JarLauncher去加载lib下的依赖，然后去启动Start-Class配置对应下的类</p><p>以上就是Fat-Jar技术的基本原理，其实核心就在于要定义一套Jar包的文件规范，并且写一个打包插件按照这个规范打包，然后写一个Launcher进行解包、用依赖包配置ClassLoader、用反射调用实际main函数。</p><p>sofa-ark会打包三种包:</p><ul><li>ark包         Ark Container实例</li><li>ark biz包     业务包,ark plugin的基础上真正执行业务逻辑的基本单位</li><li>ark plugin包  一些依赖的集合，并且通过MANIFEST文件对这些依赖集合中的类进行访问控制</li></ul><p>事实上从这就看出sofa-ark项目的本质了。sofa-ark项目其实是一个以Ark Container为核心的容器生态。Ark Container可以被理解为OSGI中的那个守护进程，用来管理业务包和插件包，只不过Ark Container不是一个守护进程而只是一个启动类罢了。既然是容器，那么就肯定要支持多应用，Container就要和Biz解耦，从而做到一个Container可以运行多个Biz和多个Plugin。</p><p>对于单个应用的项目，我们当然可以不要Ark Biz包，而是直接用Container包装起来，做成一个可执行文件。但是如果需要多个业务同时运行，我们就可以以Biz包的形式，一个一个往容器里加了。</p><p>sofa-ark也存在一些问题:</p><ol><li>开源时间短,社区不够活跃。一旦遇到问题好像只能去github提issue,能不能解决就靠运气了</li><li>代码侵入性比较强,改动成本大,除非项目一开始就引入了这个东西,后面再依赖改动实在麻烦</li><li>学习成本高,并不是人人都像我一样聪明</li></ol><h2 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h2><p>通过上面的方案调研,好像并没有一个合适的类隔离器,而且类隔离器实现起来并不简单。自己写一个类隔离器的激情几乎已经被浇灭了。我以为只需要自定义一个类加载器去加载指定版本的jar就行了,原理就是一个类唯一标识就是类加载器+类全限定名,简单写了一下发现要动态切换classloader,还遇到了一些其他问题,就没有再弄。最后还是统一使用了低版本的jar,自己封装了一些高级功能。</p><p>以后有机会去做一个jar,通过添加maven依赖就能解决这个问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES默认参数优化</title>
      <link href="/2019/06/30/ES%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
      <url>/2019/06/30/ES%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="ES重要参数调优"><a href="#ES重要参数调优" class="headerlink" title="ES重要参数调优"></a>ES重要参数调优</h2><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p>在es进行升级的时候,可能会导致data、config、plugin这些文件夹被覆盖导致数据丢失,所以再生产环境中,要将重要的文件路径重新设定,放在es的安装路径之外。path.data可以指定多个目录,用逗号分隔。</p><h3 id="避免脑裂"><a href="#避免脑裂" class="headerlink" title="避免脑裂"></a>避免脑裂</h3><ul><li>discovery.zen.min_master_nodes参数对于集群的可靠性来说非常重要,它定义了最少要有多少个节点参与选主,这个参数要设置成master候选节点的quorum数量,也就是大多数。es生产环境至少要有3个节点,并且quorum至少为2。</li><li>es集群是可以动态增加和下线节点的,所以随时可能改变quorum。所以这个参数也是可以通过api随时修改的,在上线和下线是都要进行修改,一旦修改,这个配置就会被持久化。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PUT /_cluster/settings</div><div class="line">&#123;</div><div class="line">&quot;persistent&quot;:&#123;</div><div class="line">&quot;discovery.zen.minimum_master_nodes:2</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="避免无意义的shard重分配"><a href="#避免无意义的shard重分配" class="headerlink" title="避免无意义的shard重分配"></a>避免无意义的shard重分配</h3><ul><li>shard重新复制、移动、删除的过程,会大量消耗网络和硬盘资源。如果所有的节点都可以等待整个集群中的所有节点都完全上线以后,再决定是否要复制和移动shard,性能会好很多。</li><li>gateway.recover_after_nodes 这个参数可以让有足够多的node上线之后,在进行shard recovery的工作</li></ul><h3 id="jvm-heap分配策略"><a href="#jvm-heap分配策略" class="headerlink" title="jvm heap分配策略"></a>jvm heap分配策略</h3><ul><li>es的默认堆大小为2g,几乎再生产都要调整这个大小</li><li>最简单的调整方式就是设置环境变量:ES_HEAP_SIZE=10g 或者在启动参数里面指定 -Xmx -Xms,两个参数设置为一样大,防止resize。在5.x版本之后推荐在jvm.options文件中设置相关参数</li><li>虽然heap对于es来说非常重要,但并不是越大越好。因为es底层使用的lucence也要消耗内存,而lucence消耗的是底层os cache,主要是存放倒排索引以及正排索引。如果lucence内存不足,es性能也不会太好。</li><li>一般可以讲内存一半给es,一半给os cache。甚至可以给os cache更多的空间。如果我们确定不需要对text feild进行聚合操作,那么就不需要fielddata,因为fielddata使用jvm heap。这样更多的内存留给lucence,可以提升索引性能。</li><li>不要给jvm分配超过32g内存，如果heap小于32,jvm会使用指针压缩技术来压缩对象指针。这个技术的核心思想就是:不要让对象指针引用内存中的二进制地址,而是引用对象的偏移量。这就意味着32位指针可以引用400万个对象,而不是400万字节。一旦超过了这个界限,指针就只能去指向二进制地址,这样在64位系统中,指针就会变成8字节,消耗很大的空间。具体大小设置应该根据jvm版本以及机器实际情况而定。</li></ul><h3 id="swapping分配策略"><a href="#swapping分配策略" class="headerlink" title="swapping分配策略"></a>swapping分配策略</h3><p>如果内存和磁盘频繁进行swap,那么会造成性能的极大降低。可以彻底关闭机器上的swap, swapoff -a,如果需要永久关闭,需要在/etc/fstab中配置。在es的配置文件中也可以配置bootstrap.mloclall:true让jvm lock住自己的内存不被swap到磁盘上去。</p><h3 id="file-descriptor检查"><a href="#file-descriptor检查" class="headerlink" title="file descriptor检查"></a>file descriptor检查</h3><p>file descriptor也叫文件句柄,是unix的一种数据结构,用来track打开的文件。在unix中所有东西都是file。因为es需要大量的文件句柄,如果文件句柄耗尽可能造成数据丢失。因此可以将文件句柄调整到65536.在/etc/security/limits.conf中设置。</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES部署相关</title>
      <link href="/2019/06/07/ES%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/06/07/ES%E9%83%A8%E7%BD%B2%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="ES部署相关"><a href="#ES部署相关" class="headerlink" title="ES部署相关"></a>ES部署相关</h2><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><ul><li>bin 执行脚本</li><li>conf 核心配置文件</li><li>data 存放索引shard相关数据</li><li>logs 日志文件</li><li>plugins es插件</li><li>script 脚本文件</li></ul><h3 id="zen-discovery集群发现机制"><a href="#zen-discovery集群发现机制" class="headerlink" title="zen discovery集群发现机制"></a>zen discovery集群发现机制</h3><ol><li>默认情况下,es进程会绑定在自己的回环地址上,也就是127.0.0.1,然后扫描9300~9305端口,尝试跟那些端口上启动的其他es进程通信,然后组成一个集群,这在本地搭集群是非常方便的,但是对于生产是不行的。需要将es绑定在非回环的地址上,才能和其他机器通信。同时需要使用集群发现机制来和其他节点的es node 通信</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">network.host: 主机ip</div><div class="line">http.port:</div></pre></td></tr></table></figure><ol><li>在生产环境中的多台机器部署es,涉及到discovery机制,discovery也负责es集群的master选举</li><li>es是一种p2p的分布式系统架构,而不是m/s主从架构的分布式系统。集群中的每个node是直接跟其他节点进行通信,client可以和任何一个node进行通信,node再转发给其他node进而执行</li><li>两个角色:master node,data node。master node负责维护整个集群的状态信息,俗称metadata,同时在node加入或下线时,重新分配shard。创建或删除索引也是master节点负责。</li><li>es集群的一个基本条件就是cluster.name参数要一致,默认是elasticsearch</li><li>es中默认的discovery机制,就是zen discovery机制,zen discovery提供了unicast discovery集群发现机制,集群发现节点通信依赖transport module,是es底层的网络通信模块和协议</li><li>es默认配置为使用unicast集群发现机制,让经过特殊配置的节点组成一个集群,而不是随便一个节点都可以。在默认配置下,unicast是localhost,因此只能在本机启动多个节点组成集群</li><li>虽然es提供了multicast(多播)机制,但是并不建议在开发环境使用,因为非常脆弱,网络稍微调整都有可能无法发现节点</li></ol><h3 id="zen-discovery原理"><a href="#zen-discovery原理" class="headerlink" title="zen discovery原理"></a>zen discovery原理</h3><ol><li>ping是一个node用来发现其他node的过程</li><li>unicast</li></ol><p>unicast集群发现机制要求配置一个主机列表,用来作为gossip通信协议的路由。这些机器通过hostname指定,ping的时候会被解析为ip地址。单播重要的配置有两个: hosts/hosts.resolve_timeout</p><p>简单来说,如果要让多个节点发现对方并组成一个集群,那么就得有一个中间的公共节点,然后不同的节点就发送请求到这些公共节点,进而交换信息,最后组成集群。</p><ol><li>unicast流程</li></ol><p>(1)初步配置好后,各个节点,首先通过network.host绑定到非回环的ip地址上,从而可以和其他节点通信<br>(2)通过discovery.zen.ping.unicast.hosts配置一批unicast中间路由node<br>(3)所有node可以发送ping到路由node,从路由node获取cluster state<br>(4)所有node中选出master<br>(5)所有node和master通信,然后加入master集群<br>(6)cluster.name需要一致<br>(7)node.name标识一个节点</p><ol><li>master选举</li></ol><p>在完成一个集群的master选举后,每一次有新的节点加入,都会发送一个join request到master node,如果master node停止了,那么集群中的node会再一次进行一次ping过程,并且选举出一个新的master。如果discovery.zen.master_election.ignore_non_master_ping设置为true,会强制区分master候选节点。即node.master=false的节点无权参与选举。</p><h3 id="集群故障探查"><a href="#集群故障探查" class="headerlink" title="集群故障探查"></a>集群故障探查</h3><ul><li>es有两种故障探查机制,第一种是master会ping其他节点。第二种是每个节点都回去ping master确保master存活。</li><li>相关参数:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping_inerval</div><div class="line">ping_timeout</div><div class="line">ping_retries</div></pre></td></tr></table></figure><h3 id="集群状态更新"><a href="#集群状态更新" class="headerlink" title="集群状态更新"></a>集群状态更新</h3><ul><li>master node是集群中唯一可以修改cluster state的节点。master node每次会处理集群状态更新事件,将更新状态发布到每个node上去。每个node都会接受publish message,ack 这个message,但不会应用这个更新。如果master没有在指定时间获取ack,那么这次状态更新就会被拒绝。</li><li>一旦ack的数量符合要求,那么一个commit 的message会发送到所有node,node就会应用这次更新</li></ul><h3 id="master宕机"><a href="#master宕机" class="headerlink" title="master宕机"></a>master宕机</h3><p>master宕机时有两个操作选项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all: 所有操作都被拒绝</div><div class="line">write: 写操作都被拒绝 可读</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang传值or传引用</title>
      <link href="/2019/05/21/Golang%E4%BC%A0%E5%80%BCor%E4%BC%A0%E5%BC%95%E7%94%A8/"/>
      <url>/2019/05/21/Golang%E4%BC%A0%E5%80%BCor%E4%BC%A0%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自:<a href="https://colobu.com/2017/01/05/-T-or-T-it-s-a-question/" target="_blank" rel="external">https://colobu.com/2017/01/05/-T-or-T-it-s-a-question/</a></p></blockquote><p>By reference or by value几乎是每个语言都要去弄清楚的一个问题,看了这篇文章以后有一种恍然大悟的感觉。</p><p>对于Go而言,严格意义上来讲只有一种传递,就是by value。当一个变量当做参数传递的时候,会创建一个变量的副本,然后传递给值或者方法,而这个副本的地址和变量的地址是不同的。</p><p>当变量作为指针被传递的时候,一个新的指针被创建,它指向变量指向的相同的内存地址。表面上看到的这个按指针传递的变量,是实质上只是创建了一个指针副本,将这个指针副本的值传递过去,所以Go只存在值传递。</p><p>当我们理解了这个问题的时候,另一个关键的问题就是:什么时候选择<strong>T</strong>作为参数类型,什么时候选择<strong>*T</strong>作为参数类型?[]T传递的是指针还是值?使用<strong>[]T</strong>还是<strong>[]*T</strong>?那些类型复制和传递的时候会创建副本?什么情况下会发生副本创建?</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="副本的创建"><a href="#副本的创建" class="headerlink" title="副本的创建"></a>副本的创建</h2><h3 id="T副本的创建"><a href="#T副本的创建" class="headerlink" title="T副本的创建"></a>T副本的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">type Bird struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">func passV(b Bird) &#123;</div><div class="line">b.Age++</div><div class="line">b.Name = &quot;Great&quot; + b.Name</div><div class="line">fmt.Printf(&quot;传入修改后的Bird:\t %+v, \t内存地址：%p\n&quot;, b, &amp;b)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">parrot := Bird&#123;Age: 1, Name: &quot;Blue&quot;&#125;</div><div class="line">fmt.Printf(&quot;原始的Bird:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot, &amp;parrot)</div><div class="line">passV(parrot)</div><div class="line">fmt.Printf(&quot;调用后原始的Bird:\t %+v, \t\t内存地址：%p\n&quot;, parrot, &amp;parrot)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原始的Bird:      &#123;Age:1 Name:Blue&#125;,      内存地址:0xc420012260</div><div class="line">传入修改后的Bird: &#123;Age:2 Name:GreatBlue&#125;, 内存地址：0xc4200122c0</div><div class="line">调用后原始的Bird: &#123;Age:1 Name:Blue&#125;,      内存地址：0xc420012260</div></pre></td></tr></table></figure><p>可以看到，在T类型作为参数的时候，传递的参数parrot会将它的副本(内存地址0xc4200122c0)传递给函数passV,在这个函数内对参数的改变不会影响原始的对象。</p><h3 id="T副本的创建-1"><a href="#T副本的创建-1" class="headerlink" title="*T副本的创建"></a>*T副本的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">type Bird struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">func passP(b *Bird) &#123;</div><div class="line">b.Age++</div><div class="line">b.Name = &quot;Great&quot; + b.Name</div><div class="line">fmt.Printf(&quot;传入修改后的Bird:\t %+v, \t内存地址：%p, 指针的内存地址: %p\n&quot;, *b, b, &amp;b)</div><div class="line">&#125;</div><div class="line">func main() &#123;</div><div class="line">parrot := &amp;Bird&#123;Age: 1, Name: &quot;Blue&quot;&#125;</div><div class="line">fmt.Printf(&quot;原始的Bird:\t\t %+v, \t\t内存地址：%p, 指针的内存地址: %p\n&quot;, *parrot, parrot, &amp;parrot)</div><div class="line">passP(parrot)</div><div class="line">fmt.Printf(&quot;调用后原始的Bird:\t %+v, \t内存地址：%p, 指针的内存地址: %p\n&quot;, *parrot, parrot, &amp;parrot)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">原始的Bird: &#123;Age:1 Name:Blue&#125;,      内存地址：0xc420076000, 指针的内存地址: 0xc420074000</div><div class="line">传入修改后的Bird: &#123;Age:2 Name:GreatBlue&#125;, 内存地址：0xc420076000, 指针的内存地址: 0xc420074010</div><div class="line">调用后原始的Bird: &#123;Age:2 Name:GreatBlue&#125;, 内存地址：0xc420076000, 指针的内存地址: 0xc420074000</div></pre></td></tr></table></figure><p>可以看到在函数passP中，参数p是一个指向Bird的指针，传递参数给它的时候会创建指针的副本(0xc420074010)，只不过指针0xc420074000和0xc420074010都指向内存地址0xc420076000。 函数内对*T的改变显然会影响原始的对象，因为它是对同一个对象的操作。</p><p>当然，一位对Go有深入了解的读者都已经对这个知识有所了解，也明白了T和*T作为参数的时候副本创建的不同。</p><h2 id="如何选择T或-T"><a href="#如何选择T或-T" class="headerlink" title="如何选择T或*T"></a>如何选择T或*T</h2><p>在定义函数和方法的时候，作为一位资深的Go开发人员，一定会对函数的参数和返回值定义成T和<em>T深思熟虑，有些情况下可能还会有些苦恼。那么什么时候才应该把参数定义成类型T,什么情况下定义成类型</em>T呢。<br>一般的判断标准是看副本创建的成本和需求。</p><ol><li>不想变量被修改。 如果你不想变量被函数和方法所修改，那么选择类型T。相反，如果想修改原始的变量，则选择*T</li><li>如果变量是一个大的struct或者数组，则副本的创建相对会影响性能，这个时候考虑使用*T，只创建新的指针，这个区别是巨大的</li><li>对于函数作用域内的参数，如果定义成T,Go编译器尽量将对象分配到栈上，而*T很可能会分配到堆上，这对垃圾回收会有影响</li></ol><h2 id="什么时候发生副本创建"><a href="#什么时候发生副本创建" class="headerlink" title="什么时候发生副本创建"></a>什么时候发生副本创建</h2><p>简单来说</p><blockquote><p>A go assignment is a copy of the value itself</p></blockquote><h3 id="普通赋值"><a href="#普通赋值" class="headerlink" title="普通赋值"></a>普通赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">type Bird struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">type Parrot struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">var parrot1 = Bird&#123;Age: 1, Name: &quot;Blue&quot;&#125;</div><div class="line">var parrot2 = parrot1</div><div class="line">func main() &#123;</div><div class="line">fmt.Printf(&quot;parrot1:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot1, &amp;parrot1)</div><div class="line">fmt.Printf(&quot;parrot2:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot2, &amp;parrot2)</div><div class="line">parrot3 := parrot1</div><div class="line">fmt.Printf(&quot;parrot2:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot3, &amp;parrot3)</div><div class="line">parrot4 := Parrot(parrot1)</div><div class="line">fmt.Printf(&quot;parrot4:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot4, &amp;parrot4)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parrot1: &#123;Age:1 Name:Blue&#125;, 内存地址：0xfa0a0</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xfa0c0</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc42007e0c0</div><div class="line">parrot4: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc42007e100</div></pre></td></tr></table></figure><h3 id="map、slice"><a href="#map、slice" class="headerlink" title="map、slice"></a>map、slice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">type Bird struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">var parrot1 = Bird&#123;Age: 1, Name: &quot;Blue&quot;&#125;</div><div class="line">func main() &#123;</div><div class="line">fmt.Printf(&quot;parrot1:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot1, &amp;parrot1)</div><div class="line">//slice</div><div class="line">s := []Bird&#123;parrot1&#125;</div><div class="line">s = append(s, parrot1)</div><div class="line">parrot1.Age = 3</div><div class="line">fmt.Printf(&quot;parrot2:\t\t %+v, \t\t内存地址：%p\n&quot;, s[0], &amp;(s[0]))</div><div class="line">fmt.Printf(&quot;parrot3:\t\t %+v, \t\t内存地址：%p\n&quot;, s[1], &amp;(s[1]))</div><div class="line">parrot1.Age = 1</div><div class="line">//map</div><div class="line">m := make(map[int]Bird)</div><div class="line">m[0] = parrot1</div><div class="line">parrot1.Age = 4</div><div class="line">fmt.Printf(&quot;parrot4:\t\t %+v\n&quot;, m[0])</div><div class="line">parrot1.Age = 5</div><div class="line">parrot5 := m[0]</div><div class="line">fmt.Printf(&quot;parrot5:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot5, &amp;parrot5)</div><div class="line">parrot1.Age = 1</div><div class="line">//array</div><div class="line">a := [2]Bird&#123;parrot1&#125;</div><div class="line">parrot1.Age = 6</div><div class="line">fmt.Printf(&quot;parrot6:\t\t %+v, \t\t内存地址：%p\n&quot;, a[0], &amp;a[0])</div><div class="line">parrot1.Age = 1</div><div class="line">a[1] = parrot1</div><div class="line">parrot1.Age = 7</div><div class="line">fmt.Printf(&quot;parrot7:\t\t %+v, \t\t内存地址：%p\n&quot;, a[1], &amp;a[1])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">parrot1: &#123;Age:1 Name:Blue&#125;, 内存地址：0xfa0a0</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc4200160f0</div><div class="line">parrot3: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc420016108</div><div class="line">parrot4: &#123;Age:1 Name:Blue&#125;</div><div class="line">parrot5: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc420012320</div><div class="line">parrot6: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc420016120</div><div class="line">parrot7: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc420016138</div></pre></td></tr></table></figure><p>可以看到 slice/map/数组 的元素全是原始变量的副本。</p><h3 id="for-range"><a href="#for-range" class="headerlink" title="for-range"></a>for-range</h3><p>for-range循环也是将元素的副本赋值给循环变量，所以变量得到的是集合元素的副本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">type Bird struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">var parrot1 = Bird&#123;Age: 1, Name: &quot;Blue&quot;&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">fmt.Printf(&quot;parrot1:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot1, &amp;parrot1)</div><div class="line">//slice</div><div class="line">s := []Bird&#123;parrot1, parrot1, parrot1&#125;</div><div class="line">s[0].Age = 1</div><div class="line">s[1].Age = 2</div><div class="line">s[2].Age = 3</div><div class="line">parrot1.Age = 4</div><div class="line">for i, p := range s &#123;</div><div class="line">fmt.Printf(&quot;parrot%d:\t\t %+v, \t\t内存地址：%p\n&quot;, (i + 2), p, &amp;p)</div><div class="line">&#125;</div><div class="line">parrot1.Age = 1</div><div class="line">//map</div><div class="line">m := make(map[int]Bird)</div><div class="line">parrot1.Age = 1</div><div class="line">m[0] = parrot1</div><div class="line">parrot1.Age = 2</div><div class="line">m[1] = parrot1</div><div class="line">parrot1.Age = 3</div><div class="line">m[2] = parrot1</div><div class="line">parrot1.Age = 4</div><div class="line">for k, v := range m &#123;</div><div class="line">fmt.Printf(&quot;parrot%d:\t\t %+v, \t\t内存地址：%p\n&quot;, (k + 2), v, &amp;v)</div><div class="line">&#125;</div><div class="line">parrot1.Age = 4</div><div class="line">//array</div><div class="line">a := [...]Bird&#123;parrot1, parrot1, parrot1&#125;</div><div class="line">a[0].Age = 1</div><div class="line">a[1].Age = 2</div><div class="line">a[2].Age = 3</div><div class="line">parrot1.Age = 4</div><div class="line">for i, p := range a &#123;</div><div class="line">fmt.Printf(&quot;parrot%d:\t\t %+v, \t\t内存地址：%p\n&quot;, (i + 2), p, &amp;p)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输入结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">parrot1: &#123;Age:1 Name:Blue&#125;, 内存地址：0xfb0a0</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc4200122a0</div><div class="line">parrot3: &#123;Age:2 Name:Blue&#125;, 内存地址：0xc4200122a0</div><div class="line">parrot4: &#123;Age:3 Name:Blue&#125;, 内存地址：0xc4200122a0</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc420012320</div><div class="line">parrot3: &#123;Age:2 Name:Blue&#125;, 内存地址：0xc420012320</div><div class="line">parrot4: &#123;Age:3 Name:Blue&#125;, 内存地址：0xc420012320</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc4200123a0</div><div class="line">parrot3: &#123;Age:2 Name:Blue&#125;, 内存地址：0xc4200123a0</div><div class="line">parrot4: &#123;Age:3 Name:Blue&#125;, 内存地址：0xc4200123a0</div></pre></td></tr></table></figure><p>注意循环变量是重用的，所以你看到它们的地址是相同的。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>往channel中send对象的时候也会创建对象的副本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">type Bird struct &#123;</div><div class="line">Age  int</div><div class="line">Name string</div><div class="line">&#125;</div><div class="line">var parrot1 = Bird&#123;Age: 1, Name: &quot;Blue&quot;&#125;</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">ch := make(chan Bird, 3)</div><div class="line">fmt.Printf(&quot;parrot1:\t\t %+v, \t\t内存地址：%p\n&quot;, parrot1, &amp;parrot1)</div><div class="line">ch &lt;- parrot1</div><div class="line">parrot1.Age = 2</div><div class="line">ch &lt;- parrot1</div><div class="line">parrot1.Age = 3</div><div class="line">ch &lt;- parrot1</div><div class="line">parrot1.Age = 4</div><div class="line">p := &lt;-ch</div><div class="line">fmt.Printf(&quot;parrot%d:\t\t %+v, \t\t内存地址：%p\n&quot;, 2, p, &amp;p)</div><div class="line">p = &lt;-ch</div><div class="line">fmt.Printf(&quot;parrot%d:\t\t %+v, \t\t内存地址：%p\n&quot;, 3, p, &amp;p)</div><div class="line">p = &lt;-ch</div><div class="line">fmt.Printf(&quot;parrot%d:\t\t %+v, \t\t内存地址：%p\n&quot;, 4, p, &amp;p)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parrot1: &#123;Age:1 Name:Blue&#125;, 内存地址：0xfa0a0</div><div class="line">parrot2: &#123;Age:1 Name:Blue&#125;, 内存地址：0xc4200122a0</div><div class="line">parrot3: &#123;Age:2 Name:Blue&#125;, 内存地址：0xc4200122a0</div><div class="line">parrot4: &#123;Age:3 Name:Blue&#125;, 内存地址：0xc4200122a0</div></pre></td></tr></table></figure><p>注意：因为变量p是重复使用的，所有地址都是相同的。</p><h2 id="不同类型的副本创建"><a href="#不同类型的副本创建" class="headerlink" title="不同类型的副本创建"></a>不同类型的副本创建</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是值类型，赋值的时候会发生原始数组的复制，所以对于大的数组的参数传递和赋值，一定要慎重。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">func main() &#123;</div><div class="line">a1 := [3]int&#123;1, 2, 3&#125;</div><div class="line">fmt.Printf(&quot;a1:\t\t %+v, \t\t内存地址：%p\n&quot;, a1, &amp;a1)</div><div class="line">a2 := a1</div><div class="line">a1[0] = 4</div><div class="line">a1[1] = 5</div><div class="line">a1[2] = 6</div><div class="line">fmt.Printf(&quot;a2:\t\t %+v, \t\t内存地址：%p\n&quot;, a2, &amp;a2)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a1: [1 2 3], 内存地址：0xc420012260</div><div class="line">a2: [1 2 3], 内存地址：0xc4200122c0</div></pre></td></tr></table></figure><p>对于[…]T和[…]<em>T的区别，我想你也应该清楚了，[…]</em>T创建的副本的元素时元数组元素指针的副本。</p><h3 id="map、slice-和-channel"><a href="#map、slice-和-channel" class="headerlink" title="map、slice 和 channel"></a>map、slice 和 channel</h3><p>网上一般说， 这三种类型都是指向指针类型，指向一个底层的数据结构。<br>因此呢，在定义类型的时候就不必定义成*T了。</p><p>当然你可以这么认为，不过我认为这是不准确的，比如slice,其实你可以看成是SliceHeader对象，只不过它的数据Data是一个指针，所以它的副本的创建对性能的影响可以忽略。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数也是一个指针类型，对函数对象的赋值只是又创建了一个对次函数对象的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package main</div><div class="line">import &quot;fmt&quot;</div><div class="line">func main() &#123;</div><div class="line">f1 := func(i int) &#123;&#125;</div><div class="line">fmt.Printf(&quot;f1:\t\t %+v, \t\t内存地址：%p\n&quot;, f1, &amp;f1)</div><div class="line">f2 := f1</div><div class="line">fmt.Printf(&quot;f2:\t\t %+v, \t\t内存地址：%p\n&quot;, f2, &amp;f2)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f1: 0x2200, 内存地址：0xc420028020</div><div class="line">f2: 0x2200, 内存地址：0xc420028030</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从一个bug说Blocking Queue</title>
      <link href="/2019/05/01/%E4%BB%8E%E4%B8%80%E4%B8%AAbug%E8%AF%B4Blocking-Queue/"/>
      <url>/2019/05/01/%E4%BB%8E%E4%B8%80%E4%B8%AAbug%E8%AF%B4Blocking-Queue/</url>
      
        <content type="html"><![CDATA[<p>最近出了个故障，排查的时候耗费了很长的时间，回顾整个排查过程，经验主义在这里起了不好的作用，直接导致了整个故障排查的时间非常长，这个故障的根本原因在于BlockingQueue用的有问题，顺带展开说说Java中常用的几个BlockingQueue：ArrayBlockingQueue、LinkedBlockingQueue和SynchronousQueue。</p><p>当时故障的现象是应用处理请求的线程池满了，导致请求处理不了，于是dump线程，看线程都在做什么，结果发现线程都Block在写日志的地方，以前出现过很多次问题，去线程dump的时候看到也是一堆的block在写日志，但通常是别的原因引发的，所以这次也是按照这样的经验，认为肯定不会是写日志这个地方的问题，于是各种排查…折腾了N久后，回过头看发现持有那把日志锁的地方是自己人写的代码，那段代码在拿到了这个日志锁后，从线程堆栈上看，block在了ArrayBlockingQueue.put这个地方，于是翻看这段代码，结果发现这是个1024长度的BlockingQueue，那就意味着如果这个Queue被放了1024个对象的话，put就一定会被block住，而且其实翻代码的时候能看出写代码的同学是考虑到了BlockingQueue如果满了应该要处理的，代码里写着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (blockingQueue.remainingCapacity() &lt; 1)</div><div class="line"> &#123; //todo &#125;</div><div class="line"> blockingQueue.put</div></pre></td></tr></table></figure><p>这里两个悲催的问题，一是这个if判断完还是直接会走到put，而不是else，二是竟然关键的满了后的处理逻辑还在//todo…<br>另外我觉得这段代码还反应了同学对BlockingQueue的接口不太熟，要达到这个效果，不需要这样先去判断，更合适的做法是用blockingQueue.offer，返回false再做相应的异常处理。</p><p>BlockingQueue是在生产/消费者模式下经常会用到的数据结构，通常常用的主要会是ArrayBlockingQueue、LinkedBlockingQueue和SynchronousQueue。</p><p>ArrayBlockingQeue/LinkedBlockingQueue两者的最大不同主要在于存放Queue中对象方式，一个是数组，一个是链表，代码注释里也写到了两者的不同：<br>Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications.</p><p>SynchronousQueue是一个非常特殊的BlockingQueue，它的模式是在offer的时候，如果没有另外一个线程正在take或poll的话，那么offer就会失败；在take的时候，如果没有另外的线程正好并发在offer，也会失败，这种特殊的模式非常适合用来做要求高响应并且线程出不固定的线程池的Queue。</p><p>对于在线业务场景而言，所有的并发，外部访问阻塞的地方的一个真理就是一定要有超时机制，在线业务最强调的是快速处理掉一次请求，所以fail fast是在线业务系统设计，代码编写中的最重要原则，按照这个原则上面的代码最起码明显犯的错误就是用put而不是带超时机制的offer，或者说如果是不重要的场景，完全就应该直接用offer，false了直接抛异常或记录下异常即可。</p><p>对于BlockingQueue这种场景呢，除了超时机制外，还有一个是队列长度一定要做限制，否则默认的是Integer.MAX_VALUE，万一代码出点bug的话，内存就被玩挂了。</p><p>说到BlockingQueue，就还是要提下BlockingQueue被用的最多的地方：线程池，Java的ThreadPoolExecutor中有个参数是BlockingQueue，如果这个地方用的是ArrayBlockingQueue或LinkedBlockingQueue，而线程池的coreSize和poolSize不一样的话，在coreSize线程满了后，这个时候线程池首先会做的是offer到BlockingQueue，成功的话就结束，这种场景同样不符合在线业务的需求，在线业务更希望的是快速处理，而不是先排队，而且其实在线业务最好是不要让请求堆在排队队列里，在线业务这样做很容易引发雪崩，超出处理能力范围直接拒绝抛错是相对比较好的做法，至于在前面页面上排队什么这个是可以的，那是另外一种限流机制。</p><p>所以说在写高并发、分布式的代码时，除了系统设计外，代码细节的功力是非常非常重要的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring的缺陷与DDD(2)</title>
      <link href="/2019/04/20/spring%E7%9A%84%E7%BC%BA%E9%99%B7%E4%B8%8EDDD-2/"/>
      <url>/2019/04/20/spring%E7%9A%84%E7%BC%BA%E9%99%B7%E4%B8%8EDDD-2/</url>
      
        <content type="html"><![CDATA[<h2 id="架构风格"><a href="#架构风格" class="headerlink" title="架构风格"></a>架构风格</h2><p>在《实现领域驱动设计》一书中提到了几种架构风格：六边形架构、REST架构、CQRS 和事件驱动等。在实际使用中，落地的架构并非是纯粹其中的一种，而很有可能户将上述几种架构风格结合起来实现。</p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>分层架构的一个重要原则是每层只能与位于其下方的层发生耦合。分层架构可以简单分为两种，即严格分层架构和松散分层架构。在严格分层架构中，某层只能与位于其直接下方的层发生耦合，而在松散分层架构中，则允许某层与它的任意下方层发生耦合。DDD分层架构中比较经典的三种模式：四层架构、五层架构和六边形架构。</p><h3 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h3><p>Eric Evans在《领域驱动设计－软件核心复杂性应对之道》这本书中提出了传统的四层架构模式：</p><ul><li><p>User Interface为用户界面层（或表示层），负责向用户显示信息和解释用户命令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。</p></li><li><p>Application为应用层，定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其它系统的应用层进行交互的必要渠道。应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。它没有反映业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度。</p></li><li><p>Domain为领域层（或模型层），负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。领域层是业务软件的核心，领域模型位于这一层。</p></li><li><p>Infrastructure层为基础实施层，向其他层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持四个层次间的交互模式</p></li></ul><p>传统的四层架构都是限定型松散分层架构，即Infrastructure层的任意上层都可以访问该层（“L”型），而其它层遵守严格分层架构。</p><h3 id="五层架构"><a href="#五层架构" class="headerlink" title="五层架构"></a>五层架构</h3><p>五层架构是根据《DCI架构：面向对象编程的新构想》中提及的DCI架构模式总结而成。DCI架构（Data、Context和Interactive三层架构）：</p><ul><li><p>Data层描述系统有哪些领域概念及其之间的关系，该层专注于领域对象的确立和这些对象的生命周期管理及关系，让程序员站在对象的角度思考系统，从而让“系统是什么”更容易被理解。</p></li><li><p>Context层：是尽可能薄的一层。Context往往被实现得无状态，只是找到合适的role，让role交互起来完成业务逻辑即可。但是简单并不代表不重要，显示化context层正是为人去理解软件业务流程提供切入点和主线。</p></li><li><p>Interactive层主要体现在对role的建模，role是每个context中复杂的业务逻辑的真正执行者，体现“系统做什么”。role所做的是对行为进行建模，它联接了context和领域对象。由于系统的行为是复杂且多变的，role使得系统将稳定的领域模型层和多变的系统行为层进行了分离，由role专注于对系统行为进行建模。该层往往关注于系统的可扩展性，更加贴近于软件工程实践，在面向对象中更多的是以类的视角进行思考设计。</p></li></ul><p>DCI目前广泛被看作是对DDD的一种发展和补充，用在基于面向对象的领域建模上。五层架构的具体定义如下：</p><ul><li><p>User Interface是用户接口层，主要用于处理用户发送的Restful请求和解析用户输入的配置文件等，并将信息传递给Application层的接口。</p></li><li><p>Application层是应用层，负责多进程管理及调度、多线程管理及调度、多协程调度和维护业务实例的状态模型。当调度层收到用户接口层的请求后，委托Context层与本次业务相关的上下文进行处理。</p></li><li><p>Context是环境层，以上下文为单位，将Domain层的领域对象cast成合适的role，让role交互起来完成业务逻辑。</p></li><li><p>Domain层是领域层，定义领域模型，不仅包括领域对象及其之间关系的建模，还包括对象的角色role的显式建模。</p></li><li><p>Infrastructure层是基础实施层，为其他层提供通用的技术能力：业务平台，编程框架，持久化机制，消息机制，第三方库的封装，通用算法，等等。</p></li></ul><h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><p>六边形架构（Hexagonal Architecture），又称为端口和适配器风格，最早由 Alistair Cockburn 提出。在 DDD 社区得到了发展和推广，之所以是六变形是为了突显这是个扁平的架构，每个边界的权重是相等的。</p><p>我们知道，经典分层架构分为三层（展现层、应用层、数据访问层），而对于六边形架构，可以分成另外的三层:</p><ul><li>领域层（Domain Layer）：最里面，纯粹的核心业务逻辑，一般不包含任何技术实现或引用</li><li>端口层（Ports Layer）：领域层之外，负责接收与用例相关的所有请求，这些请求负责在领域层中协调工作。端口层在端口内部作为领域层的边界，在端口外部则扮演了外部实体的角色。</li><li>适配器层（Adapters Layer）：端口层之外，负责以某种格式接收输入、及产生输出。比如，对于 HTTP 用户请求，适配器会将转换为对领域层的调用，并将领域层传回的响应进行封送，通过 HTTP 传回调用客户端。在适配器层不存在领域逻辑，它的唯一职责就是在外部世界与领域层之间进行技术性的转换。适配器能够与端口的某个协议相关联并使用该端口，多个适配器可以使用同一个端口，在切换到某种新的用户界面时，可以让新界面与老界面同时使用相同的端口。</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g298gyarr1j311a0nyafl.jpg" alt=""></p><p>这样做的好处是将使业务边界更加清晰，从而获得更好的扩展性，除此之外，业务复杂度和技术复杂度分离，是 DDD 的重要基础，核心的领域层可以专注在业务逻辑而不用理会技术依赖，外部接口在被消费者调用的时候也不用去关心业务内部是如何实现。</p><h3 id="REST架构"><a href="#REST架构" class="headerlink" title="REST架构"></a>REST架构</h3><p>RESTful风格的架构将 资源 放在第一位，每个 资源 都有一个 URI 与之对应，可以将 资源 看着是 DDD 中的实体；RESTful 采用具有自描述功能的消息实现无状态通信，提高系统的可用性；至于 资源 的哪些属性可以公开出去，针对 资源的操作，RESTful使用HTTP协议的已有方法来实现：GET、PUT、POST和DELETE。</p><p>在 DDD 的实现中，我们可以将对外的服务设计为 RESTful 风格的服务，将实体/值对象/领域服务作为资源对外提供增删改查服务。但是并不建议直接将实体暴露在外，一来实体的某些隐私属性并不能对外暴露，二来某些资源获取场景并不是一个实体就能满足。因此我们在实际实践过程中，在领域模型上增加了 DTO 这样一个角色，DTO 可以组合多个实体/值对象的资源对外暴露。</p><h3 id="CQRS"><a href="#CQRS" class="headerlink" title="CQRS"></a>CQRS</h3><p>CQRS 就是平常大家在讲的读写分离，通常读写分离的目的是为了提高查询性能，同时达到读/写的解耦。让 DDD 和 CQRS 结合，我们可以分别对读和写建模，查询模型通常是一种非规范化数据模型，它并不反映领域行为，只是用于数据显示；命令模型执行领域行为，且在领域行为执行完成后，想办法通知到查询模型。</p><p>那么命令模型如何通知到查询模型呢？ 如果查询模型和领域模型共享数据源，则可以省却这一步；如果没有共用数据源，则可以借助于 消息模式（Messaging Patterns）通知到查询模型，从而达到最终一致性（Eventual Consistency）。</p><p>Martin 在 blog 中指出：CQRS 适用于极少数复杂的业务领域，如果不是很适合反而会增加复杂度；另一个适用场景为获取高性能的服务。</p><h2 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h2><p>在上面小节讲解了领域驱动设计的几种架构风格，下面我们具体结合简单的实例来看其中的领域模型划分，初步分为4大类</p><ol><li>失血模型</li><li>贫血模型</li><li>充血模型</li><li>涨血模型</li></ol><p>我们看看这些领域模型的具体内容，以及他们的优缺点。</p><h3 id="失血模型"><a href="#失血模型" class="headerlink" title="失血模型"></a>失血模型</h3><p>失血模型简单来说，就是domain object只有属性的getter/setter方法的纯数据类，所有的业务逻辑完全由business object来完成(又称TransactionScript)，这种模型下的domain object被Martin Fowler称之为“贫血的domain object”。</p><h3 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h3><p>简单来说，就是 domain ojbect 包含了不依赖于持久化的领域逻辑，而那些依赖持久化的领域逻辑被分离到 Service 层。</p><p>Service(业务逻辑，事务封装) –&gt; DAO —&gt; domain object</p><p>这也就是 Martin Fowler 指的 rich domain object:</p><ul><li>一个带有业务逻辑的实体类，即domain object是Item</li><li>一个DAO接口ItemDao</li><li>一个DAO实现ItemDaoHibernateImpl</li><li>一个业务逻辑对象ItemManager<br>这种模型的优点：</li></ul><ol><li>各层单向依赖，结构清楚，易于实现和维护</li><li>设计简单易行，底层模型非常稳定</li></ol><p>缺点为：</p><ol><li>domain object的部分比较紧密依赖的持久化 domain logic 被分离到Service层，显得不够 OO</li><li>Service 层过于厚重</li></ol><h3 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h3><p>充血模型和第二种模型差不多，所不同的就是如何划分业务逻辑，即认为，绝大多业务逻辑都应该被放在domain object里面(包括持久化逻辑)，而Service层应该是很薄的一层，仅仅封装事务和少量逻辑，不和DAO层打交道。</p><p>Service(事务封装) —&gt; domain object &lt;—&gt; DAO</p><p>这种模型就是把第二种模型的 domain object 和 business object 合二为一了。所以 ItemManager 就不需要了，在这种模型下面，只有三个类，他们分别是</p><ul><li>Item：包含了实体类信息，也包含了所有的业务逻辑</li><li>ItemDao：持久化DAO接口类</li><li>ItemDaoHibernateImpl：DAO接口的实现类</li></ul><p>在这种模型中，所有的业务逻辑全部都在Item中，事务管理也在Item中实现。<br>这种模型的优点：</p><ol><li>更加符合OO的原则</li><li>Service层很薄，只充当Facade的角色，不和DAO打交道。</li></ol><p>这种模型的缺点：</p><ol><li>DAO和domain object形成了双向依赖，复杂的双向依赖会导致很多潜在的问题。</li><li>如何划分Service层逻辑和domain层逻辑是非常含混的，在实际项目中，由于设计和开发人员的水平差异，可能导致整个结构的混乱无序。</li><li>考虑到Service层的事务封装特性，Service层必须对所有的domain object的逻辑提供相应的事务封装方法，其结果就是Service完全重定义一遍所有的domain logic，非常烦琐，而且 Service 的事务化封装其意义就等于把 OO 的domain logic 转换为过程的 Service TransactionScript。</li></ol><h3 id="胀血模型"><a href="#胀血模型" class="headerlink" title="胀血模型"></a>胀血模型</h3><p>基于充血模型的第三个缺点，有同学提出，干脆取消Service层，只剩下domain object和DAO两层，在domain object的domain logic上面封装事务。</p><p>domain object(事务封装，业务逻辑) &lt;—&gt; DAO</p><p>似乎ruby on rails就是这种模型，他甚至把 domain object 和 DAO 都合并了。</p><p>该模型优点：</p><ol><li>简化了分层</li><li>也算符合OO</li></ol><p>缺点: </p><ol><li><p>很多不是domain logic的 service 逻辑也被强行放入 domain object，引起了domain ojbect模型的不稳定</p></li><li><p>domain object 暴露给web层过多的信息，可能引起意想不到的副作用。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这四种模型当中，失血模型和胀血模型应该是不被提倡的。而贫血模型和充血模型从技术上来说，都已经是可行的了。贫血模型和充血模型哪个更加好一些？人们针对这个问题进行了旷日持久的争论，最后仍然没有什么结果。双方争论的焦点主要在我上面加粗的两句话上，就是领域模型是否要依赖持久层，因为依赖持久层就意味着单元测试的展开要更加困难（无法脱离框架进行测试，原文的讨论中这里专指Hibernate），领域层就更难独立，将来也更难从应用程序中剥离出来，当然好处是业务逻辑不必混放在不同的层中，使得单一职责性体现的更好。而支持者（充血模型）认为，只要将持久层抽象出来，即可减少测试的困难性，同时适用充血模型毕竟带来了不少开发上的便利性，除了依赖持久层这一点，拥有更多好处的充血模型仍然值得选择。最后，谁也没能说服谁，关于贫血模型和充血模型的选择，更多的要靠具体的业务场景来决定，并不能说哪一种更比哪一种好。设计模式这种东西不是向来都没有什么定论么。</p><p>我个人则倾向使用充血模型，因为充血模型更加像一个设计完善的系统架构，好在计算机世界里有很多的 IOC 和 DI 框架，唯一的缺陷依赖持久层可以通过各种变通的方法绕过，随着技术的进步，一些缺陷也会被慢慢解决。我的思路是这样的：先将持久层抽象为接口，然后通过服务层将持久层注入到领域模型中，这样领域模型仅仅会依赖于持久层的接口。而这个接口，可以利用现有框架的技术进行抽象。</p><blockquote><p>转自: <a href="http://blueskykong.com/2019/03/28/ddd-2/" target="_blank" rel="external">http://blueskykong.com/2019/03/28/ddd-2/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring的缺陷与DDD(1)</title>
      <link href="/2019/03/10/spring%E7%9A%84%E7%BC%BA%E9%99%B7%E4%B8%8EDDD-1/"/>
      <url>/2019/03/10/spring%E7%9A%84%E7%BC%BA%E9%99%B7%E4%B8%8EDDD-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spring 框架已经成为构建企业级 Java 应用事实上的标准了，众多的企业项目都构建在 Spring 项目及其子项目之上，特别是 Java Web 项目，很多都使用了 Spring 并且遵循着 Web、Service、Dao 这样的分层原则，下层向上层提供服务；不过Petri Kainulainen在其博客中却指出了众多 Spring Web 应用的最大瑕疵。</p></blockquote><p>多数有经验的程序开发者都应该听说过DDD，并且尝试过将其应用在自己的项目中。不知你是否遇到过这样的场景：你创建了一个资源库（Repository），但一段时间之后发现这个资源库和传统的DAO越来越像了，你开始反思自己的实现方式是正确的吗？或者，你创建了一个聚合，然后发现这个聚合是如此的庞大，它为什么引用了如此多的对象，难道又是我做错了吗？</p><p>本文将会谈谈有关领域驱动设计，和领域驱动设计中使用贫血、失血和充血模型。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="Spring的缺陷"><a href="#Spring的缺陷" class="headerlink" title="Spring的缺陷"></a>Spring的缺陷</h2><p>现在大部分应用Spring框架的Java Web应用都相当关注单一职责原则和关注分离原则，但是在此之上却诞生了一些不太好的反模式和设计原则，比如：</p><ul><li>领域模型对象只是用来存储应用的数据（领域模型使用了贫血模型这种反模式）。</li><li>业务逻辑位于服务层中，管理域对象的数据。</li><li>在服务层中，应用的每个实体对应一个服务类。</li></ul><p>使用 Spring 框架构建应用的开发者很乐于谈论依赖注入的好处。但遗憾的是，他们很多人并没有在其应用中很好地利用其优势，如单一职责原则和关注分离原则。如果仔细看看基于 Spring 的 Web 应用，你会发现很多都是使用如下这些常见且错误的设计原则来实现的：</p><p>这类设计原则的应用非常广泛，我现在所在的Java Web项目就是使用这样的设计原则进行架构设计的，基本都是常见的三层或多层架构，他们大概是什么样的呢？</p><ul><li>Web层（俗称展现层吧，Presentation Layer)：接收用户输入，将数据传至服务层；</li><li>服务层(Service Layer，可以叫Business Logic Layer)：事务边界，处理业务逻辑、权限管理与授权，并与存储层通信</li><li>存储层（Data access layer）：与数据库进行通信，对数据进行持久化。</li></ul><p>但是发现什么没有？问题出在了服务层，他承受了太多的职责，像事务管理、业务逻辑、权限检查等等，这违反了单一职责原则和关注分离原则，并且产生了大量的依赖和循环依赖。当业务复杂度上升时，服务层所包含的代码将会非常庞大和复杂，直接导致了测试成本的上升。服务层主要有两个问题：</p><ul><li>应用的业务逻辑来自于服务层。</li></ul><p>业务逻辑散落在服务层。如果需要查看某个业务规则是如何实现的，我们需要先找到它。此外，如果有多个服务类都需要相同的业务规则，那么会将这个业务规则从一个服务复制到另一个服务中，大量的代码重复。</p><ul><li>每个领域模型类在服务层中都有一个服务类。</li></ul><p>这违背了单一职责原则：单一职责原则表明每个类都应该只有一个职责，这个职责应该完全被这个类所封装。它的所有服务都应该与这个职责保持一致。</p><p>如何改善现状，下面具体介绍领域驱动设计的相关概念和实施策略。</p><h2 id="领域驱动模型"><a href="#领域驱动模型" class="headerlink" title="领域驱动模型"></a>领域驱动模型</h2><p>DDD总体结构分为四层: Infrastructure(基础实施层)，Domain(领域层)，Application(应用层)，Interfaces(表示层，也叫用户界面层或是接口层)，各个层面的作用下面介绍。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g297fblc1gj30s80iwqa1.jpg" alt=""></p><ul><li>用户界面（表现层）：负责给用户展示信息，并解释用户命</li><li>应用层：该层协调应用程序的活动。不包括任何业务逻辑，不保存业务对象的状态，但能保存应用程序任务过程的状态。</li><li>领域层：这一层包括业务领域的信息。业务对象的状态在这里保存。业务对象的持久化和它们的状态可能会委托给基础设施层。</li><li>基础设施层：对其它层来说，这一层是一个支持性的库。它提供层之间的信息传递，实现业务对象的持久化，包含对用户界面层的支持性库等。</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>当一个对象由其标识(而不是属性)区分时，这种对象称为实体(Entity)。比如当两个对象的标识不同时，即使两个对象的其他属性全都相同，我们也认为他们是两个完全不同的实体。</p><h4 id="值对象（Value-Object）"><a href="#值对象（Value-Object）" class="headerlink" title="值对象（Value Object）"></a>值对象（Value Object）</h4><p>当一个对象用于对事物进行描述而没有唯一标识时，那么它被称作值对象。因为在领域中并不是任何时候一个事物都需要有一个唯一的标识，也就是说我们并不关心具体是哪个事物，只关心这个事物是什么。比如下单流程中，对于配送地址来说，只要是地址信息相同，我们就认为是同一个配送地址。由于不具有唯一标示，我们也不能说”这一个”值对象或者”那一个”值对象。</p><h4 id="领域服务（Domain-Service）"><a href="#领域服务（Domain-Service）" class="headerlink" title="领域服务（Domain Service）"></a>领域服务（Domain Service）</h4><p>一些重要的领域行为或操作，它们不太适合建模为实体对象或者值对象，它们本质上只是一些操作，并不是具体的事物，另一方面这些操作往往又会涉及到多个领域对象的操作，它们只负责来协调这些领域对象完成操作而已，那么我们可以归类它们为领域服务。它实现了全部业务逻辑并且通过各种校验手段保证业务的正确性。同时呢，它也能避免在应用层出现领域逻辑。理解起来，领域服务有点facade的味道。</p><h4 id="聚合及聚合根（Aggregate，Aggregate-Root"><a href="#聚合及聚合根（Aggregate，Aggregate-Root" class="headerlink" title="聚合及聚合根（Aggregate，Aggregate Root)"></a>聚合及聚合根（Aggregate，Aggregate Root)</h4><p>聚合是通过定义领域对象之间清晰的所属关系以及边界来实现领域模型的内聚，以此来避免形成错综复杂的、难以维护的对象关系网。聚合定义了一组具有内聚关系的相关领域对象的集合，我们可以把聚合看作是一个修改数据的单元。</p><p>聚合根属于实体对象，它是领域对象中一个高度内聚的核心对象。(聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法)</p><p>若一个聚合仅有一个实体，那这个实体就是聚合根；但要有多个实体，我们就要思考聚合内哪个对象有独立存在的意义且可以和外部领域直接进行交互。</p><h4 id="工厂（Factory）"><a href="#工厂（Factory）" class="headerlink" title="工厂（Factory）"></a>工厂（Factory）</h4><p>DDD中的工厂也是一种封装思想的体现。引入工厂的原因是：有时创建一个领域对象是一件相对比较复杂的事情，而不是简单的new操作。工厂的作用是隐藏创建对象的细节。事实上大部分情况下，领域对象的创建都不会相对太复杂，故我们仅需使用简单的构造函数创建对象就可以。隐藏创建对象细节的好处是显而易见的，这样就可以不会让领域层的业务逻辑泄露到应用层，同时也减轻应用层负担，它只要简单调用领域工厂来创建出期望的对象就可以了。</p><h4 id="仓储（Repository）"><a href="#仓储（Repository）" class="headerlink" title="仓储（Repository）"></a>仓储（Repository）</h4><p>资源仓储封装了基础设施来提供查询和持久化聚合操作。这样能够让我们始终关注在模型层面，把对象的存储和访问都委托给资源库来完成。它不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD 关心的是领域内的模型，而不是数据库的操作。</p><h3 id="DDD设计"><a href="#DDD设计" class="headerlink" title="DDD设计"></a>DDD设计</h3><p>DDD 概念理解起来有点抽象，这个有点像设计模式，感觉很有用，但是自己开发的时候又不知道怎么应用到代码里面，或者生搬硬套后自己看起来都很别扭。DDD的战略设计主要包括领域/子域、通用语言、限界上下文和架构风格等概念。</p><h4 id="领域和子域"><a href="#领域和子域" class="headerlink" title="领域和子域"></a>领域和子域</h4><p>现实世界中，领域包含了问题域和解系统。一般认为软件是对现实世界的部分模拟。在DDD中，解系统可以映射为一个个限界上下文，限界上下文就是软件对于问题域的一个特定的、有限的解决方案。</p><p>在日常开发中，我们通常会将一个大型的软件系统拆分成若干个子系统。这种划分有可能是基于架构方面的考虑，也有可能是基于基础设施的。但是在DDD中，我们对系统的划分是基于领域的，也即是基于业务的。</p><h4 id="限界上下文"><a href="#限界上下文" class="headerlink" title="限界上下文"></a>限界上下文</h4><p>一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义。</p><p>将一个限界上下文中的所有概念，包括名词、动词和形容词全部集中在一起，我们便为该限界上下文创建了一套通用语言。通用语言是一个团队所有成员交流时所使用的语言，业务分析人员、编码人员和测试人员都应该直接通过通用语言进行交流。</p><p>对于上文中提到的各个子域之间的集成问题，其实也是限界上下文之间的集成问题。在集成时，我们主要关心的是领域模型和集成手段之间的关系。比如需要与一个REST资源集成，你需要提供基础设施（比如Spring 中的RestTemplate），但是这些设施并不是你核心领域模型的一部分，你应该怎么办呢？答案是防腐层，该层负责与外部服务提供方打交道，还负责将外部概念翻译成自己的核心领域能够理解的概念。当然，防腐层只是限界上下文之间众多集成方式的一种，另外还有共享内核、开放主机服务等，具体细节请参考《实现领域驱动设计》原书。限界上下文之间的集成关系也可以理解为是领域概念在不同上下文之间的映射关系，因此，限界上下文之间的集成也称为上下文映射图。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文通过Spring Web应用的瑕疵引出改善的措施，随后介绍了领域驱动开发的相关概念和设计策略。在前面讲了这么多概念，想必读者一定有了解如何落地领域驱动设计的冲动。笔者将在下一篇文章介绍领域模型的几种类型和DDD的具体实践案例。</p><blockquote><p>转自:<a href="http://blueskykong.com/2019/01/07/ddd-1/" target="_blank" rel="external">http://blueskykong.com/2019/01/07/ddd-1/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言并发模型</title>
      <link href="/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/03/07/Go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发(concurrency)：两个或两个以上的任务在一段时间内被执行。我们不必care这些任务在某一个时间点是否是同时执行，可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务。</p><p>并行(parallellism)：两个或两个以上的任务在同一时刻被同时执行。<br>并发说的是逻辑上的概念，而并行，强调的是物理运行状态。并发“包含”并行。</p><h2 id="Go的CSP并发模型"><a href="#Go的CSP并发模型" class="headerlink" title="Go的CSP并发模型"></a>Go的CSP并发模型</h2><p>Go实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是Java或者C++等语言中的多线程开发。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</p><p>CSP并发模型是在1970年左右提出的概念，属于比较新的概念，不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。</p><p>普通的线程并发模型，就是像Java、C++、或者Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如Java提供的包”java.util.concurrent”中的数据结构。Go中也实现了传统的线程并发模型。</p><p>Go的CSP并发模型，是通过goroutine和channel来实现的。</p><ul><li>goroutine 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。</li><li>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。</li></ul><p>生成一个goroutine的方式非常的简单：Go一下，就生成了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go f();</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>通信机制channel也很方便，传数据用channel &lt;- data，取数据用&lt;-channel。<br>在通信过程中，传数据channel &lt;- data和取数据&lt;-channel必然会成对出现，因为这边传，那边取，两个goroutine之间才会实现通信。<br>而且不管传还是取，必阻塞，直到另外的goroutine传或者取为止。<br>有两个goroutine，其中一个发起了向channel中发起了传值操作。（goroutine为矩形，channel为箭头）</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0u9eu5xuwj30n00kgt8s.jpg" alt=""></p><p>左边的goroutine开始阻塞，等待有人接收。</p><p>这时候，右边的goroutine发起了接收操作。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0u9f3ug9mj30ro0ko0sx.jpg" alt=""></p><p>右边的goroutine也开始阻塞，等待别人传送。</p><p>这时候，两边goroutine都发现了对方，于是两个goroutine开始一传，一收。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0u9f9wesxj30le0lmmxb.jpg" alt=""></p><p>这便是Golang CSP并发模型最基本的形式。</p><h2 id="Go并发模型的实现原理"><a href="#Go并发模型的实现原理" class="headerlink" title="Go并发模型的实现原理"></a>Go并发模型的实现原理</h2><p>我们先从线程讲起，无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；内核空间主要操作访问CPU资源、I/O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源，用户空间呢就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。<br>我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。<br>线程模型的实现，可以分为以下几种方式：</p><h3 id="用户线程模型"><a href="#用户线程模型" class="headerlink" title="用户线程模型"></a>用户线程模型</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0u9znc5u7j30xq0ougr1.jpg" alt=""></p><p>如图所示，多个用户态的线程对应着一个内核线程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成。</p><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0ua0qn5fpj30ou0n8tdf.jpg" alt=""></p><p>这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++就是这种。</p><h3 id="两级线程模型"><a href="#两级线程模型" class="headerlink" title="两级线程模型"></a>两级线程模型</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0ua1l2uzjj30nc0poq82.jpg" alt=""></p><p>这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度。<br>Go语言的线程模型就是一种特殊的两级线程模型。暂且叫它“MPG”模型吧。</p><h2 id="Go线程实现模型MPG"><a href="#Go线程实现模型MPG" class="headerlink" title="Go线程实现模型MPG"></a>Go线程实现模型MPG</h2><p>M指的是Machine，一个M直接关联了一个内核线程。 P指的是”processor”，代表了M所需的上下文环境，也是处理用户级代码逻辑的处理器。 G指的是Goroutine，其实本质上也是一种轻量级的线程。</p><p>三者关系如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g0ua2jqaqsj30tg0smdib.jpg" alt=""></p><p>以上这个图讲的是两个线程(内核线程)的情况。一个M会对应一个内核线程，一个M也会连接一个上下文P，一个上下文P相当于一个“处理器”，一个上下文连接一个或者多个Goroutine。P(Processor)的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数runtime.GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有固定数量的线程在运行go代码。Goroutine中就是我们要执行并发的代码。图中P正在执行的Goroutine为蓝色的；处于待执行状态的Goroutine为灰色的，灰色的Goroutine形成了一个队列runqueues<br>三者关系的宏观的图为：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g0ua38s9tzj30yu0hujv6.jpg" alt=""></p><h3 id="抛弃P-Processor"><a href="#抛弃P-Processor" class="headerlink" title="抛弃P(Processor)"></a>抛弃P(Processor)</h3><p>你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让Goroutine的runqueues挂到M上呢？答案是不行，需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候。</p><p>一个很简单的例子就是系统调用sysall，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程M需要放弃当前的上下文环境P，以便可以让其他的Goroutine被调度执行。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0ua45fjefj30xu0o03zz.jpg" alt=""></p><p>如上图左图所示，M0中的G0执行了syscall，然后就创建了一个M1(也有可能本身就存在，没创建)，（转向右图）然后M0丢弃了P，等待syscall的返回值，M1接受了P，将·继续执行Goroutine队列中的其他Goroutine。<br>当系统调用syscall结束后，M0会“偷”一个上下文，如果不成功，M0就把它的Gouroutine G0放到一个全局的runqueue中，然后自己放到线程池或者转入休眠状态。全局runqueue是各个P在运行完自己的本地的Goroutine runqueue后用来拉取新goroutine的地方。P也会周期性的检查这个全局runqueue上的goroutine，否则，全局runqueue上的goroutines可能得不到执行而饿死。</p><h3 id="均衡的分配工作"><a href="#均衡的分配工作" class="headerlink" title="均衡的分配工作"></a>均衡的分配工作</h3><p>按照以上的说法，上下文P会定期的检查全局的goroutine 队列中的goroutine，以便自己在消费掉自身Goroutine队列的时候有事可做。假如全局goroutine队列中的goroutine也没了呢？就从其他运行的中的P的runqueue里偷。</p><p>每个P中的Goroutine不同导致他们运行的效率和时间也不同，在一个有很多P和M的环境中，不能让一个P跑完自身的Goroutine就没事可做了，因为或许其他的P有很长的goroutine队列要跑，得需要均衡。<br>该如何解决呢？<br>Go的做法倒也直接，从其他P中偷一半！</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0ua5617txj30vq0mqdhb.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java SPI与Dubbo SPI</title>
      <link href="/2019/02/20/java-SPI%E4%B8%8EDubbo-SPI/"/>
      <url>/2019/02/20/java-SPI%E4%B8%8EDubbo-SPI/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA-SPI"><a href="#JAVA-SPI" class="headerlink" title="JAVA SPI"></a>JAVA SPI</h2><p>java spi一直都是一个很少有人关注的点,我听到这个词还是源于Dubbo SPI,Dubbo SPI是对java SPI进行了一些优化得到的。这个机制主要是针对厂商或者插件,但是我们日常中确一直在使用。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0vc2gbxpuj30dm0743yf.jpg" alt=""></p><ul><li>bad good 是两个interface的实现</li><li>interface 提供一个标准接口</li><li>invoker负责最后的调用</li></ul><h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Printer &#123;</div><div class="line">    void print();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="bad-amp-good"><a href="#bad-amp-good" class="headerlink" title="bad&amp;good"></a>bad&amp;good</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">添加依赖</div><div class="line">&lt;dependency&gt;</div><div class="line">            &lt;groupId&gt;com.sc&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;interface&lt;/artifactId&gt;</div><div class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">实现接口</div><div class="line">public class GoodPrint implements Printer &#123;</div><div class="line">    public void print() &#123;</div><div class="line">        System.out.println(&quot;i am good&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class BadPrinter implements Printer &#123;</div><div class="line"></div><div class="line">    public void print() &#123;</div><div class="line">        System.out.println(&quot;i am bad&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">新建文件resources\META-INF\services\com.sc.Printer</div><div class="line"></div><div class="line">文件内容</div><div class="line">com.sc.GoodPrint</div></pre></td></tr></table></figure><h4 id="invoker"><a href="#invoker" class="headerlink" title="invoker"></a>invoker</h4><p>添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.sc&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;interface&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.sc&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;good-printer&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>编写主类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class MainApp &#123;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ServiceLoader&lt;Printer&gt; printerLoader = ServiceLoader.load(Printer.class);</div><div class="line">        for (Printer printer : printerLoader) &#123;</div><div class="line">            printer.print();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i am good</div></pre></td></tr></table></figure><p>并且通过切换bad依赖,输出的结果是不同的,这就是java spi的简单示例。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>根据上面的demo我们可以猜测,最关键的部分就是在resources\META-INF\services目录下创建的文件,文件名是标准接口全路径,内容就是实现类的全路径。</p><p>我们平时最常见的第三方厂商当然就是mysql啦,打开mysql。在mysql-connector-java-xxx.jar中发现了META-INF\services\java.sql.Driver文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">com.mysql.jdbc.Driver</div><div class="line">com.mysql.fabric.jdbc.FabricMySQLDriver</div></pre></td></tr></table></figure><p>我们可以分析出，java.sql.Driver是一个规范接口，com.mysql.jdbc.Driver<br>com.mysql.fabric.jdbc.FabricMySQLDriver则是mysql-connector-java-xxx.jar对这个规范的实现接口。</p><p>还记得一道经典的面试题：class.forName(“com.mysql.jdbc.Driver”)到底做了什么事？</p><p>都知道class.forName与类加载机制有关，会触发执行com.mysql.jdbc.Driver类中的静态方法，从而使主类加载数据库驱动。因为数据库驱动类的特殊性质，JDBC规范中明确要求Driver类必须向DriverManager注册自己，导致其必须由class.forName手动触发。</p><p>但是在较新的mysql驱动版本中,DriverManager已经废弃了class.forName的方式而是改用spi加载jdbc驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public Void run() &#123;</div><div class="line">    ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</div><div class="line">    Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="java-spi-源码"><a href="#java-spi-源码" class="headerlink" title="java spi 源码"></a>java spi 源码</h2><p>java spi的源码主要在com.util.ServiceLoader类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final String PREFIX = &quot;META-INF/services/&quot;;</div></pre></td></tr></table></figure><p>首先定义了一个PREFIX,也就是为什么我们要把文件写在这个路径下</p><p>load方法的作用就是将接口封装为ServiceLoader,主要的功能是在遍历时实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private boolean hasNextService() &#123;</div><div class="line">            if (nextName != null) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            if (configs == null) &#123;</div><div class="line">                try &#123;</div><div class="line">                    String fullName = PREFIX + service.getName();</div><div class="line">                    if (loader == null)</div><div class="line">                        configs = ClassLoader.getSystemResources(fullName);</div><div class="line">                    else</div><div class="line">                        configs = loader.getResources(fullName);</div><div class="line">                &#125; catch (IOException x) &#123;</div><div class="line">                    fail(service, &quot;Error locating configuration files&quot;, x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            while ((pending == null) || !pending.hasNext()) &#123;</div><div class="line">                if (!configs.hasMoreElements()) &#123;</div><div class="line">                    return false;</div><div class="line">                &#125;</div><div class="line">                pending = parse(service, configs.nextElement());</div><div class="line">            &#125;</div><div class="line">            nextName = pending.next();</div><div class="line">            return true;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>代码还是比较简单,首先找到接口实现类的全限定名,根据hasNextService获取的实现类信息,使用指定的ClassLoader进行加载和实例化。</p><h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><p>Java SPI的使用很简单。也做到了基本的加载扩展点的功能。但根据上面的代码可以看到Java SPI有以下的不足:</p><ul><li>需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要的实现,并且默认会去实例化所有实现类。</li><li>配置文件中只是简单的列出了所有的扩展实现，而没有给他们命名。导致在程序中很难去准确的引用它们。</li><li>扩展如果依赖其他的扩展，做不到自动注入和装配</li><li>不提供类似于Spring的IOC和AOP功能</li><li>扩展很难和其他的框架集成，比如扩展里面依赖了一个Spring bean，原生的Java SPI不支持<br>所以Java SPI应付一些简单的场景是可以的，但对于Dubbo，它的功能还是比较弱的。Dubbo对原生SPI机制进行了一些扩展。接下来，我们就更深入地了解下Dubbo的SPI机制。</li></ul><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li>扩展点 -  java接口</li><li>扩展  -  java实现类</li><li>扩展实例 - 实例化的java类</li><li>扩展自适应点 - 根据入参不同,自动选择扩展实例。这个机制对于使用者来说是透明的,实际上就是动态代理。</li></ul><h3 id="dubbo-spi-demo"><a href="#dubbo-spi-demo" class="headerlink" title="dubbo spi demo"></a>dubbo spi demo</h3><p>例如我们要实现一个LoadBalance策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class DemoLoadBalance implements LoadBalance &#123;</div><div class="line">    @Override</div><div class="line">    public &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException &#123;</div><div class="line">        System.out.println(&quot;DemoLoadBalance: Select the first invoker...&quot;);</div><div class="line">        return invokers.get(0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>添加文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">META-INF/dubbo/com.alibaba.dubbo.rpc.cluster.LoadBalance</div></pre></td></tr></table></figure><p>内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo=com.dubbo.spi.demo.consumer.DemoLoadBalance</div></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;dubbo:reference id=&quot;helloService&quot; interface=&quot;com.dubbo.spi.demo.api.IHelloService&quot; loadbalance=&quot;demo&quot; /&gt;</div></pre></td></tr></table></figure><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>官方已经在这里已经讲的非常明白了,对java spi进行了扩展,主要是按需实例化,并且自动注入属性以及通过Wrapper提供了AOP的功能。</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html" target="_blank" rel="external">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi-2.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Socket网络编程-2</title>
      <link href="/2019/02/02/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2/"/>
      <url>/2019/02/02/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP初始化配置"><a href="#TCP初始化配置" class="headerlink" title="TCP初始化配置"></a>TCP初始化配置</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private static Socket createSocket() throws IOException &#123;</div><div class="line">    //相当于无参构造函数</div><div class="line">    Socket socket = new Socket(Proxy.NO_PROXY);</div><div class="line"></div><div class="line">    //具有http代理的构造</div><div class="line">    Proxy proxy = new Proxy(Proxy.Type.HTTP,</div><div class="line">            new InetSocketAddress(InetAddress.getByName(&quot;www.baidu.com&quot;),8080));</div><div class="line">    socket = new Socket(proxy);</div><div class="line"></div><div class="line">    //直连模式</div><div class="line">    socket = new Socket(&quot;localhost&quot;,20000);</div><div class="line"></div><div class="line">    //指定本地端口 连接到20000端口的服务器,客户端使用20001端口</div><div class="line">    socket = new Socket(InetAddress.getLocalHost(),2000,InetAddress.getLocalHost(),</div><div class="line">            20001);</div><div class="line"></div><div class="line">    //作用同上</div><div class="line">    socket = new Socket();</div><div class="line">    socket.bind(new InetSocketAddress(InetAddress.getLocalHost(),20001));</div><div class="line">    socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),20000));</div></pre></td></tr></table></figure><p>Socket有如上几种常见的初始化方式,推荐的做法是使用无参的构造函数,因为有参数的构造函数会在初始化之后就进入连接状态,在连接之后如果想进行一定的参数配置,那么这是无效的。</p><p>下面给出一些常见的socket配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private static void initSocket(Socket socket) throws SocketException &#123;</div><div class="line">    // 设置读取超时时间为2s</div><div class="line">    socket.setSoTimeout(2000);</div><div class="line">    //是否复用未完全关闭的socket地址</div><div class="line">    socket.setReuseAddress(true);</div><div class="line">    //是否开启nagle算法,默认开启. 关闭后可以理解为允许批量ack,而不是对于每个数据包都需要ack</div><div class="line">    socket.setTcpNoDelay(false);</div><div class="line">    //长时间无响应时发送确认数据,默认2h</div><div class="line">    socket.setKeepAlive(true);</div><div class="line"></div><div class="line">    //表示对于close操作如何处理</div><div class="line">    //1. false,0 默认情况,关闭时立即返回,底层接管缓冲区,如果没有发送完,则继续</div><div class="line">    //2. true,0 关闭时立即返回,缓冲区数据抛弃,发送RST到对方,无需等待2MSL</div><div class="line">    //3.  true,xx 最长阻塞200ms,然后按照2处理</div><div class="line">    socket.setSoLinger(true,200);</div><div class="line"></div><div class="line">    //是否让业务层接收到紧急数据,默认关闭,建议关闭 可以调用socket.sendUrgentData(1)发送参数的后八位</div><div class="line">    socket.setOOBInline(false);</div><div class="line"></div><div class="line">    //设置缓冲区大小</div><div class="line">    socket.setReceiveBufferSize(64*1024*1024);</div><div class="line">    socket.setSendBufferSize(64*1024*1024);</div><div class="line"></div><div class="line">    //设置连接时间,延迟,带宽对于socket性能评估的权重,如更关心延迟,则可以调高第二个参数</div><div class="line">    socket.setPerformancePreferences(1,1,1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在经过自定义的配置之后,再进行socket的bind和connect操作比较合理。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static ServerSocket createSocket() throws IOException &#123;</div><div class="line">        ServerSocket ss = new ServerSocket();</div><div class="line">        //等待连接的队列容量为50</div><div class="line">        ss.bind(new InetSocketAddress(InetAddress.getLocalHost(),20001),50);</div><div class="line"></div><div class="line">        ss = new ServerSocket(20001,50);</div><div class="line"></div><div class="line">        return ss;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>服务端的socket初始化比较简单,同样推荐使用空的构造函数,以便进行后续配置。服务端socket提供了一个backlog参数,用来表示有多少连接可以加入等待队列,当有空闲时就会从队列中取出连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void initServerSocket(ServerSocket ss) throws SocketException &#123;</div><div class="line">        ss.setReuseAddress(true);</div><div class="line">        ss.setReceiveBufferSize(64*1024*1024);</div><div class="line">        ss.setSoTimeout(2000);</div><div class="line">        ss.setPerformancePreferences(1,1,1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>配置参数也比较简单,要注意的是,这里的bufferSize并不是serverSocket的bufferSize,而是accept的client的bufferSize。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2>]]></content>
      
      
      <categories>
          
          <category> socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Socket网络编程-1</title>
      <link href="/2019/02/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/"/>
      <url>/2019/02/01/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<p>最近一直在研究Dubbo原理,想深入进去发现内部网络框架使用了Netty,而之前研究过很久Netty发现已经忘得差不多了。回头看了一下Netty,发现自己对底层的网络、Socket都不是很熟悉,所以这里从更底层的socket入手,后面再总结Dubbo。</p><h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzr71jnsy9j30rw0k875b.jpg" alt=""></p><p>这是大学教材上计网的第一课,OSI是一个非常理想化的模型,并没有在实际中应用。</p><p>最上层是应用层,也就是我们编写app所在的层级,下一层表示层就是用来将应用层的信息表示成数据层面的东西,例如将字符串转换为byte数组。会话层的主要功能是在两个节点间建立、维护和释放面向用户的连接,并对会话进行管理和控制,保证会话数据可靠传送。传输层的作用就是在必要的时候对消息进行分割,并保证有效性,向下交给网络层。网络层的作用就是控制子网的运行,例如对逻辑地址进行分组的传输,以及路由的选择。数据链路层更加底层,是对物理地址的一个寻找,并将原始比特流转换为逻辑的传输路线,物理层可以理解为比特流与电信号之间的转换。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzr7djjmjsj30t60kwad1.jpg" alt=""></p><p>上图是一个tcp/ip模型与osi模型的映射关系以及一些常见的协议。</p><h2 id="Socket与TCP-UDP"><a href="#Socket与TCP-UDP" class="headerlink" title="Socket与TCP/UDP"></a>Socket与TCP/UDP</h2><p>Socket简单来说是一个端口+ip的结合描述协议(RFC793),是TCP/IP协议相关API的总称,是网络API的集合实现,涵盖了Datagram socket和stream socket。</p><p>TCP是面向连接的协议,通过三次握手建立连接,通讯完成后拆除连接。</p><p>UDP是面向无连接的通讯协议,数据包括源端口号和目标端口号,由于通讯不是端到端的,所以可以实现广播发送</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>一个简单的socket通信编程demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Server &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket server = new ServerSocket(2000);</div><div class="line">        System.out.println(&quot;服务器启动&quot;);</div><div class="line"></div><div class="line">        //等待连接</div><div class="line">        for(;;)&#123;</div><div class="line">            Socket client = server.accept();</div><div class="line">            if(client!=null)&#123;</div><div class="line">                ClientHandle clientHandle = new ClientHandle(client);</div><div class="line">                clientHandle.start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class ClientHandle extends Thread&#123;</div><div class="line">        private Socket socket;</div><div class="line">        private boolean flag = true;</div><div class="line"></div><div class="line">        ClientHandle(Socket socket)&#123;</div><div class="line">            this.socket = socket;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;客户端连接&quot;+socket.getPort());</div><div class="line">            try &#123;</div><div class="line">                    PrintStream socketOutput = new PrintStream(socket.getOutputStream());</div><div class="line">                    BufferedReader socketInput  = new BufferedReader(</div><div class="line">                            new InputStreamReader(socket.getInputStream()));</div><div class="line">                do&#123;</div><div class="line">                    String str = socketInput.readLine();</div><div class="line">                    if(str.equalsIgnoreCase(&quot;bye&quot;))&#123;</div><div class="line">                        socketOutput.println(str);</div><div class="line">                        flag=false;</div><div class="line">                    &#125;else&#123;</div><div class="line">                        System.out.println(str);</div><div class="line">                        socketOutput.println(&quot;reply &quot;+str);</div><div class="line">                    &#125;</div><div class="line">                &#125;while (flag);</div><div class="line">                socketInput.close();</div><div class="line">                socketOutput.close();</div><div class="line">            &#125;catch (Exception e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;finally &#123;</div><div class="line">                try &#123;</div><div class="line">                    socket.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;客户端断开&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        Socket socket = new Socket();</div><div class="line">        socket.setSoTimeout(3000);</div><div class="line">        socket.connect(new InetSocketAddress(Inet4Address.getLocalHost(),2000));</div><div class="line">        System.out.println(&quot;连接完成&quot;);</div><div class="line">        try &#123;</div><div class="line">            todo(socket);</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        socket.close();</div><div class="line">        System.out.println(&quot;客户端退出&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void todo(Socket socket) throws IOException &#123;</div><div class="line">        InputStream in = System.in;</div><div class="line">        BufferedReader input = new BufferedReader(new InputStreamReader(in));</div><div class="line">        //得到socket输出流,打印</div><div class="line">        OutputStream outputStream = socket.getOutputStream();</div><div class="line">        PrintStream printStream = new PrintStream(outputStream);</div><div class="line"></div><div class="line">        InputStream inputStream = socket.getInputStream();</div><div class="line">        BufferedReader sbuff = new BufferedReader(new InputStreamReader(inputStream));</div><div class="line"></div><div class="line">        boolean  flag=true;</div><div class="line">        do &#123;</div><div class="line">            String str = input.readLine();</div><div class="line">            printStream.println(str);</div><div class="line"></div><div class="line">            String ret = sbuff.readLine();</div><div class="line">            if (&quot;bye&quot;.equalsIgnoreCase(ret)) &#123;</div><div class="line">                flag=false;</div><div class="line">            &#125;else&#123;</div><div class="line">                System.out.println(ret);</div><div class="line">            &#125;</div><div class="line">        &#125;while (flag);</div><div class="line">        sbuff.close();</div><div class="line">        inputStream.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面简单写了一个socket通信的demo,可以看到本身java调用socket进行连接是非常简单的,但是一旦涉及到这些IO读写就会变得很复杂,各种stream,reader之间相互转换,后面再对java io进行一下总结。</p>]]></content>
      
      
      <categories>
          
          <category> socket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal源码阅读</title>
      <link href="/2019/01/02/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2019/01/02/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>ThreadLocal是开发中比较常用的一个工具,可以用来传递变量或者做数据隔离。那么ThreadLocal是如何实现线程隔离呢,可以通过set方法来看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">       Thread t = Thread.currentThread();</div><div class="line">       ThreadLocalMap map = getMap(t);</div><div class="line">       if (map != null)</div><div class="line">           map.set(this, value);</div><div class="line">       else</div><div class="line">           createMap(t, value);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   </div><div class="line">   ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">       return t.threadLocals;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>首先set方法获取了当前线程,然后获取当前线程的threadLocals变量,其中ThreadLocalMap类的定义是在ThreadLocal类中，真正的引用却是在Thread类中。得到map后如果不为null,则将当前threadLocal对象作为key,放入map,否则创建一个map再赋值。</p><p>刚开始看这里很让人费解的一个地方就是为什么要用ThreadLocal对象作为key呢？为什么不能直接以当前线程的ID作为key呢?</p><p>这里想了很久突然明白了,因为一个线程可以创建多个ThreadLocal去存储变量,那么如果我用线程ID去作为key,那么当有多个threadLocal的时候就不知道取哪一个了,所以使用threadLocal作为key,但其实还是取了threadLocal内部的一个hashcode作为唯一标示。</p><p>进入ThreadLocalMap源码,它的实现是一个Entry数组,Entry的key为ThreadLocal的弱引用,value为变量值。也就是说在这里如果使用threadLocal对象作为key,有一个好出就是当发生gc时,没有用的threadLocal会被回收,而如果使用线程ID,则这个threadLocal不会被回收。但是threadLocalMap对象并没有被回收,也就是说value是个强引用,key被回收后会形成一个key为null的Entry。</p><p>所以这时如果这个线程是个耗时非常长的业务,或者你在线程池中使用了threadLocal,那么这里就会一直存在内存占用,过多就形成了内存泄露。 </p><p>为了解决这个问题,map的get/set操作都会对无效的key进行清理,或者调用remove方法进行清理,所以这里依赖于程序员的良好习惯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line"></div><div class="line">            // We don&apos;t use a fast path as with get() because it is at</div><div class="line">            // least as common to use set() to create new entries as</div><div class="line">            // it is to replace existing ones, in which case, a fast</div><div class="line">            // path would fail more often than not.</div><div class="line"></div><div class="line">            Entry[] tab = table;</div><div class="line">            int len = tab.length;</div><div class="line">            int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">            for (Entry e = tab[i];</div><div class="line">                 e != null;</div><div class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">                ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">                if (k == key) &#123;</div><div class="line">                    e.value = value;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (k == null) &#123;</div><div class="line">                    replaceStaleEntry(key, value, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            tab[i] = new Entry(key, value);</div><div class="line">            int sz = ++size;</div><div class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">                rehash();</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>那么key是否可以作为一个强引用呢?使用强引用会带来什么问题呢?</p><p>如果key使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。所以这里使用弱引用如果有良好的习惯,每次操作完remove,造成的问题会比强引用小。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>消息队列阶段性使用总结</title>
      <link href="/2018/12/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>一年多来在工作中接触了Kafka、ActiveMQ,业余时间自己学习了RabbitMQ,基本上已经是市面上主流的几款MQ软件了,后面有时间会继续看一下RocketMQ。</p><p>MQ虽然可以用来对系统进行异步调用、解耦,提高用户体验和优化架构。但是MQ降低了系统的可用性,因为当系统进行MQ的改造后,MQ的故障会导致下游的服务不可用和分布式一致性问题。所以在技术上首先要保证MQ集群始终处于可用的状态。</p><h2 id="MQ集群方案"><a href="#MQ集群方案" class="headerlink" title="MQ集群方案"></a>MQ集群方案</h2><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>kafka的集群依赖于Zookeeper,因此首要保证ZK的可用性,可以使用3-5台(2n+1)。Zookeeper集群的工作是超过半数才能对外提供服务。</p><p>接着部署多台Kafka,注册到ZK上,Kafka会通过选举选出leader和follower以及replica机制提供集群高可用</p><h3 id="activeMQ"><a href="#activeMQ" class="headerlink" title="activeMQ"></a>activeMQ</h3><p>activemq提供了多种Master/slave模式的集群,公司使用Replicated LevelDB Store的集群方式,也是5.9版本后官方推荐的一种集群方式</p><p>Replicated LevelDB Store方案使用Zookeeper选举Master。要进行选举，则需要多数派的“参与者”。因为Replicated LevelDB Store中有多个Broker，从多个Broker中选举出一个成为Master，其他的则成为Slave。只有Master接收Client的连接，Slave负责连接到Master，并接收（同步方式、异步方式）Master上的数据。<br> 比如说：一共有3个Broker，一个Master，二个Slave。当新消息到达Master时，Master需要将消息同步到其中一台Slave之后，才能向Producer发送ACK确认此次消息成功发送。<br>而剩下的另一台Slave，则可以在后台以异步方式复制这个新消息。此外，还能容忍一台Slave宕机。（能容忍不超过大多数的Broker宕机）</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>常见的RabbitMQ集群有两种:</p><ol><li>普通模式</li></ol><p>对于Queue来说,消息只会存储在一个MQ节点上,当请求到达其他节点时,其他节点会来临时请求这个节点的消息。这样做避免了各个节点消息同步,节省了空间,但是当存储消息的节点挂掉,在恢复之前消息都会丢失。</p><ol><li>镜像模式</li></ol><p>把需要的队列做成镜像队列。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。</p><h2 id="消息生产保障"><a href="#消息生产保障" class="headerlink" title="消息生产保障"></a>消息生产保障</h2><p>一个非常常见的问题是,怎么保证投递出去的消息一定不会丢失？</p><p>个人认为,这个问题可以拆分为如何保证生产端消息投递成功,如何保证消费端一定收到消息这样两个问题:</p><h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><ol><li>rabbitmq在发送端提供了publish-confirm和publish-return机制。</li></ol><p>publish-return机制用来告诉生产者消息有没有被路由到正确的queue中,如果找到的正确的destination则会返回ack,否则返回unack。</p><p>publish-confirm能够在消息进入目标队列后返回一个ack或者unack告诉生产端,如果broker正确处理这条消息,会返回ack。如果broker内部处理时发生了异常,就会返回unack。</p><p>这就使得生产者知道消息是否正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出。confirm是一种异步的机制,发送者不必等待消息的确认。confirm机制可以视为一种发送端的事务机制,生产端通过回调消息来对消息进行重新处理。但是Confirm机制，无法进行回滚，就是一旦服务器崩溃，生产者无法得到Confirm信息，生产者其实本身也不知道该消息是否已经被持久化，只有继续重发来保证消息不丢失，但是如果原先已经持久化的消息，并不会被回滚，这样队列中就会存在两条相同的消息，系统需要支持去重。</p><ol><li>ActiveMQ</li></ol><p>Activemq应该是没有专门为生产端保证消息投递的确认机制,我在做这里的时候是根据抛出的JMSException来进行一些补偿处理,同样这里会遇到的问题是你并不确认这个消息是否真的到达了消息队列,当你进行补偿时可能造成了重复消息,这同样需要消费端支持消息去重。</p><ol><li>Kafka</li></ol><p>对于Kafka,注重的是高吞吐,一般涉及业务逻辑的消息都不会选择kafka,它提供了三种可靠性投递保证:</p><ul><li>生产端发送出去就算成功</li><li>Master-Slave模型，只有当Master和所有Slave都接收到消息时，才算投递成功，这种模型提供了最高的投递可靠性，但是损伤了性能</li><li>即只要Master确认收到消息就算投递成功</li></ul><p>实际使用中都会折中选择第三种方案</p><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>对于消费端,大多数业务系统都会选择进行手动签收。当取到消息,进行正确处理并入库,才会对broker返回ack。</p><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>仅仅依赖于上述消息队列提供的消息保证机制是不够的,因为MQ并不擅长做这个。对于业务要求比较严格的场景,每条消息都需要可追溯,也就需要对消息落库,并通过定时任务扫描状态异常的消息,进行重新发送或者人工干预。</p><p>对于吞吐率要求比较高的系统,落库的负担就太大,这时比较常用的一种方案就是延迟确认消息。在发送业务消息的同时发送一条延迟确认消息,确认消费端系统是否正确处理消息。这种方案在于提高了系统的吞吐量但是可能造成一段时间内业务状态不一致。</p><h2 id="如何保证消息不重复"><a href="#如何保证消息不重复" class="headerlink" title="如何保证消息不重复"></a>如何保证消息不重复</h2><p>虽然这时我们解决了消息投递问题,但是它又引入了消息重复的问题。消息重复投递的原因可能在broker,也可能在生产端和消费端。那么我们可以把问题简化为如何保证消费端消费消息的幂等性,那么这时就可以忽略broker和生产者带来的问题。</p><p>首先每个消息都会有一个MessageID,这应该是全局唯一的。消费端要做的就是将存储MessageId以及这条消息的处理状态。当消息来的时候首先要在消息表对比是否已经成功处理这条消息,成功处理则将这条消息丢弃。这里消费端需要注意控制并发,因为重复消息可能同时到达,在并发消费。在查询时可以限制时间范围,因为一般重复消息间隔时间不会太久。</p><h2 id="消息顺序消费保证"><a href="#消息顺序消费保证" class="headerlink" title="消息顺序消费保证"></a>消息顺序消费保证</h2><ol><li>rabbitmq/activemq 保证消息顺序是通过独占队列(exclusive)来保证,这样虽然可以严格保证消息顺序,但是无法进行扩展,吞吐率低。对于QPS高的系统确实是无法承受的。更好的处理方式就是不处理,因为MQ并不是设计来做这些的。所以消费端就需要对消息顺序做处理。生产端在消息中附加额外的信息,版本号 &amp; 状态机 &amp; msgid &amp; parent_msgid，通过 parent_msgid 判断消息的顺序（需要全局存储，记录消息的执行状态）</li></ol><ol><li>如果要Kafka本身保证顺序消费,就失去了使用Kafka的意义。这种场景不应该选择kafka。只能将处理逻辑放到应用中。</li></ol><h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p>关键还是在消费端进行配置,有两个关键参数:concurrentConsumerCount 和 prefetchCount。可以适当提高这两个参数。</p><h2 id="各个MQ的缺陷"><a href="#各个MQ的缺陷" class="headerlink" title="各个MQ的缺陷"></a>各个MQ的缺陷</h2><p>相比于知道各个MQ的优势,知道它们的劣势更加重要,因为在选型的时候首先要将不能满足要求的进行排除</p><h3 id="AMQ"><a href="#AMQ" class="headerlink" title="AMQ"></a>AMQ</h3><p>AMQ的消息模型比较简单,只支持PTP和topic两种模式。对于消息分组的场景支持比较弱(依赖于消费端的选择器),权限精度不高,社区不活跃可用插件比较少,控制台功能比较简单。</p><p>据说会有消息丢失等问题,但是我没遇到过。</p><h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>相比于AMQ有更高的性能,相比于Kafka支持更多的场景。在产生消息堆积时性能会有大幅度下降,使用erlang开发,进行修改或二次开发比较困难。是大多数互联网公司的选择。</p><h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><p>速度快,吞吐量高,适合处理大量数据,如日志场景。Kafka的核心概念就是partition,consumer消费是通过绑定partition来消费的。如果consumer数量大于partition数量就会浪费,所以最佳就是consumer和partition成比例关系。这种静态的绑定会导致扩缩容的麻烦,也就是当流量高峰时,仅仅增加consumer不能解决问题,还要增加partition。但是partition增加后又不能再减少,最后导致rebalance。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(7) Consumer高级特性</title>
      <link href="/2018/12/08/JMS-7-Consumer%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2018/12/08/JMS-7-Consumer%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="独占消费者"><a href="#独占消费者" class="headerlink" title="独占消费者"></a>独占消费者</h2><p>Queue中的消息是按照顺序分发到consumer。然而当你有多个consumer的时候,这个顺序就无法进行保证。可以通过设置消息独占来保证顺序消费问题,这样broker会在consumer中选择一个进行发送,如果发送期间consumer挂掉,broker会自动切换到其他consumer上进行发送。</p><p>创建独占消费者方式如下,还可以配合优先级进行优化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Queue queue6()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;ex.q?consumer.exclusive=true&amp;consumer.priority=10&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Message-Group"><a href="#Message-Group" class="headerlink" title="Message Group"></a>Message Group</h2><p>Message Group可以看成一种并发的exclusive consumer。JMS消息属性JMSXGroupID用来区分message group。Message Group特性保证所有具有相同JMSXGroupID的消息会被分发到相同的consumer。</p><p>除此之外,Message Group也是一种负载均衡机制,在一个消息被分发到consumer之前,会去检查消息JMSXGroupID,如果存在,broker会寻找相同JMSXGroupID的consumer。如果没有,broker会选择一个consumer,并将它关联到这个Message Group。此后这个consumer 都会收到这类Message,知道consumer关闭或者Message Group关闭(发送一个消息,设置JMSXGroupSeq为-1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jmsTemplate.send(&quot;queue.a&quot;,new MessageCreator() &#123;</div><div class="line">            @Override</div><div class="line">            public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                TextMessage message = session.createTextMessage();</div><div class="line">                message.setStringProperty(&quot;JMXGroupID&quot;,&quot;G1&quot;);</div><div class="line">                return message;</div><div class="line">            &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="消息选择器"><a href="#消息选择器" class="headerlink" title="消息选择器"></a>消息选择器</h2><blockquote><p>参考<a href="https://www.cnblogs.com/ywjy/articles/5433826.html" target="_blank" rel="external">https://www.cnblogs.com/ywjy/articles/5433826.html</a></p></blockquote><p>通过类sql的语法,为consumer指定message的筛选条件。</p><p>发送端设置属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jmsTemplate.send(topic1, new MessageCreator() &#123;</div><div class="line">            @Override</div><div class="line">            public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                TextMessage textMessage = session.createTextMessage();</div><div class="line">                textMessage.setIntProperty(&quot;count&quot;,10);</div><div class="line">                return textMessage;</div><div class="line">            &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>消费端过滤属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@JmsListener(destination = &quot;file&quot;,selector = &quot;count &gt; 5&quot;)</div></pre></td></tr></table></figure><h2 id="慢消费"><a href="#慢消费" class="headerlink" title="慢消费"></a>慢消费</h2><p>慢消费会在非持久的topic上出现问题,导致消息积压在broker内存中,拖垮整个broker。除了调整客户端prefetchSize,目前AMQ使用Pending Message Limit Strategy来解决这个问题。</p><p>Pending Message Limit Strategy(等待消息限制策略)有两种:</p><ol><li>Constant Pending Message Limit Strategy:</li></ol><p>limit 大小可以设置为0,-1,&gt;0。0表示不额外增加预存大小,-1表示不增加也不丢弃消息,&gt;0表示需要额外增加的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constantPendingMessageLimitStrategy limit=&quot;50&quot;&gt;</div></pre></td></tr></table></figure><ol><li>Prefetch Rate Pending Message Limit Strategy:</li></ol><p>参数表示扩大目前prefetchSize的多少倍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;PrefetchRatePendingMessageLimitStrategy multiplier=&quot;3&quot;&gt;</div></pre></td></tr></table></figure><p>添加配置的位置在destinationPolicy-&gt;policyMap-&gt;policyEntries-&gt;policyEntry中。</p><p>消息丢弃策略目前提供三种:</p><ol><li><p>oldestMessageEvicationStrategy:丢弃最旧的消息</p></li><li><p>oldestMessageWithLowestPriorityEvicationStrategy:最旧且优先级最低</p></li><li><p>uniquePropertyMessageEvicationStrategy: 根据消息设置的属性来丢弃消息</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uniquePropertyMessageEvicationStrategy propertyName=&quot;STOCK&quot; /&gt;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(6) Message高级特性</title>
      <link href="/2018/12/08/JMS-6-Message%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2018/12/08/JMS-6-Message%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="延时投递与定时投递"><a href="#延时投递与定时投递" class="headerlink" title="延时投递与定时投递"></a>延时投递与定时投递</h2><p>AMQ提供了对消息的定时调度机制,只需要把调度信息设置在message中即可。</p><p>首先要在xml中开启设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schedulerSupport=&quot;true&quot;</div></pre></td></tr></table></figure><ul><li>一共四个属性:</li></ul><ol><li>AMQ_SCHUDULED_DELAY: 延迟投递的时间</li><li>AMQ_SCHUDULED_PERIOD: 延迟投递时间间隔</li><li>AMQ_SCHUDULED_REPEAT: 重复次数</li><li>AMQ_SCHUDULED_CRON: cron表达式</li></ol><ul><li>AMQ也提供了封装的消息类型:org.apache.activemq.scheduledMessage</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jmsTemplate.send(new MessageCreator() &#123;</div><div class="line">                @Override</div><div class="line">                public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                    TextMessage textMessage = session.createTextMessage();</div><div class="line">                    //设置延时投递 60s</div><div class="line">                    textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY,60*1000);</div><div class="line">                    //重复3次</div><div class="line">                    textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT,3);</div><div class="line">                    return textMessage;</div><div class="line">                &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="Blob-Message"><a href="#Blob-Message" class="headerlink" title="Blob Message"></a>Blob Message</h2><p>BlobMessage是用来传递较大的二进制信息,在AMQ的新版本中,默认是关闭的,因为这种方式可能造成安全漏洞。</p><p>可以在发送端的url上进行设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://192.168.1.1:61619?jms.blobTransferPolicy.uploadUrl=http://xx.xx.xx.xx/nsfvol/fhms/</div></pre></td></tr></table></figure><p>sending blobmessage的方式:</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzba3faj1j31880dm3zo.jpg" alt=""></p><p>可以看到这里有三种发送blob Message的方式: url、File 或者 Inputstream,这里需要注意的是由于blobMessage是AMQ提供的扩展,所以要将jms的session强转为Amq的session。</p><p>文件接收方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@JmsListener(destination = &quot;file&quot;)</div><div class="line">    public void fileQ(Message message) throws IOException, JMSException &#123;</div><div class="line">        if(message instanceof BlobMessage)&#123;</div><div class="line">            BlobMessage blobMessage = (BlobMessage) message;</div><div class="line">            InputStream inputStream = blobMessage.getInputStream();</div><div class="line">            byte[] data = new byte[inputStream.available()];</div><div class="line">            inputStream.read(data);</div><div class="line">            inputStream.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(5)-AMQ Message Dispatch</title>
      <link href="/2018/12/07/JMS-5-AMQ-Message-Dispatch/"/>
      <url>/2018/12/07/JMS-5-AMQ-Message-Dispatch/</url>
      
        <content type="html"><![CDATA[<h2 id="Message-Cursor"><a href="#Message-Cursor" class="headerlink" title="Message Cursor"></a>Message Cursor</h2><p>AMQ发送持久化消息的典型处理方式为,当消费者准备就绪,broker把存储的消息按批次发送给消费者,发送完成后,指针向后移动。这时一种比较理想的方式。在AMQ 5.0版本之后,消息发送开始采用一种混合模式,当消费者活跃时,直接将持久消息发送给消费者,当消费者不活跃时,采用cursor来处理发送消息。</p><blockquote><p>当消费者活跃,处理能力比较强时,消息的直接发送到消费端</p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxy9mb9u2lj30pu0dgjr9.jpg" alt=""></p><blockquote><p>当消息产生积压,消费者再度活跃时,或者消费者的消费速度比生产速度慢时,消息从pending cursor取出,发送到消费队列。</p></blockquote><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxy9tgmrq3j30qi0bqdfq.jpg" alt=""></p><p>Message Cursor有三种类型:</p><ol><li>Store-based</li></ol><p>AMQ 5.0之后的默认类型,支持持久化和非持久化,内嵌了file-based。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxyazo6b1wj31100k2jri.jpg" alt=""></p><ol><li>VM</li></ol><p>这种方式的消息存储在内存中,这种方式处理很快,但是当出现消费端慢消费就可能出现问题。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxybs0h8uzj30vk09u747.jpg" alt=""></p><ol><li>File-based</li></ol><p>当内存达到限制,消息就会被存储到文件系统的临时文件中</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxybvbvzfyj30p80iqt8o.jpg" alt=""></p><h2 id="分发策略"><a href="#分发策略" class="headerlink" title="分发策略"></a>分发策略</h2><ol><li>严格顺序分发</li></ol><p>AMQ会保证topic consumer以相同的顺序接收来自同一个producer的消息,但有时也需要保证消费者能以相同的顺序消费来自不同topic producer的消息。例如生产者p1 p2 通过topic关联了c1 c2,p1生产了消息1,2,3而p2生产消息4,5,6。这时c1的消费顺序是123456,而c2的消费顺序是456123。如果我们需要严格保证两个c的消费顺序,这时就会需要严格顺序分发。</p><p>保证严格顺序的一个负面效果就是性能会降低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;policyEntry topic=&quot;Orders.&gt;&quot;&gt;</div><div class="line">    &lt;dispatchPolicy&gt;</div><div class="line">        &lt;strictOrderDispatchPolicy/&gt;</div><div class="line">    &lt;/dispatchPolicy&gt;</div><div class="line">&lt;/policyEntry&gt;</div></pre></td></tr></table></figure><ol><li>轮询分发策略</li></ol><p>在某些情况下,消息的数量比较少,但每次处理消息的时间会比较长,那么在默认的prefetch参数和dispatch policy下,这些消息会倾向于发送到某个consumer上,就会因为负载不均导致处理时间增加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;policyEntry topic=&quot;Orders.&gt;&quot;&gt;</div><div class="line">    &lt;dispatchPolicy&gt;</div><div class="line">        &lt;roundRobinDispatchPolicy/&gt;</div><div class="line">    &lt;/dispatchPolicy&gt;</div><div class="line">&lt;/policyEntry&gt;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(4)-AMQ Destination特性</title>
      <link href="/2018/12/07/JMS-4-AMQ-Destination%E7%89%B9%E6%80%A7/"/>
      <url>/2018/12/07/JMS-4-AMQ-Destination%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="wildcards"><a href="#wildcards" class="headerlink" title="wildcards"></a>wildcards</h2><p>wildcards用来支持名字分层体系,它不属于JMS规范,是AMQ的一个扩展。</p><p>AMQ支持三种wildcards:</p><ol><li><p>‘.’, 路径上名字的分隔符</p></li><li><p>‘*’, 常见的通配符,匹配路径上的所有</p></li><li><p>‘&gt;’,递归匹配以这个名字开头的dest</p></li></ol><p>例如下面两个dest:</p><p>PRICE.STOCK.CN.WANDA<br>PRICE.STOCK.AM.ALIBABA</p><ol><li>PRICE.&gt; 匹配所有的价格变动</li><li>PRICE.STOCK.&gt;匹配所有的股价变动</li><li>PRICE.STOCK.CN.* 匹配所有A股变动</li><li>PRICE.STOCK.*.ALIBABA 匹配与阿里相关的股价变动</li></ol><h2 id="组合队列-composite-destination"><a href="#组合队列-composite-destination" class="headerlink" title="组合队列 composite destination"></a>组合队列 composite destination</h2><p>组合队列允许用一个虚拟的dest代表多个dest,这样就可以通过组合队列在一个操作中同时向多个queue发送消息。</p><p>不同队列名用’,’隔开。如果有topic有ptp,则需要写明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">public Queue queue()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;queue.a,queue.b&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public Queue queue2()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;queue://queue.a,topic://topic.a&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="delete-inactive-destination"><a href="#delete-inactive-destination" class="headerlink" title="delete inactive destination"></a>delete inactive destination</h2><p>上面的组合队列可以很大程度上方便使用,但是可能会造成创建过多的队列,那么就需要一种功能能够自动删除无用的队列。当然也可以通过控制台或者jms远程删除。</p><p>这种方式需要在配置文件进行配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; schedulePeriodForDestinationPurge=&quot;10000&quot;&gt;</div><div class="line"></div><div class="line">&lt;destinationPolicy&gt;</div><div class="line">    &lt;policyMap&gt;</div><div class="line">        &lt;policyEntries&gt;</div><div class="line">                &lt;policyEntry topic=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimeoutBeforeGC=&quot;30000&quot;&gt;</div><div class="line">                &lt;/policyEntry&gt;</div><div class="line">        &lt;/policyEntries&gt;</div><div class="line">    &lt;/policyMap&gt;</div><div class="line">&lt;/destinationPolicy&gt;</div><div class="line"></div><div class="line">&lt;/destinationPolicy&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure><p>schedulePeriodForDestinationPurge 设置检查间隔,单位ms</p><p>inactiveTimeoutBeforeGC 表示空闲多久会被删除,单位ms</p><p>gcInactiveDestinations=true 删除不活动的队列</p><h2 id="Destination-options"><a href="#Destination-options" class="headerlink" title="Destination options"></a>Destination options</h2><p>这个特性是AMQ在JMS规范之外提供的特性,以一种url的方式可以对队列进行一些配置。</p><ol><li><p>consumer.prefechSize: consumer一次可以拉取的最大消息数量</p></li><li><p>consumer.maximumPendingMessageLimit: 当存在慢消费的情况时,非持久化的topic允许丢弃消息的最大值</p></li><li><p>consumer.retroactive: 是否为回溯消费者</p></li><li><p>consumer.dispatchAsync: 是否异步分发,默认为true</p></li><li><p>consumer.exclusive: 是否为独占消费者,默认false</p></li><li><p>consumer.priority: 消费者优先级,默认为0</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Queue queue3()&#123;</div><div class="line">        return new ActiveMQQueue(&quot;queue.c?consumer.priority=false&amp;consumer.prefechSize=10&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Visual-Destitation"><a href="#Visual-Destitation" class="headerlink" title="Visual Destitation"></a>Visual Destitation</h2><p>虚拟dest创建的是逻辑dest,客户端和消费端通过它来生产和消费消息,并把它映射到物理dest。AMQ支持两种方式:</p><ol><li><p>visual topic 虚拟主题</p></li><li><p>composite destination 组合</p></li></ol><p>虚拟dest的作用体现在哪里呢?</p><p>在AMQ,topic只有在持久订阅下才是持久化的,它的每个订阅者都会收到所有的消息。但它存在两个问题:</p><ol><li><p>同一个应用只能用一个listener去监听topic,而不能使用多个,通过负载均衡来处理消息(当消费端部署了多个节点,那么每个节点都会消费一遍这个消息,而我们理想的情况是a节点处理n条,b节点处理m条)。虽然PTP模式可以解决这个问题,但明显会创建过多的Queue。所以,又要订阅发布,又要消息分组,JMS本身是不支持的。</p></li><li><p>同一个应用内,消费者failover问题。由于只能有单个持久订阅者,如果这个订阅者离线,那么消息就无法处理,系统健壮性不足。</p></li></ol><p>为了解决这个问题,AMQ提出了visual topic</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Topic topic()&#123;</div><div class="line">        return new ActiveMQTopic(&quot;VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于消费者来说,只需要创建正常的topic,然后以’VirtualTopic’开头。</p><p>对于消费端来说,需要将自己视为一个队列,不同的应用使用不同的队列名,即可表示自己是一个消费端的负载均衡。队列名必须以‘Consume’开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Queue queue4()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;Consumer.A.VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public Queue queue5()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;Consumer.B.VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Mirrored-Queues"><a href="#Mirrored-Queues" class="headerlink" title="Mirrored Queues"></a>Mirrored Queues</h2><p>AMQ中每个Queue中的消息只能被一个consumer消费。但有时候你可能希望监视消息流。因此AMQ提供了mirrored queue机制,broker会把发送到某个queue的消息转发到一个名称类似的topic,监视程序只需要监听这个mirrored queue topic。</p><p>首先要对broker进行配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;$&#123;activemq.data&#125;  useMirroredQueues=&quot;true&quot;&gt;</div></pre></td></tr></table></figure><p>如果不进行其他配置,默认的mirror topic前缀是 ‘VirtualTopic.Mirror.’,当然也支持自定义格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;destinationInterceptors&gt;</div><div class="line">    &lt;mirroredQueue copyMessage=&quot;true&quot; postPrefix=&quot;.mirror&quot; prefix=&quot;mirror.&quot;&gt;</div><div class="line">&lt;/destinationInterceptors&gt;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(3)-JMS API结构</title>
      <link href="/2018/12/06/JMS-3-JMS%E7%BB%93%E6%9E%84/"/>
      <url>/2018/12/06/JMS-3-JMS%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxx3glglroj30n40hm0tm.jpg" alt=""></p><p>JMS API的结构还是比较简单的。</p><p>创建一个JMS的基本步骤是:</p><ol><li>创建JMS ConnectionFactory</li><li>通过ConnectionFactory创建一个Connection</li><li>通过Connection创建jms session</li><li>创建destination、producer、consumer</li><li>发送消息</li><li>关闭资源</li></ol><h2 id="JmsTempate"><a href="#JmsTempate" class="headerlink" title="JmsTempate"></a>JmsTempate</h2><p>在Springboot中一般使用JmsTempate进行操作,所以对照上面的过程,看一下template是如何进行封装的。</p><ol><li>引入Pom</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;</div><div class="line">&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</div><div class="line">&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><ol><li>code</li></ol><p>首先在启动类上添加注解@EnableJms,会启动一些JMS的自动配置,包括JmsTempate。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public JmsTemplate(ConnectionFactory connectionFactory) &#123;</div><div class="line">this();</div><div class="line">setConnectionFactory(connectionFactory);</div><div class="line">afterPropertiesSet();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JmsTemplate的构造函数中需要一个ConnectionFactory,因此会先实例化一个ConnectionFactory。也就对应了上面过程中的第一步。</p><p>当注入JmsTemplate我们就可以调用send方法进行消息发送,非常简单。但正是因为它封装的太好了,我们反而不容易了解它的具体实现细节,所以进入send方法的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void send(final Destination destination, final MessageCreator messageCreator) throws JmsException &#123;</div><div class="line">execute(session -&gt; &#123;</div><div class="line">doSend(session, destination, messageCreator);</div><div class="line">return null;</div><div class="line">&#125;, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>send方法调用了内部方法execute,而且我们看到一个关键参数名session,这里是一个lambda表达式,在session内封装了消息和destination,然后丢进execute方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; action, boolean startConnection) throws JmsException &#123;</div><div class="line">Assert.notNull(action, &quot;Callback object must not be null&quot;);</div><div class="line">Connection conToClose = null;</div><div class="line">Session sessionToClose = null;</div><div class="line">try &#123;</div><div class="line">Session sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(</div><div class="line">obtainConnectionFactory(), this.transactionalResourceFactory, startConnection);</div><div class="line">if (sessionToUse == null) &#123;</div><div class="line">conToClose = createConnection();</div><div class="line">sessionToClose = createSession(conToClose);</div><div class="line">if (startConnection) &#123;</div><div class="line">conToClose.start();</div><div class="line">&#125;</div><div class="line">sessionToUse = sessionToClose;</div><div class="line">&#125;</div><div class="line">if (logger.isDebugEnabled()) &#123;</div><div class="line">logger.debug(&quot;Executing callback on JMS Session: &quot; + sessionToUse);</div><div class="line">&#125;</div><div class="line">return action.doInJms(sessionToUse);</div><div class="line">&#125;</div><div class="line">catch (JMSException ex) &#123;</div><div class="line">throw convertJmsAccessException(ex);</div><div class="line">&#125;</div><div class="line">finally &#123;</div><div class="line">JmsUtils.closeSession(sessionToClose);</div><div class="line">ConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>execute方法创建connection,绑定session。调用doInJms方法将message发送到broker,然后释放资源。</p><p>这样粗略的看了一下消息的发送原理。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(2)-可靠性保证与消息模型</title>
      <link href="/2018/12/06/JMS-2-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/"/>
      <url>/2018/12/06/JMS-2-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>对于一个消息中间件来说,可靠性保证一直是一个重要主题。Jms消息的可靠性保证,通常包含三个阶段: 客户端接收消息/客户端处理消息/客户端ACK</p><p>在事务性会话中(jms session),当事务被提交,即发生自动确认。在非事务会话中,消息的确认取决于应答模式:包含三种应答模式:</p><ul><li>client 客户端手动确认</li><li>auto 自动确认</li><li>dups_ok 一种延迟确认的模式,个人理解是一种批量签收。可以减少开销,但是可能会造成重复的ack。如果没有仔细研究过原理,不建议使用</li></ul><h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>JMS消息持久化有两种方式:</p><p>PERSISTENT: 持久化模式,消息不会因为broker宕机而丢失,默认模式</p><p>NO_PERSISTENT: broker宕机,消息丢失</p><p>ActiveMQ内部消息存储默认使用了KahaDB,同时开支持的方式有AMQ,JDBC,Memory。可以在activemq.xml中对KahaDB进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">    &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot;/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure><p>可用属性:</p><ol><li><p>indexWriteBatchSize: 批量写入磁盘索引的数量,默认1000</p></li><li><p>indexCacheSize: 内存中缓存索引的page数量,默认1000</p></li><li><p>enableIndexWriteAsync: 是否异步写出索引,默认false</p></li><li><p>journalMaxFileLength: 设置每个消息datalog大小,默认32MB</p></li><li><p>enableJournalDiskSyncs: 如果没有加事务,是否需要写入磁盘。JMS持久化时需要设置为false</p></li><li><p>cleanUpInterval: 清理过期消息,默认30000</p></li><li><p>archiveDataLogs: 对于需要删除的文件,不做删除,而是进行压缩。默认为false</p></li><li><p>directoryArchive: 压缩文件的存放位置</p></li></ol><h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><p>可以设置消息的过期时间,默认是永不过期。</p><h2 id="临时目的地"><a href="#临时目的地" class="headerlink" title="临时目的地"></a>临时目的地</h2><p>jms session可以创建临时的queue或者topic,当创建临时目的地的连接断开,临时目的地也就删除。只有创建临时目的地连接的消费者才可以消费这里的信息。</p><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>在JMS客户端中,可以使用本地事务来组合消息的接收和发送,最后使用commit提交或者使用rollback进行回滚。事务提交表示发送者的消息都已经发送,消费者消息都已确认。事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交。</p><p>需要注意的是,如果业务是一个请求/回复模式,发送一个消息,同时希望在事务中等待消息的回复,那么程序会被挂起,因为直到事务提交,发送操作才会真正执行。</p><p>消息的生产和消费不能再同一个事务中。</p><h2 id="消息模型-PTP"><a href="#消息模型-PTP" class="headerlink" title="消息模型-PTP"></a>消息模型-PTP</h2><p>PTP就是一种点对点的模型,一个消费者一个生产者,是一种单播模式。</p><p>当session关闭时,如果有一些消息已经收到,但还没有签收,那么当客户端再次连接上时,这些消息还会被再次接收。</p><p>如果消费端设置了选择器,那么不符合条件的消息会留在队列中,不会被接收。</p><p>队列可以持久保存消息知道消费端收到消息,充分体现异步传输的优势</p><h2 id="消息模型-pub-sub"><a href="#消息模型-pub-sub" class="headerlink" title="消息模型-pub/sub"></a>消息模型-pub/sub</h2><p>发布订阅模式,生产者制定一个主题,多个消费端可以订阅这个主题来收到消息,是一种广播模式。</p><ol><li><p>消息订阅分为持久订阅和非持久订阅:非持久订阅当客户端处于非激活状态时,消息将会消失,永远不能接收到。<br>持久模式则是消费端向JMS注册自身,当消费端宕机,broker会保存这个主题的消息,当消费端上线时,可以得到离线时漏掉的消息。</p></li><li><p>非持久模式下不能重新派送一个未签收的消息,所以需要设置为持久化模式。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JMS(1)-消息基础</title>
      <link href="/2018/12/06/jms-%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2018/12/06/jms-%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>JMS即java message service,是一个java面向消息中间件提出的标准化接口。类似于jdbc于mysql-connector的关系。ActiveMQ是apache出的一个消息中间件,实现了JMS协议。目前AMQ的版本为5.x,社区不太活跃,因为AMQ目前的主要精力投入在下一代MQ的开发-appllo上。</p><p>常见MQ的选型,供参考:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxz85ye41hj30py0nqq66.jpg" alt=""></p><h2 id="JMS消息结构"><a href="#JMS消息结构" class="headerlink" title="JMS消息结构"></a>JMS消息结构</h2><p>JMS消息由以下部分组成: 消息头 消息体 属性</p><p>消息头包含识别信息和路由信息:</p><ol><li>JMSDestatination: 路由地址,由sender设置</li><li>JMSDeliveryMode: 传送模式。两种: 持久模式和非持久化模式,持久模式消息会被传送”仅仅一次”。也就是说当broker宕机,消息不会丢失,当broker恢复后会再次发送消息。非持久消息保证传输最多一次,当机器宕机,数据将永远消失。</li><li>JMSExpiration: 消息过期时间,消息在过期时间内没有被消费,则会删除。</li><li>JMSPriority: 消息优先级,从0-9,0-4是普通消息,5-9是加急消息。JMS提供的保障的是加急消息先于普通消息送达,其他尽量保证,默认为4</li><li>JMSMessageID: 每个消息的唯一识别,可以手动设置为业务id,否则会自动生成。</li><li>JMSCorrelationID: 用来连接到另外一个消息,典型的应用是将回复消息链接到原消息,也就是有应答的场景。</li><li>JMSReplyTo: 提供本消息回复消息的目的地址</li><li>JMSType: 消息类型识别符</li><li>JMSRedelivered: 如果客户端收到一个设置了JMSRedelivered属性的消息,表示客户端之前接受过这个消息,但是没有ack。如果触发了消息重新发送,JMSRedelivered=true,否则false。</li></ol><p>JMS消息体提供了5种消息体:</p><ul><li>TextMessage</li><li>MapMessage</li><li>BytesMessage</li><li>StreamMessage</li><li>ObjectMessage</li></ul><p>JMS提供三种消息属性:</p><ol><li>应用程序添加的属性: Message.setStringProperty(k,v)</li><li>JMS定义的属性: connection.getMetaData().getJMSXPropertyNames() 获取jms定义的属性</li><li>三方插件提供的特殊属性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>k8s学习总结5-调度</title>
      <link href="/2018/12/05/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%935-%E8%B0%83%E5%BA%A6/"/>
      <url>/2018/12/05/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%935-%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>K8S调度器的主要任务就是为Pod寻找一个合适的Node。</p><h2 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h2><p>K8S提供了默认调度器,它的主要流程是:根据Predicate算法检查每个Node。然后再调用Priority算法给Node打分。最终调度结果就是选择分数最高的那个Node。</p><p>K8S调度算法的流程如下:</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxvz4mqinzj312u0nowfp.jpg" alt=""></p><p>主要是两个循环过程:</p><p>第一个循环informer负责监听etcd中Pod、Node、Service等需要调度的组件。一旦发现informer就将它放入一个优先级队列。</p><p>第二个循环是Scheduling Path,不断从优先队列中取出一个Pod,使用Predicate算法过滤出一组Node,Node的信息从Cache中获取。选出一个合适的Node之后,调度器就会进行绑定操作,将Pod的nodeName填写为筛选出的Node名称。</p><h2 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h2><p>K8S中Predicates算法默认提供四种调度策略:</p><h3 id="GeneralPredicates"><a href="#GeneralPredicates" class="headerlink" title="GeneralPredicates"></a>GeneralPredicates</h3><p>这是第一组过滤策略,也是最基础的调度规则。目的就是根据yaml配置文件检查硬件资源是否充足,端口是否冲突。由于调度策略采用了无锁化设计,所以当一个Pod被调度到Node上时,Node会再次执行一遍这个策略。</p><h3 id="Volume相关过滤"><a href="#Volume相关过滤" class="headerlink" title="Volume相关过滤"></a>Volume相关过滤</h3><p>这组规则主要对Volume进行过滤。</p><p>首先是NoDiskconflict,检查Pod声明挂载的volume是否存在冲突。</p><p>接着是MaxPDVolumeCountPredicate,判断节点某种volume类型是否超过上限。</p><p>接着是VolumeBindingPredicate,主要作用是判断节点亲和性。</p><h3 id="宿主机相关过滤规则"><a href="#宿主机相关过滤规则" class="headerlink" title="宿主机相关过滤规则"></a>宿主机相关过滤规则</h3><p>这组规则是判断Pod是否满足Node的某些条件。</p><p>例如配置了PodToleratesNodeTaints字段,只有当Pod的Toleration和Node的taint字段相匹配,才能调度到该节点。</p><h3 id="Pod相关过滤规则"><a href="#Pod相关过滤规则" class="headerlink" title="Pod相关过滤规则"></a>Pod相关过滤规则</h3><p>这组检查和GeneralPredicates有很多重合,比较特殊的一点是PodAffinityPredicate。用来检查Node上Pod之间的亲密和反亲密关系。</p><p>上面这四种类型的 Predicates，就构成了调度器确定一个Node可以运行待调度Pod的基本策略。</p><h2 id="Priorites"><a href="#Priorites" class="headerlink" title="Priorites"></a>Priorites</h2><p>Proorites根据算法对选出的Node打分,最常用的是LeastRequestedPriority</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score = (cpu((capacity-sum(requested))10/capacity) + memory((capacity-sum(requested))10/capacity))/2</div></pre></td></tr></table></figure><p>其实就是选择内存和CPU最多的主机,除此之外还有NodeAffinityPriority,TaintTolerationPriority以及InterPodAffinityPriority。</p><h2 id="优先级与抢占机制"><a href="#优先级与抢占机制" class="headerlink" title="优先级与抢占机制"></a>优先级与抢占机制</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>首先要明确的是,优先级与抢占解决的是Pod调度失败的问题。</p><p>通常情况下,调度失败的Pod会被搁置,直到出现满足条件的Node才能再次调度。但是如果这个Pod是一个优先级非常高的系统,我们希望能通过减少一部分优先度低的Pod,给优先级高的Pod空出位置。</p><p>在K8S 1.10版本提供了优先级与抢占机制,首先要定义一个PriorityClass类型的yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: scheduling.k8s.io/v1beta1</div><div class="line">kind: PriorityClass</div><div class="line">metadata:</div><div class="line">  name: high-priority</div><div class="line">value: 1000000</div><div class="line">globalDefault: false</div><div class="line">description: &quot;This priority class should be used for high priority service pods only.&quot;</div></pre></td></tr></table></figure><p>这里定义了优先级为1000000的配置文件,globalDefault如果设置为true,就会将Pod的默认优先级定义为1000000,而实际默认是0。优先级最大为10亿,超过10亿为K8S内部的Pod。</p><p>定义过后就可以在Pod中使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: nginx</div><div class="line">  labels:</div><div class="line">    env: test</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - name: nginx</div><div class="line">    image: nginx</div><div class="line">    imagePullPolicy: IfNotPresent</div><div class="line">  priorityClassName: high-priority</div></pre></td></tr></table></figure><p>经过配置之后,调度队列就会将这个Pod就会比优先级低的Pod提前出队。</p><h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>抢占机制相比优先级要复杂的多。当一个高优先级的Pod调度失败之后,就会触发抢占机制。抢占的大概过程如下:</p><p>k8s选出优先级较低的Pod所在的Node节点,将抢占者的spec.nominatedNodeName填写为该Node,然后将该pod重新入队。如果在下个周期,这个Pod没有抢到node(出现了优先级更高的pod),将spec.nominatedNodeName去掉重新入队,如果抢占成功,则让被抢占节点优雅退出(delete api),将新pod部署。</p><p>接下来讲述一下详细原理,我们将这个Pod称为抢占者,旧的节点称为牺牲者:</p><p>抢占的重要设计就是在调度队列的实现里,实现了两个不同的队列。</p><ol><li><p>activeQ: 存放下个周期需要调度的Pod</p></li><li><p>unschedulableQ: 用于存放调度失败的Pod,当这个队列中的Pod被更新时,k8s将它重新放入activeq。</p></li></ol><p>在这里发生调度失败,也就是节点入队时会去触发寻找牺牲者的流程。</p><p>首先调度器检查这次调度失败的原因,用来确认抢占机制可以实现重新调度。</p><p>如果抢占可以发生,调度器将缓存的所有节点信息复制一份,然后利用副本去模拟一遍抢占过程。</p><p>模拟成功之后会选出一个最佳Node,接着调度器就会开始真正的抢占操作:</p><p>首先检查牺牲者列表,清理Pod的spec.nominatedNodeName字段</p><p>为抢占者设置spec.nominatedNodeName属性</p><p>开启协程,删除旧Pod,完成抢占</p>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql之日志模块</title>
      <link href="/2018/12/04/mysql%E4%B9%8Bredo-log%E5%92%8Cundo-log/"/>
      <url>/2018/12/04/mysql%E4%B9%8Bredo-log%E5%92%8Cundo-log/</url>
      
        <content type="html"><![CDATA[<p>平时在看一些mysql的文章时,不可避免看到过undolog,redolog,binlog等xxlog概念,这些概念都属于mysql的日志模块,这里对这些概念做一次总结。</p><h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>redolog也叫重做日志,是innodb特有的一种log,用于保证事务的持久性。在事务提交时,必须将该事务所有事务日志写到磁盘的redologfile 和 undologfile上。</p><p>我们知道mysql的数据会持久化到磁盘上,但是如果每次进行更新都写磁盘。磁盘要进行io操作找到这条记录并更改,成本很高。因此mysql就是用了redolog来提升效率。</p><p>具体来说,当有一条记录更新时,Innodb将数据循环写到redolog中,更新内存。当数据库空闲时或者redolog满,就会异步刷写到磁盘上。这种基于WAL(预写日志)的存储,都是crash-safe的,因为mysql可以通过redolog在crash之后恢复数据。redo log是在事务开始之后就开始逐步写入磁盘。</p><p>关于redolog比较重要的一个参数是innodb_flush_log_at_trx_commit</p><ul><li><p>innodb_flush_log_at_trx_commit=1,每次commit都会将日志从redo log buffer(用户空间)写到system buffer(内核空间),并fsync刷新到磁盘文件中。</p></li><li><p>innodb_flush_log_at_trx_commit=2,每次commit都会将日志从redo log buffer(用户空间)写到system buffer(内核空间),由系统决定什么时候fsync到磁盘。如果这时服务器宕机,则会丢失这部分数据。</p></li><li><p>innodb_flush_log_at_trx_commit=0,mysql每秒从redo log buffer,把数据写入到系统中去。数据库宕机则丢失一秒内的数据。</p></li></ul><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog是mysql服务器级别的日志,也叫做归档日志,二进制日志。这是因为innodb并不是mysql原生的引擎,binlog只能用于归档,并没有提供crash-safe能力。</p><p>binlog在事务提交的时候产生,将事务中的语句按照一定的格式记录到binlog中。这里binlog的功能与redolog有些类似,但是精度也就是可靠性明显不同,redolog作用于事务层面,而binlog则主要用来做数据库备份,同步。另一个区别在于redolog是循环写的,不提供持久保存,而binlog提供归档的功能。</p><p>binlog有两种模式:row和statement:statement记录的是sql语句,row模式记录变更前后的内容,会记录两条。因此row模式更安全,但是会是log变大。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>由于redo log和binlog都会记录事务,那么这就对binlog和redolog的提交有要求。如果binlog和redolog的记录不一致,那么就会出现事务不一致的状况,这常常发生在主从复制的环境下。</p><p>MySQL通过两阶段提交过程来完成事务的一致性的,也即redo log和binlog的一致性的,先写redo log,处于prepare状态,再写binlog,写成功后进入commit状态。两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p><h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2><p>undolog也叫回滚日志,保存了事务发生之前数据的版本,可以用来回滚,并提供MVCC。</p><p>当我们对数据进行更新操作就会产生undolog,可以把undolog可以理解为一个链表,保存了一个字段连续变化的过程。当我们进行修改时,会将数据备份到undolog,并在undlog中进行修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。undolog正式凭借此保证事务的原子性。</p><p>undolog另一个重要作用就是并发读写时支持mvcc(多版本并发控制)机制。当一行数据被写操作锁定时,读操作可以根据事务号到undolog中找到合适版本的数据,而不会写锁阻塞读操作,这就是一致性视图。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm学习笔记-重载与重写</title>
      <link href="/2018/11/29/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/"/>
      <url>/2018/11/29/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重载与重写是java中相当重要的一组概念,java利用重载和重写实现了多态,看下面一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">void invoke(Object obj, Object... args) &#123; ... &#125;</div><div class="line">void invoke(String s, Object obj, Object... args) &#123; ... &#125;</div><div class="line"></div><div class="line">invoke(null, 1);    // 调用第二个 invoke 方法</div><div class="line">invoke(null, 1, 2); // 调用第二个 invoke 方法</div></pre></td></tr></table></figure><p>在java中,如果一个类中存在相同名字的函数,并且参数也相同,那么它是无法通过编译的。那么就需要修改参数类型让他们不同,这种方法之间的关系,就是重载。</p><p>重载的方法在编译阶段就可以识别,有以下几个原则:</p><ol><li>首先在不进行自动装箱/拆箱的情况下调用方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void test(int i )&#123;</div><div class="line">    System.out.println(&quot;test int&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public void test(Integer i)&#123;</div><div class="line">    System.out.println(&quot;test integer&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    Rich r = new Rich();</div><div class="line">    r.test(1);  // 执行第一个</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>在1不匹配的情况下,允许自动拆箱装箱,不优先选择带有可变长参数方法:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void test(int i,String hello)&#123;</div><div class="line">    System.out.println(&quot;test int&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public void test(Integer i,String ... hellos)&#123;</div><div class="line">    System.out.println(&quot;test integer&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    Rich r = new Rich();</div><div class="line">    r.test(1,&quot;1&quot;); //执行第一个</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>在2不匹配的情况下,允许自动装箱拆箱/允许可变长参数</li></ol><p>除了同一个类中的方法,重载也可以作用于父类与子类之间,如果子类定义了与父类方法名称相同而参数类型不同,那么这两个方法也构成了重载。</p><p>那么如果子类定义了与父类非私有方法同名的方法,并且参数类型也相同,那么这时子类重写了父类的方法。方法的重写,正是多态的一种重要体现方式,它允许子类继承父类部分功能的同时,拥有自己独特的行为。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="jvm静态绑定与动态绑定"><a href="#jvm静态绑定与动态绑定" class="headerlink" title="jvm静态绑定与动态绑定"></a>jvm静态绑定与动态绑定</h2><p>jvm标识一个方法的依据是类名+方法名+方法描述符,方法描述符就是参数类型和返回类型构成。<br>对于方法冲突的情况,jvm会在验证阶段报错。</p><p>对于重载方法的区分,在java编译时期就可以区分,因此重载也叫做静态绑定,或者编译时多态。<br>而重写方法是在运行时确定的,所以也叫做动态绑定或者运行时多态。</p><p>当然上面的说法在某些情况下就不太严谨,例如某个类中的重载方法被它的子类重写,那么jvm就会将这个方法编译为动态绑定的类型。</p><p>更准确的说,jvm的静态绑定指的是在解析时能够直接识别目标的情况,而动态绑定则是依据运行时调用者的动态类型来识别目标的情况。</p><h2 id="重写方法-桥接"><a href="#重写方法-桥接" class="headerlink" title="重写方法-桥接"></a>重写方法-桥接</h2><p>对于方法重写,jvm与java的判断条件是不同的。对于java来说,只要方法的名称和参数名称相同,则构成重写。<br>而对于jvm来说,不同的返回值所构成的方法描述符是不同的,所以对于jvm来说并没有构成重写。举个栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Merchant &#123;</div><div class="line">    public Number actionPrice(double price) &#123;</div><div class="line">        return price * 0.8;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class NaiveMerchant extends Merchant &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Double actionPrice(double price) &#123;</div><div class="line">        return 0.9 * price;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Merchant merchant = new NaiveMerchant();</div><div class="line">        // price 必须定义成 Number 类型 </div><div class="line">        Number price = merchant.actionPrice(40);</div><div class="line">        System.out.println(price);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在上面的代码中,父类与子类的返回类型是不同的,java对其判断为重写方法,那么这时jvm如何处理呢,因为jvm只有当方法的方法描述也相同才判断为重写方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">javac Merchant.java NaiveMerchant.java</div><div class="line"></div><div class="line">javap -v NaiveMerchant</div></pre></td></tr></table></figure><p>我们通过反编译查看字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> public java.lang.Double actionPrice(double);</div><div class="line">    descriptor: (D)Ljava/lang/Double;</div><div class="line">    flags: ACC_PUBLIC</div><div class="line">    Code:</div><div class="line">      stack=4, locals=3, args_size=2</div><div class="line">         0: dload_1</div><div class="line">         1: ldc2_w        #2                  // double 0.9d</div><div class="line">         4: dmul</div><div class="line">         5: invokestatic  #4                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;</div><div class="line">         8: areturn</div><div class="line">      LineNumberTable:</div><div class="line">        line 13: 0</div><div class="line"></div><div class="line">// 桥接方法         </div><div class="line">public java.lang.Number actionPrice(double);</div><div class="line">    descriptor: (D)Ljava/lang/Number;</div><div class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</div><div class="line">    Code:</div><div class="line">      stack=3, locals=3, args_size=2</div><div class="line">         0: aload_0</div><div class="line">         1: dload_1</div><div class="line">         2: invokevirtual #12                 // Method actionPrice:(D)Ljava/lang/Double;</div><div class="line">         5: areturn</div><div class="line">      LineNumberTable:</div><div class="line">        line 9: 0</div></pre></td></tr></table></figure><p>可以看到这里生成了两个方法,第二个方法的flags描述为ACC_BRIDGE,为了保持重写的语义，Java 编译器会在 NaiveMerchant 的字节码文件中自动生成一个桥接方法来保证重写语义。<br>当子类在继承父类的一个泛型方法、或子类实现一个接口的泛型方法,编译器也会在子类的 class 文件中自动生成桥接方法。</p><h2 id="调用相关指令"><a href="#调用相关指令" class="headerlink" title="调用相关指令"></a>调用相关指令</h2><p>java字节码中与调用相关的指令共有5种:</p><ul><li>invokestatic      调用静态方法(static)</li><li>invokedynamic     调用动态方法</li><li>invokevirtual     调用非私有实例方法</li><li>invokespecial     调用私有实例方法,构造器,super,实现接口的默认方法</li><li>invokeinterface   调用接口</li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>在编译的过程中,并不知道方法的具体内存地址。因此编译器会暂时使用一个符号引用来表示该方法。符号引用存储在class文件的常量池中,上面字节码中#12 #4就表示符号引用,常量池会显示在class文件的头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Constant pool:</div><div class="line">   #1 = Methodref          #12.#28        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">   #2 = Fieldref           #29.#30        // java/lang/System.out:Ljava/io/PrintStream;</div><div class="line">   #3 = String             #31            // action 1</div><div class="line">   #4 = Methodref          #32.#33        // java/io/PrintStream.println:(Ljava/lang/String;)V</div><div class="line">   #5 = InvokeDynamic      #0:#37         // #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</div><div class="line">   #6 = String             #38            // test int</div><div class="line">...</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm学习笔记-类加载</title>
      <link href="/2018/11/27/%E8%A1%A8%E9%9D%A2%E7%90%86%E8%A7%A3jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/11/27/%E8%A1%A8%E9%9D%A2%E7%90%86%E8%A7%A3jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h2><blockquote><p>当我们写好.java程序点击运行的时候发生了什么</p></blockquote><ol><li>当我们写好.java的源程序，使用javac命令把源程序编译成.class文件，编译后的.class文件(类字节码文件)包括以下内容:</li></ol><ul><li>以魔数Magic Number:0xCafeBabe开头</li><li>ConstantPool:符号表</li><li>FieldInfo:类成员变量表</li><li>方法描述</li><li>附加节点</li><li>…</li></ul><ol><li><p>有了.class文件我们就可以执行java命令运行java程序</p></li><li><p>首先JVM装载.class，也就是类加载器加载字节码。但是类加载器本身也是一个java类，所以它也需要被加载，幸运的是有一个类加载器是用c++编写的，叫做<code>Bootstrap类加载器</code>，属于虚拟机内核，用特定于操作系统的本地代码实现。Bootstrap类加载器负责加载javajava核心包中的类(rt.jar)，这些类的Class.getClassLoader()方法返回值会null，表示需要Bootstrap加载器来加载。JAVA核心包中还有两个类加载器:<code>ExtClassLoader</code>和<code>ApplicationClassLoader</code>。他们都用java语言编写，其中ExtClassLoader负责加载<java_home>/jre/lib/ext目录下的jar，ApplicationClassLoader负责加载应用程序的启动执行类，即当使用java命令去启动执行一个类时，JAVA虚拟机使用AppClassLoader加载这个类。所以这里有个小track就是把一些自己常用但是非java自带的jar放到ext目录下，这样就可以少写几个maven dependency。</java_home></p></li></ol><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="为什么要类加载器"><a href="#为什么要类加载器" class="headerlink" title="为什么要类加载器"></a>为什么要类加载器</h2><ol><li>java类加载都是在程序的运行期完成的</li><li>增加java程序的灵活性，例如：</li></ol><ul><li>面向接口的编程，在程序运行时才指定其具体的实现类。</li><li>用户自定义类加载器,支持程序从网络或者其他地方加载一个类。</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flrre3ma6nj30km0970t3.jpg" alt=""></p><ul><li>①的可控性最强，因为可以自定义类加载器</li><li>①②③⑤的顺序一定。但注意是开始顺序一定，并不保证按顺序完成。</li><li>④过程可能在⑤之后进行，为了支持java的运行时绑定</li></ul><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>我们知道java类型分为基本类型和引用类型,基本类型是jvm预先定义好的,引用类型包括类,接口,数组类,泛型参数。由于泛型参数在编译过程中会被擦除,数组类由jvm生成,所以只剩下类和接口才会有对应的字节流。</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li><li>将字节流转化元数据区的数据结构</li><li>在堆中生成这个类的对象，作为访问此类的入口</li></ol><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flrsg7pnfhj30k20dmmzx.jpg" alt="来源网络"></p><p>在jvm中有个规矩,任何一个类加载器拿到一个接收到加载请求,都要转交给父类加载器,如果父类加载器没有找到路径的情况下,子类加载器才会去加载。</p><ul><li><p>在JAVA9之前,类加载器的层级结构为: Bootstrap ClasssLoader(c) -&gt; extension ClassLoader -&gt; application ClassLoader</p></li><li><p>由于JAVA9引入了模块系统,将extension ClassLoader改为Platform ClassLoader。除了java.base由启动类加载器加载,其他都交给平台类加载器加载</p></li></ul><p>如果两个类相等，那么不光要class是相同的，而且需要类加载器相同。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol><li>验证: 确保符合jvm规范，没有安全问题</li><li>准备: 为类的静态字段分配内存。在这里static变量会被赋予一个默认初始值,而final修饰的则会直接赋予原值</li><li>解析: 将常量池内的引用符号替换为直接引用（可以理解为将原来的多级指针指向的最终地址替换指针）</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>将一个类中所有被static关键字标识的代码统一执行一遍，如果执行的是静态变量，那么就会使用用户指定的值覆盖之前在准备阶段设置的初始值.如果执行的是static代码块，那么在初始化阶段，JVM就会执行static代码块中定义的所有操作。</p><p>jvm并没有强制规定什么时候要进行加载，但是规定了五种有且只有的情况立即初始化类，当然在初始化之前要完成前面的几个步骤。</p><ol><li>new一个类的对象</li><li>调用类的静态成员（除了final常量）和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当虚拟机启动,加载main方法所在的类</li><li>当初始化一个类，如果其父类没有被初始化，则先初始化它父类</li></ol><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><blockquote><p>关于双亲委派模型的疑问？？？</p></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flrta4ovpij309v085dh2.jpg" alt=""></p><p>这个图相信大家都见到过，也就是双亲委派模型(Parents-Delegation-Model)的示意图。详细内容就不作介绍。一点疑问就是当我第一次学这个内容的时候我在考虑双亲的双体现在哪里呢？它只是向上面一级也就是父加载器传递，这个Parents体现的应该是垂直方向，也就是父亲，爷爷这种关系，而不是水平方向上的双亲关系。所以我认为这个模型不应该叫双亲委派模型，英文也应该是(Parent-Delegation-Model),我认为双亲这种说法很容易误导初学者。<br>在《Thinking in jvm》英文原本中印证了我的想法,如图。个人认为这种说法更准确。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flrtfhpw0aj30m8019jre.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红黑树</title>
      <link href="/2018/11/25/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2018/11/25/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="《算法导论》中的红黑树"><a href="#《算法导论》中的红黑树" class="headerlink" title="《算法导论》中的红黑树"></a>《算法导论》中的红黑树</h2><p>红黑树与AVL相似,都是对BST进行了一系列优化,防止退化成链表的现象。算法导论中对红黑树的定义如下</p><ol><li>每个节点要么是红色,要么是黑色</li><li>根节点必须黑色</li><li>每个叶子节点(空节点)也是黑色</li><li>红节点的孩子节点必须为黑色</li><li>任意节点到叶子节点,经过的黑色节点数量是相同的</li></ol><p>相信大多数人都看过这段关于RBT的描述,然后通过这段描述推导出更多的性质,然后就是一些列的旋转、染色代码,非常不友好。问题就在于我们通过上面的性质根本无法得知红黑树是怎么得来的,作者怎么发明这种算法的。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>事实上红黑树与2-3树是一种等价结构,但是2-3树更便于理解,因此我们从2-3树开始</p><p>首先2-3树满足BST的基本性质,每个节点可能是一个元素或两个元素,对于两个元素的节点,左边的元素小于右边的元素,如图所示:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxjg68p97jj31560i4n1o.jpg" alt=""></p><p>在这个2-3树种,42叫做2节点,17/33叫做3节点,由于2-3树插入数据的方式,保证了2-3树是一个绝对平衡的树,也就是从根节点到任意叶子节点,所经过的长度一定是相同的。</p><h2 id="2-3树如何保持平衡"><a href="#2-3树如何保持平衡" class="headerlink" title="2-3树如何保持平衡"></a>2-3树如何保持平衡</h2><p>当树中插入第一个节点42,这个节点就作为根节点,此时2-3树平衡</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxjgg9uneoj304g042dfy.jpg" alt=""></p><p>这时插入第二个节点37,如果是BST则会判断大小然后放到42的左子树上去。但是2-3树不会将节点添加到一个空的位置,而是和42融合为一个新的节点,放在42的左边,也就是找到最后一个叶子节点并融合,此时树依然平衡</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxjgkl0y55j308a04w0t5.jpg" alt=""></p><p>继续添加一个节点12,同理12融合到27的左边,暂时形成一个四节点。由于2-3树不允许存在4节点,那么此时就必须将这个4节点拆分,很容易就可以拆分成一个子树</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxjgmg1g8jj30b204ydgm.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxjgnsslcpj30km0ayt9z.jpg" alt=""></p><p>这时我们继续添加一个节点18,它将融合到12的右边,形成一个3节点,此时树依然绝对平衡</p><p>继续添加节点6,暂时会融合到12的左边,形成一个4节点,但这时如果再像第一次那样拆分,树的形式就不是绝对平衡了</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxjgqmlogdj30oo0awgng.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxjgs4j4rjj30ou0f8wgn.jpg" alt=""></p><p>那么这时候该怎么做呢,答案就是将12与37进行融合,形成一个三节点,这时树就保持绝对平衡了</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxjgt8qh9pj30k80a840k.jpg" alt=""></p><p>我们继续插入11,5。变化过程同理,首先形成一个二叉树,然后将6融合到父亲节点,形成一个暂时的四节点,继续将根节点进行拆分,则又得到了一个完全平衡的树</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxjgx4kqcgj30o80fg418.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxjgy698roj30qk0aq0vb.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxjgz6is4xj30p80h6tc4.jpg" alt=""></p><p>继续插入节点则可以根据上述的过程同理变换。</p><h2 id="2-3树与红黑树的等价性"><a href="#2-3树与红黑树的等价性" class="headerlink" title="2-3树与红黑树的等价性"></a>2-3树与红黑树的等价性</h2><p>在上面看到了2-3树的变换过程,其实红黑树的变换和2-3树是等价的。对于2-3树来说,包含两种节点,2节点和3节点。对于2节点,我们可以用一个普通的Node节点来表示。而对于3节点这种形式,由于一个Node只能放置一个元素,我们必须使用两个节点来表示3节点。而实际上这两个节点是一个同级的关系,并且本身应该属于同一个节点,所以这时我们可以对其中一个节点进行着色,一般是将左边较小的元素表示为红色。这时我们就可以通过一个红色节点和一个黑色节点将他们表示成2-3树种的3节点。这时我们就可以将一个2-3树映射成红黑树了。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxjh7t4lesj30iu0d0wfq.jpg" alt=""></p><p>这时我们将上面的2-3树描述成红黑树,相信这样一看,就可以理解为什么红黑树这样进行着色了。对照算法导论中的定义,可以发现每一条都符合</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxjhbs8l68j30tm0eadjj.jpg" alt=""></p><p>观察红黑树,可以发现,其实红黑树是一个保持”黑平衡”的二叉树,但是严格意义上来说,它并不是一个平衡二叉树,因为它的最大高度为2logn,也就是一红一黑相连续,由于常数不记,所以它的时间复杂度是logn。相比于avl来说,查找可能会更慢,虽然都是O(logn)级别的。但是红黑树的应用却更加广泛,因为对于删除元素和新增元素,红黑树要更快</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>k8s学习总结4-网络</title>
      <link href="/2018/11/12/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%934-%E7%BD%91%E7%BB%9C/"/>
      <url>/2018/11/12/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%934-%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>K8S的网络部分确实是一个难点,我在这里卡了很久也看了很多相关的文档。K8S的网络依赖于Docker,Docker的网络离不开linux内核的支持,所以要理解K8S的网络必须要了解linux网络知识。</p><h2 id="linux网络基础"><a href="#linux网络基础" class="headerlink" title="linux网络基础"></a>linux网络基础</h2><p>Docker使用到的linux技术主要包括下面几种:</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx59jhgk3cj307106xmwz.jpg" alt=""></p><p>linux通过命名空间(ns)可以将网络栈进行隔离,不同的ns完全隔离无法进行通信。Docker也正是利用了这种特性实现不同容器网络环境的隔离。那么如果我有需求需要让不同ns的进程进行通信,该怎么做呢?答案就是veth设备对。</p><p>Veth的重要作用就是打通网络栈之间的壁垒,就像一个通道,两端连着不同的网络栈,所以Veth必须成对出现。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx5a6gasdnj308y056wea.jpg" alt=""></p><p>Docker 服务启动后默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。linux网桥的作用就是绑定多个以太网设备,将他们桥接起来。网桥上层只需要将数据交给网桥,网桥负责决定是将数据转发到哪些以太网口。以太网口接收到的网络报文,同样只需要交给网桥,网桥负责判断是丢弃还是继续向上层提交。</p><p>假如用户需要对某些关心的数据进行一些操作,Iptable/Netfilter就提供了这种功能,通过在挂载点挂载钩子函数,可以对一些数据包进行过滤、修改、丢弃操作等。Netfilter提供了五个位置来作控制</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx5bbxfwxij30dk0dhdft.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.PREROUTING (路由前)</div><div class="line">2.INPUT (数据包流入口)</div><div class="line">3.FORWARD (转发管卡)</div><div class="line">4.OUTPUT(数据包出口)</div><div class="line">5.POSTROUTING（路由后）</div></pre></td></tr></table></figure><p>任何一个数据包，只要经过本机，必将经过这五个链中的其中一个链。接着又定义了表的概念用来管理这些链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">filter:定义允许与不允许</div><div class="line">manage: 修改数据报文</div><div class="line">nat: 网络地址转换</div></pre></td></tr></table></figure><p>对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT </p><p>对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING </p><p>而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</p><p>iptables是工作在用户控件提供管理这些规则的接口的工具,它的背后就是工作在内和空间的Netfilter。</p><h2 id="Docker网络模型"><a href="#Docker网络模型" class="headerlink" title="Docker网络模型"></a>Docker网络模型</h2><p>docker支持四种网络模式:</p><ul><li>host</li><li>container</li><li>none</li><li>bridge</li></ul><p>docker默认启用的是bridge类型,安装docker后会在宿主机上创建一个docker0网桥,当运行一个容器,veth就被会创建,一端连在docker0网桥上,另一端在宿主机内的eth0网桥上。这样就做到了同一主机上不同容器可以相互访问,但如果要通过其他ip访问这台机器的docker容器,就需要将宿主机上分配端口,将docker0的一个端口映射到宿主机端口上。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx5cclqoypj30ku09rt8z.jpg" alt=""></p><h2 id="Kubernates网络模型"><a href="#Kubernates网络模型" class="headerlink" title="Kubernates网络模型"></a>Kubernates网络模型</h2><p>K8S作为一种容器编排工具,主要解决一下场景中的问题:</p><ol><li>容器与容器之间的通信</li><li>Pod与Pod之间的通信</li><li>Pod与service之间的通信</li><li>集群内外的通信</li></ol><h3 id="容器与容器"><a href="#容器与容器" class="headerlink" title="容器与容器"></a>容器与容器</h3><p>由于Pod中的容器共享网络栈,所以容器之间可以使用localhost进行通信。</p><h3 id="Pod之间通信"><a href="#Pod之间通信" class="headerlink" title="Pod之间通信"></a>Pod之间通信</h3><p>Pod之间的通信可能存在于同一个Node上,也有可能存在于不同Node上。</p><hr><p>同一个Node上的Pod都是通过veth连接到宿主机的docker0网桥,他们的Ip都是从docker0上动态获取并且和docker0 ip属于同一个网段。</p><hr><p>Pod的地址与docker0在同一个网段,docker0与宿主机eth0属于两个不同的网段,Node之间的通信依赖于宿主机的网卡。所以不同Node的Pod想要通信,首先要找到Node对应的宿主机Ip,将数据包发送到宿主机网卡上,然后在转发给docker0,最后再到达目标Pod。</p><p>这部分的实现通常都是依赖一些网络配置工具来完成,例如flannel,后面再详细介绍。</p><h3 id="Pod与Service"><a href="#Pod与Service" class="headerlink" title="Pod与Service"></a>Pod与Service</h3><p>kubernetes创建服务时，会为服务分配一个虚拟的IP地址，即为ClusterIP，客户端通过访问这</p><p>个虚拟IP地址来访问内部组件。实质上具体访问内部的工作都是kube-proxy来完成的。kube-</p><p>proxy担负着透明代理和负载均衡的角色，其实就是将某个访问service的请求，通过一套算法</p><p>和规则转发给后端的pod，这里说的算法就是Round Robin负载均衡算法和session粘连规则。</p><p>我们还可以通过修改service里面的service.spec.sessionAffinity参数的值来实现会话保持特</p><p>的定向转发。</p><p>总之，不管是clusterIP+targetPort，还是节点IP+NodePort，都会被Iptables规则重新定向到</p><p>kube-proxy监听服务的代理端口。</p><h3 id="集群内外通信"><a href="#集群内外通信" class="headerlink" title="集群内外通信"></a>集群内外通信</h3><ol><li>NodeIP+NodePort</li></ol><p>这种方式就是在宿主机上开放一个端口,供外部访问</p><ol><li>Ingress</li></ol><p>Ingress 可以给 service 提供集群外部访问的 URL、负载均衡、SSL 终止、HTTP 路由等。为了配置这些 Ingress 规则，集群管理员需要部署一个 Ingress controller，它监听 Ingress 和 service 的变化，并根据规则配置负载均衡并提供访问入口。典型的就是Nginx Ingress。</p><ol><li>loadbalance</li></ol>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>k8s学习总结3-存储</title>
      <link href="/2018/11/12/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%933-%E5%AD%98%E5%82%A8/"/>
      <url>/2018/11/12/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%933-%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="PV-PVC-StorageClass"><a href="#PV-PVC-StorageClass" class="headerlink" title="PV PVC StorageClass"></a>PV PVC StorageClass</h2><p>容器化一个应用最麻烦的地方,莫过于对其状态的管理,而最常见的状态就是存储状态。K8s提出了PV和PVC这样的概念,来方便开发人员对存储状态进行管理</p><h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><p>PV文件描述的是一个持久化存储卷,例如一个Ceph文件系统,一个云盘等等,主要信息就是声明了访问方式以及存储容量的大小,主要由运维人员来维护,开发人员无需关心存储的具体细节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: PersistentVolume</div><div class="line">metadata:</div><div class="line">  name: nfs</div><div class="line">spec:</div><div class="line">  storageClassName: manual</div><div class="line">  capacity:</div><div class="line">    storage: 1Gi</div><div class="line">  accessModes:</div><div class="line">    - ReadWriteMany</div><div class="line">  nfs:</div><div class="line">    server: 10.244.1.4</div><div class="line">    path: &quot;/&quot;</div></pre></td></tr></table></figure><h3 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h3><p>PVC描述的是Pod所希望持久化存储的属性,例如所需磁盘的大小,可读写的权限等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: PersistentVolumeClaim</div><div class="line">metadata:</div><div class="line">  name: nfs</div><div class="line">spec:</div><div class="line">  accessModes:</div><div class="line">    - ReadWriteMany</div><div class="line">  storageClassName: manual</div><div class="line">  resources:</div><div class="line">    requests:</div><div class="line">      storage: 1Gi</div></pre></td></tr></table></figure><p>这里PVC真正能够使用起来,必须要同一个PV进行绑定,这里包括两部分检查:</p><ol><li>PV的存储空间大于等于PVC所声明的</li><li>PV与PVC的storageClassName必须相同</li></ol><p>当PV与PVC进行绑定之后,我们就可以在yaml里使用这个存储了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  labels:</div><div class="line">    role: web-frontend</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - name: web</div><div class="line">    image: nginx</div><div class="line">    ports:</div><div class="line">      - name: web</div><div class="line">        containerPort: 80</div><div class="line">    volumeMounts:</div><div class="line">        - name: nfs</div><div class="line">          mountPath: &quot;/usr/share/nginx/html&quot;</div><div class="line">  volumes:</div><div class="line">  - name: nfs</div><div class="line">    persistentVolumeClaim:</div><div class="line">      claimName: nfs</div></pre></td></tr></table></figure><h3 id="PV与PVC"><a href="#PV与PVC" class="headerlink" title="PV与PVC"></a>PV与PVC</h3><p>PV与PVC是如何做到持久化呢?我们知道Docker的volume机制就是将宿主机上的一个目录与容器里的目录绑定挂在到一起。而对于K8s这种分布式的系统来说,数据的持久化一定不能落在本地盘上,因为这样不具备分布式的特性,会引起单点的故障,所以hostPath和enptyDir是不行的。所以大多数情况下,持久化volume的实现依赖于一个远程存储服务，如NFS。</p><p>K8S所需要做的就是将这个远程存储服务与容器的本地目录进行绑定,这个过程分为两步:</p><ol><li>Attach:连接到远程的存储服务</li><li>Mount: 将磁盘设备格式化并挂载到宿主机目录</li></ol><p>经过这两个阶段的处理,我们就得到了一个持久化的volume宿主机目录,然后通过-v 就可以为Pod里的容器挂在这个持久化volume了,这就是K8s处理PV的过程。</p><p>可以看到PV与PVC的关系就像JAVA中的接口与实现类,这样做的好出就是实现了解耦，与面向对象的思想一致。但是这样的方式也引入了一些困难:因为PV一般都是运维人员进行编写的,如果开发声明了一个PVC但是无法绑定PV,那么Pod就会创建失败,当K8s集群大到一定规模时,这种方式一定会成为一种灾难。</p><h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><p>由于PV与PVC带来的这种问题,我们很自然的就希望能够提供一个自动创建PV的机制,这就是dynamic provisioning,相比于人工管理PV的方式就叫做static provisioning。</p><p>dynamic provisioning机制的核心就是StorageClass对象,即创建一个PV的模板。一般来说一个StorageClass会定义两部分内容:</p><ol><li>PV的属性,如存储类型,大小</li><li>创建这种PV所需要的插件,如ceph,nfs</li></ol><p>有了这个模板,K8S就能根据用户提交的PVC,找到一个对应的storageClass,然后调用storageClass所声明的插件,创建出PV。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: storage.k8s.io/v1</div><div class="line">kind: StorageClass</div><div class="line">metadata:</div><div class="line">  name: block-service</div><div class="line">provisioner: kubernetes.io/gce-pd</div><div class="line">parameters:</div><div class="line">  type: pd-ssd</div></pre></td></tr></table></figure><p>而作为开发者,我们就只需要在yaml中指定需要使用的storageClass就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: PersistentVolumeClaim</div><div class="line">metadata:</div><div class="line">  name: claim1</div><div class="line">spec:</div><div class="line">  accessModes:</div><div class="line">    - ReadWriteOnce</div><div class="line">  storageClassName: block-service</div><div class="line">  resources:</div><div class="line">    requests:</div><div class="line">      storage: 30Gi</div></pre></td></tr></table></figure><h2 id="本地持久化"><a href="#本地持久化" class="headerlink" title="本地持久化"></a>本地持久化</h2><p>虽然K8S内置了20中持久化实现方式,但是并没有提供本地的持久化存储方式。但是依然有很多用户希望能够直接使用宿主机上的本地磁盘目录,而不依赖远程的存储服务。这样做好出也很明显,Volume直接使用本地磁盘,IO性能会好很多。所以在1.10版本之后,K8S依靠PV/PVC实现了这个特性,即Local Persistent Volume。</p><p>首先本地持久卷并不适用于所有应用,并且相对于其他PV,一旦这些节点宕机,那么数据就会丢失,这就要求使用Local Persistent Volume的节点必须具有备份和回复能力。</p><h3 id="难点1"><a href="#难点1" class="headerlink" title="难点1"></a>难点1</h3><p>Local Persistent Volume并不等于hostPath+nodeAffinity。实际上并不应该把宿主机上的一个目录当做PV来使用,因为本地目录的存储完全不可控,随时都有可能被写满,其次缺少最基础IO隔离机制。所以一个Local Persistent Volume应该等于一块额外挂载到宿主机的磁盘,也就是一个PV一块盘。</p><h3 id="难点2"><a href="#难点2" class="headerlink" title="难点2"></a>难点2</h3><p>调度器如何保证Pod始终能被正确的调度到他所请求的Local Persistent Volume所在的节点。对于local PV来说,每个节点挂载情况可能完全不同,有的节点甚至没有挂载,那么K8s就需要维护这种关系,才能调度Pod,也就是在调度的时候考虑volume分布。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先需要手动在node上挂载磁盘,例如/mnt/disks</p><p>接着定义PV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: PersistentVolume</div><div class="line">metadata:</div><div class="line">  name: example-pv</div><div class="line">spec:</div><div class="line">  capacity:</div><div class="line">    storage: 5Gi</div><div class="line">  volumeMode: Filesystem</div><div class="line">  accessModes:</div><div class="line">  - ReadWriteOnce</div><div class="line">  persistentVolumeReclaimPolicy: Delete</div><div class="line">  storageClassName: local-storage</div><div class="line">  local:</div><div class="line">    path: /mnt/disks/vol1</div><div class="line">  nodeAffinity:</div><div class="line">    required:</div><div class="line">      nodeSelectorTerms:</div><div class="line">      - matchExpressions:</div><div class="line">        - key: kubernetes.io/hostname</div><div class="line">          operator: In</div><div class="line">          values:</div><div class="line">          - node-1</div></pre></td></tr></table></figure><p>可以看到这个PV定义了lcoal字段并且指定了路径.如果Pod要使用这个PV<br>那么就必须运行在这个node-1节点上,所以指定了nodeAffinity。</p><p>接着定义一个StorageClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">kind: StorageClass</div><div class="line">apiVersion: storage.k8s.io/v1</div><div class="line">metadata:</div><div class="line">  name: local-storage</div><div class="line">provisioner: kubernetes.io/no-provisioner</div><div class="line">volumeBindingMode: WaitForFirstConsumer</div></pre></td></tr></table></figure><p>这里需要注意local pv目前不支持动态创建,所以需要指定为no-provisioner。所以创建PV的过程是不可以省略的。</p><p>volumeBindingMode=WaitForFirstConsumer属性也非常重要,这是一种延迟绑定的机制,这种绑定会在调度的时候才去绑定,否则就会引起Pod调度的失败。</p><p>接着我们就可以编写一个普通的PVC来使用这个local pv了,这就类似于面向对象的设计,我们只需要修改接口的实现类,就可以动态修改类的表现。</p>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>k8s学习总结-2</title>
      <link href="/2018/11/10/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932-Pod/"/>
      <url>/2018/11/10/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%932-Pod/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么我们需要Pod"><a href="#为什么我们需要Pod" class="headerlink" title="为什么我们需要Pod"></a>为什么我们需要Pod</h2><p>关于docker容器,我们都知道它的技术原理就是Namespace做隔离,cgroups做限制,rootfs做文件系统,那么k8s为什么又提出了Pod这个概念呢。</p><p>我们可以这样理解,容器就是一个特殊的进程,而k8s就类似于操作系统,去调度管理这些特殊的进程,那么k8s就可以比做操作系统。我们知道,在真正的操作系统中,进程并不是孤单的运行,它存在于一个进程组之中,被操作系统有规则的组织在一起。</p><p>那么我们可以理解Pod其实就是将操作系统中进程组的概念抽象到了K8s中,因为k8s的设计脱身于borg系统,谷歌的开发者们发现,他们部署的应用,往往都存在进程与进程组的关系,这些应用密切协作,必须部署在一台机器上。而如果没有组这个概念,这种组织关系就难以维护,而Pod就是将操作系统中的进程组的概念映射到了容器中。</p><p>关于Pod的一个事实是,Pod只是一个逻辑概念,Pod里的容器共享网络栈并且可以声明共享同一个Volume。</p><p>Pod的设计降低了调度的复杂度,考虑这样一种场景:A/B/C三个容器必须要部署在一起,各需要1G内存。现在node1有3G内存,node2有2.5G内存。若A首先初始化,部署到了node2上,那么轮到C就不满足硬件条件而部署失败。那么就必须要将AB两个容器回滚,重新部署到node1上。</p><p>这就是一个典型的成组调度没有被妥善处理的例子,虽然有很多可供选择的方案,但谈不上完美,要么造成资源的严重浪费,要么技术难度不是常规团队可以驾驭。而加入了Pod这种概念,Pod是K8s调度的原子单位,调度器是按照Pod的需求而不是容器的需求来进行计算的。根据这种调度方式,上述的例子就会选择node1而不会选择node2进行调度。</p><p>Pod除了简化调度模型,还有个更重要的意义就是容器设计模式。</p><p>首先要弄清楚Pod的实现原理,Pod的实现需要一个中间容器,叫做infra容器(k8s.gcr.io/pause)。在Pod中,infra会首先被创建,其他容器都是通过join network namespace的方式与infra容器关联在一起。因此对于一个pod中的A B两个容器来说:</p><ul><li>可以使用localhost进行通信</li><li>Pod的生命周期与infra容器一致,与A B无关</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx530pb14ij30dh0d474j.jpg" alt=""></p><p>而对于volume的共享,K8s只需要将所有volume的定义都设计在Pod层就好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: two-containers</div><div class="line">spec:</div><div class="line">  restartPolicy: Never</div><div class="line">  volumes:</div><div class="line">  - name: shared-data</div><div class="line">    hostPath:      </div><div class="line">      path: /data</div><div class="line">  containers:</div><div class="line">  - name: nginx-container</div><div class="line">    image: nginx</div><div class="line">    volumeMounts:</div><div class="line">    - name: shared-data</div><div class="line">      mountPath: /usr/share/nginx/html</div><div class="line">  - name: debian-container</div><div class="line">    image: debian</div><div class="line">    volumeMounts:</div><div class="line">    - name: shared-data</div><div class="line">      mountPath: /pod-data</div><div class="line">    command: [&quot;/bin/sh&quot;]</div><div class="line">    args: [&quot;-c&quot;, &quot;echo Hello from the debian container &gt; /pod-data/index.html&quot;]</div></pre></td></tr></table></figure><p>所以Pod这种”超亲密关系”容器的设计思想,实际上就是希望当用户想在容器里完成多个应用的时候,应该考虑是不是可以描述为一个pod里的多个容器。</p><p>例如应用war包和tomcat容器,可以描述为一个Pod内的多个容器,以组合的方式解决war和tomcat的耦合关系。但是应用与mysql等数据库的关系,不应该描述为一个Pod,我们不能因为应用宕机而造成数据库无法使用,所以应用与数据库要分为两个Pod来部署。</p>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>k8s学习总结-1</title>
      <link href="/2018/11/10/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931-%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/11/10/k8s%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%931-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器其实是一种沙盒技术,能够像集装箱一样,把你的应用装起来。应用与应用之间因为有了边界而不至于互相干扰,被装进集装箱的应用,也可以被方便的搬来搬去,这就是paas最理想的状态。</p><h2 id="docker是如何修改应用的边界"><a href="#docker是如何修改应用的边界" class="headerlink" title="docker是如何修改应用的边界"></a>docker是如何修改应用的边界</h2><p>容器的核心技术,就是通过约束和修改进程的动态表现,从而创造出一种边界。对于Docker等大多数容器来说,Cgroups技术是用来制造约束的主要手段,Namespace技术则是用来修改进程视图的主要方式。</p><p>Namespace可以视为一个障眼法,一个namespace里的应用都只能看到当前namespace下被cgroups等技术所限制的资源,文件,设备,而对于宿主机或其他不相关的应用,就完全看不到。这就是linux容器最基本的实现原理。所以容器技术其实就是一个特殊即进程而已。</p><h2 id="容器与文件系统"><a href="#容器与文件系统" class="headerlink" title="容器与文件系统"></a>容器与文件系统</h2><p>容器里的应用进程,理应看到一份完全独立的文件系统,这样,他就可以在自己的容器目录下完成操作,完全不受宿主机和其他容器的影响。Docker在处理这个问题的时候使用了mount namespace技术,改变了容器文件系统的挂载点,简单来说可以理解为执行一下操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd /var/lib/docker/</div><div class="line">以容器ID为名称创建一个文件夹,如123</div><div class="line">cd 123</div><div class="line">创建一系列文件夹如:etc var lib等待以及所需要的文件内容</div><div class="line">mount(&quot;/&quot;,&quot;var/lib/docker/123&quot;)即修改文件系统挂载点</div></pre></td></tr></table></figure><p>这个挂载到容器根目录上,用来为容器进程提供隔离后执行环境的文件系统,就是所谓的容器镜像。他还有个更专业的名字,rootfs(根文件系统)</p><p>一个常见的rootfs,通常会包含一些文件目录,如/bin /etc /proc等。rootfs只是一个操作系统所包含的文件、配置、目录,并不包含操作系统内核,所以容器镜像要比一个虚拟机iso小的多,因为虚拟机iso文件包含了操作系统的内核。</p><p>除此之外,docker公司做出了一个巨大的创新,就是引入了layer概念,用户每修改一次镜像,都会增量追加一个rootfs,这种做法利用了Union File System技术,即将不同的目录联合挂载到一个目录下,最后我们所看到的文件系统实际上是由多个layer视图叠加显示出来的,一个容器的rootfs实际由三部分组成:</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fx3124ugtzj30jf0eiaao.jpg" alt=""></p><p>用户所进行的一切操作都是在最上部的rw层进行的,init层是用来存放/etc/hosts、/etc/resolv.conf等信息。因为这些信息属于底层文件系统的一部分,有些场景需要修改这些文件,但是我们对镜像进行提交时又不希望将这些信息一起提交,所以设计了init层。下面的就全部都是只读的镜像层。</p><p>当我们创建一个文件时,我们实际上只是在最上层的镜像添加了一个文件,当我们删除一个文件时,实际上创建了一个.wh.foo的文件,这样这个文件就被遮罩了起来。当修改一个文件时,首先会从上到下查找有没有这个文件，找到，就复制到容器层中修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write。</p>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rabbitmq常用模式</title>
      <link href="/2018/09/27/Rabbitmq%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/27/Rabbitmq%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="RabbitMQ常用模式"><a href="#RabbitMQ常用模式" class="headerlink" title="RabbitMQ常用模式"></a>RabbitMQ常用模式</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvnbel6rimj30uy0gaqeu.jpg" alt=""></p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="迅速消息发送"><a href="#迅速消息发送" class="headerlink" title="迅速消息发送"></a>迅速消息发送</h3><ul><li>迅速消息指消息不进行落库,不做可靠性保障</li><li>用于非核心消息,例如日志、统计分析</li><li>特点是性能高,吞吐量大</li><li>代码层面来看就是直接调用rabbitTemplate.convertAndSend方法,不需要消息落库,也不需要监听return or confirm</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fvncdyzb9ej30nd06zjsq.jpg" alt=""></p><h3 id="确认消息发送"><a href="#确认消息发送" class="headerlink" title="确认消息发送"></a>确认消息发送</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fvncfrl93lj30v40f0414.jpg" alt=""></p><p>消息确认模式是一种非常常见的模式,消息需要落库,生产端需要监听broker的confirm响应。对于异常消息需要定时任务进行补偿。</p><h3 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h3><p>批量消息是指我们把多条消息放到一个集合里,在一个session中进行提交。一种做法是将数据放在threadLocal中,提交时带上size属性,最重要的是对这一批数据进行合并。这种方式的缺点是消费端不保证可靠性,返回结果无法预期。同时幂等性也是一个大问题。需要进行消息补偿。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvncld6zx2j30w20eo0y9.jpg" alt=""></p><h3 id="延迟消息发送"><a href="#延迟消息发送" class="headerlink" title="延迟消息发送"></a>延迟消息发送</h3><p>消息延迟推送、定时任务,用于业务削峰限流,降级的异步延迟消息机制</p><p>Rabbitmq对延迟队列的支持需要下载插件来完成</p><blockquote><p> 安装插件</p></blockquote><p> <a href="http://www.rabbitmq.com/community-plugins.html" target="_blank" rel="external">http://www.rabbitmq.com/community-plugins.html</a></p><p>下载对应版本的rabbitmq_delayed_message_exchange插件,解压缩得到.ez文件,放到plugins文件夹</p><blockquote><p> rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p></blockquote><p>启用插件之后重启rabbitmq-server就可以了</p><p>延迟队列的使用非常广泛:例如收货后自动评价功能,优惠券过期等</p><h3 id="顺序消息发送"><a href="#顺序消息发送" class="headerlink" title="顺序消息发送"></a>顺序消息发送</h3><ol><li>保证顺序消费,必须保证消息投递到一个队列中,并且消费者只能有一个(exclusive模式)</li><li>统一提交,保证在同一个会话中</li><li>添加消息属性:顺序标记的序号、消息Size属性，进行落库操作</li><li>并行进行发送给自身的延迟消息进行后续消费处理</li><li>消费者延迟消息,根据会话ID、size进行处理</li><li>定时任务进行补偿</li></ol><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fvnd7kixawj30x90f7ah6.jpg" alt=""></p><h3 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h3><p>消息的幂等性是一个非常重要的特性,是指对于同一个消息,消费者不论消费者接收到多少次这条消息,处理结果都是相同的。</p><blockquote><p>导致非幂等性的原因</p></blockquote><ol><li>可靠性消息投递的机制</li><li>Broker与消费者之间网络波动</li><li>消费端异常</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvndljo98nj30v70emn2q.jpg" alt=""></p><p>这里利用的是一个ID路由组件,如果单个数据库当然就不需要了。生产端生成消息并落库,统一批次的消息一定有一个全局唯一的id去标识。那么消费端利用这个ID去插入数据库,根据是否产生主键冲突来判断幂等性。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rabbitmq与Springboot</title>
      <link href="/2018/09/22/Rabbitmq%E4%B8%8ESpringboot/"/>
      <url>/2018/09/22/Rabbitmq%E4%B8%8ESpringboot/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvihp66f5rj308v04eq2s.jpg" alt=""></p><h2 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a>SimpleMessageListenerContainer</h2><p>SimpleMessageListenerContainer是一个简单消息监听容器,提供了事务特性的设置,包括事务并发量,回滚以及消息确认,重回队列等绝大部分消费者的设置。</p><p>SimpleMessageListenerContainer支持动态修改消费者的配置,可以根据这一特性去自定义rabbitmq管控台。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    @Bean</div><div class="line">    public SimpleMessageListenerContainer container(ConnectionFactory factory)&#123;</div><div class="line">        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(factory);</div><div class="line">        container.setQueues(queue1());</div><div class="line">        container.setConcurrentConsumers(1);</div><div class="line">        container.setMaxConcurrentConsumers(10);</div><div class="line">        container.setDefaultRequeueRejected(false);</div><div class="line">        container.setAcknowledgeMode(AcknowledgeMode.AUTO);</div><div class="line">        container.setConsumerTagStrategy(new ConsumerTagStrategy() &#123;</div><div class="line">            @Override</div><div class="line">            public String createConsumerTag(String queue) &#123;</div><div class="line">                return queue+&quot;_&quot;+UUID.randomUUID().toString();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        //1.接收消息 不灵活</div><div class="line">&lt;!--        container.setMessageListener(new ChannelAwareMessageListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onMessage(Message message, Channel channel) throws Exception &#123;</div><div class="line">                String s = new String(message.getBody());</div><div class="line">                System.out.println(s+&quot;收到消息&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);--&gt;</div><div class="line"> // 自定义消费函数</div><div class="line"> MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());</div><div class="line">        container.setMessageListener(adapter);</div><div class="line">        return container;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">public class MessageDelegate &#123;</div><div class="line">    public void handleMessage(byte[] body)&#123;</div><div class="line">        System.out.println(new String(body)+&quot;收到消息&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码自定义消费者函数,可以看到MessageDelegate就是一个普通类,并没有继承或者实现任何类。那么消息是如何接受的呢?其实这里amqp使用了适配器模式,默认会去你的代理类中调用handleMessage方法,可以通过设置一个方法名来进行自定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adapter.setDefaultListenerMethod(&quot;你的方法名&quot;);</div></pre></td></tr></table></figure><p>如果不进行配置,默认需要用byte[]作为参数来接收消息,否则会抛出错误。</p><h2 id="MessageConvert"><a href="#MessageConvert" class="headerlink" title="MessageConvert"></a>MessageConvert</h2><p>当我们实现自定义的MessageListenerAdapter后,还有可以配置MessageConvert将byte[]编码为需要的格式,而不仅仅是byte[]。展示几种比较常用的转换类型。</p><h3 id="自定义string类型"><a href="#自定义string类型" class="headerlink" title="自定义string类型"></a>自定义string类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());</div><div class="line">adapter.setMessageConverter(new TextMessageConvert());</div><div class="line">//指定的队列路由到指定的方法  对列名-方法名</div><div class="line">Map&lt;String,String&gt;  map = new HashMap&lt;&gt;();</div><div class="line">map.put(&quot;queue-1&quot;,&quot;method1&quot;);</div><div class="line">map.put(&quot;queue-2&quot;,&quot;method2&quot;);</div><div class="line">adapter.setQueueOrTagToMethodName(map);</div></pre></td></tr></table></figure><p>这里配置了QueueOrTagToMethodName,通过这样一个map。可以实现这样的效果:queue-1返回的消息会被MessageDelegate.method1方法接收,queue-2的消息会被MessageDelegate.method2方法接收</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class TextMessageConvert implements MessageConverter &#123;</div><div class="line">    @Override</div><div class="line">    public Message toMessage(Object object, MessageProperties messageProperties) throws MessageConversionException &#123;</div><div class="line">        return new Message(object.toString().getBytes(),messageProperties);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object fromMessage(Message message) throws MessageConversionException &#123;</div><div class="line">        return new String(message.getBody());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>代理类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void handleMessage(String body)&#123;</div><div class="line">    System.out.println(body+&quot;收到消息&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里我们就可以直接使用String类型接收消息了</p><h3 id="json类型"><a href="#json类型" class="headerlink" title="json类型"></a>json类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MessageListenerAdapter adapter = new MessageListenerAdapter(new MessageDelegate());</div><div class="line">Jackson2JsonMessageConverter converter = new Jackson2JsonMessageConverter();</div><div class="line">adapter.setMessageConverter(converter);</div></pre></td></tr></table></figure><blockquote><p>测试  这里需要注意 接收函数的入参需要定义为Map类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void testJson()&#123;</div><div class="line">        Order o = new Order();</div><div class="line">        o.setDesc(&quot;test&quot;);</div><div class="line">        o.setId(&quot;1&quot;);</div><div class="line">        o.setName(&quot;apple&quot;);</div><div class="line">        MessageProperties p  = new MessageProperties();</div><div class="line">        p.setContentType(&quot;application/json&quot;);</div><div class="line">        String s = JSON.toJSONString(o);</div><div class="line">        Message message = new Message(s.getBytes(),p);</div><div class="line">        rabbitTemplate.send(&quot;001&quot;,message);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>代理类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void handleMessage(Map body)&#123;</div><div class="line">    System.out.println(body+&quot;收到消息-json&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="java-对象"><a href="#java-对象" class="headerlink" title="java 对象"></a>java 对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jackson2JsonMessageConverter converter = new Jackson2JsonMessageConverter();</div><div class="line">DefaultJackson2JavaTypeMapper mapper = new DefaultJackson2JavaTypeMapper();</div><div class="line">mapper.setTrustedPackages(&quot;*&quot;);</div><div class="line">converter.setJavaTypeMapper(mapper);</div><div class="line">adapter.setMessageConverter(converter);</div></pre></td></tr></table></figure><p>可以看到消息体转JAVA对象,就是在json的基础上再进行一次封装。</p><blockquote><p>Test</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testJson()&#123;</div><div class="line">     Order o = new Order();</div><div class="line">     o.setDesc(&quot;123123&quot;);</div><div class="line">     o.setId(&quot;1&quot;);</div><div class="line">     o.setName(&quot;apple&quot;);</div><div class="line">     MessageProperties p  = new MessageProperties();</div><div class="line">     p.setContentType(&quot;application/json&quot;);   </div><div class="line">     p.getHeaders().put(&quot;__TypeId__&quot;,&quot;com.demo.rabbitmq.amqp.entity.Order&quot;);</div><div class="line">     String s = JSON.toJSONString(o);</div><div class="line">     Message message = new Message(s.getBytes(),p);</div><div class="line">     rabbitTemplate.send(&quot;001&quot;,message);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>代理类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void handleMessage(Order order)&#123;</div><div class="line">    System.out.println(order+&quot;收到消息 java-type&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="java多对象"><a href="#java多对象" class="headerlink" title="java多对象"></a>java多对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Jackson2JsonMessageConverter converter = new Jackson2JsonMessageConverter();</div><div class="line">DefaultJackson2JavaTypeMapper mapper = new DefaultJackson2JavaTypeMapper();</div><div class="line">Map&lt;String,Class&lt;?&gt;&gt; classMap = new HashMap&lt;&gt;();</div><div class="line">classMap.put(&quot;order&quot;, Order.class);</div><div class="line">classMap.put(&quot;package&quot;, Package.class);</div><div class="line">mapper.setIdClassMapping(classMap);</div><div class="line">mapper.setTrustedPackages(&quot;*&quot;);</div><div class="line">converter.setJavaTypeMapper(mapper);</div><div class="line">adapter.setMessageConverter(converter);</div></pre></td></tr></table></figure><blockquote><p>Test</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testMutilPojo()&#123;</div><div class="line">    Order o = new Order();</div><div class="line">    o.setDesc(&quot;123123&quot;);</div><div class="line">    o.setId(&quot;1&quot;);</div><div class="line">    o.setName(&quot;apple&quot;);</div><div class="line"></div><div class="line">    Package p = new Package();</div><div class="line">    p.setContent(&quot;啊啊&quot;);</div><div class="line">    p.setId(&quot;2&quot;);</div><div class="line">    p.setName(&quot;pac&quot;);</div><div class="line"></div><div class="line">    MessageProperties properties  = new MessageProperties();</div><div class="line"></div><div class="line">    properties.setContentType(&quot;application/json&quot;);</div><div class="line">    properties.getHeaders().put(&quot;__TypeId__&quot;,&quot;order&quot;);</div><div class="line">    Message m1 = new Message(JSON.toJSONString(o).getBytes(),properties);</div><div class="line">    rabbitTemplate.send(&quot;001&quot;,m1);</div><div class="line"></div><div class="line">    properties.getHeaders().put(&quot;__TypeId__&quot;,&quot;package&quot;);</div><div class="line">    Message m2 = new Message(JSON.toJSONString(p).getBytes(),properties);</div><div class="line">    rabbitTemplate.send(&quot;001&quot;,m2);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>delegate 方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void handleMessage(Order pojos)&#123;</div><div class="line">    System.out.println(pojos+&quot;多对象&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void handleMessage(Package pojos)&#123;</div><div class="line">    System.out.println(pojos+&quot;多对象&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="与springboot集成"><a href="#与springboot集成" class="headerlink" title="与springboot集成"></a>与springboot集成</h2><blockquote><p>配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">spring.rabbitmq.addresses=localhost:5672</div><div class="line">spring.rabbitmq.virtual-host=/</div><div class="line">spring.rabbitmq.username=guest</div><div class="line">spring.rabbitmq.password=guest</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 发送端配置</div><div class="line">spring.rabbitmq.publisher-returns=true</div><div class="line">spring.rabbitmq.publisher-confirms=true</div><div class="line">#消息没有被路由到队列会返回给发送者</div><div class="line">spring.rabbitmq.template.mandatory=true</div><div class="line"></div><div class="line"></div><div class="line"># 消费端配置</div><div class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</div><div class="line">spring.rabbitmq.listener.simple.default-requeue-rejected=true</div><div class="line">spring.rabbitmq.listener.simple.concurrency=5</div><div class="line">spring.rabbitmq.listener.simple.max-concurrency=10</div></pre></td></tr></table></figure><p>一般来说我们需要设置发送端监听confrim消息和return消息,并且在消费端关闭自动确认和重回队列</p><blockquote><p>发送端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class RabbitSender &#123;</div><div class="line">    @Autowired</div><div class="line">    private RabbitTemplate template;</div><div class="line"></div><div class="line"></div><div class="line">    final RabbitTemplate.ConfirmCallback confirmCallback = new RabbitTemplate.ConfirmCallback()&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</div><div class="line">            if(ack)&#123;</div><div class="line">                System.out.println(&quot;corr &quot;+correlationData);</div><div class="line">            &#125;else&#123;</div><div class="line">                System.out.println(cause);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    final RabbitTemplate.ReturnCallback returnCallback = new RabbitTemplate.ReturnCallback() &#123;</div><div class="line">        @Override</div><div class="line">        public void returnedMessage(org.springframework.amqp.core.Message message, int replyCode, String replyText, String exchange, String routingKey) &#123;</div><div class="line">            System.out.println(message);</div><div class="line">            System.out.println(replyCode);</div><div class="line">            System.out.println(replyText);</div><div class="line">            System.out.println(exchange);</div><div class="line">            System.out.println(routingKey);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public void send(Object message, Map&lt;String,Object&gt; properties)&#123;</div><div class="line">        MessageHeaders headers = new MessageHeaders(properties);</div><div class="line">        Message msg = MessageBuilder.createMessage(message, headers);</div><div class="line">        template.setConfirmCallback(confirmCallback);</div><div class="line">        template.setReturnCallback(returnCallback);</div><div class="line">        CorrelationData cd = new CorrelationData(&quot;only id&quot;);</div><div class="line">        template.convertAndSend(&quot;test_sb&quot;,&quot;sb.ex&quot;,msg,cd) ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void sendOrder(Order message, Map&lt;String,Object&gt; properties)&#123;</div><div class="line">        template.setConfirmCallback(confirmCallback);</div><div class="line">        template.setReturnCallback(returnCallback);</div><div class="line">        CorrelationData cd = new CorrelationData(&quot;only id&quot;);</div><div class="line">        template.convertAndSend(&quot;order_ex&quot;,&quot;order.1&quot;,message,cd) ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里可以看到,在发送端不需要任何配置,我们是直接可以发送对象的,这里CorrelationData一定要保证全局唯一。</p><blockquote><p>消费端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class RabbitConsumer &#123;</div><div class="line"></div><div class="line">    @RabbitListener(bindings = @QueueBinding(</div><div class="line">            value = @Queue(value = &quot;test_sb&quot;,durable = &quot;true&quot;),</div><div class="line">            exchange = @Exchange(value = &quot;sb_ex&quot;,type = &quot;topic&quot;),</div><div class="line">            key = &quot;sb.#&quot;</div><div class="line">    ))</div><div class="line">    @RabbitHandler</div><div class="line">    public void onMessage(Message message, Channel channel) throws IOException &#123;</div><div class="line">        System.out.println(new String(message.getBody()));</div><div class="line">        long deliveryTag = message.getMessageProperties().getDeliveryTag();</div><div class="line">        channel.basicAck(deliveryTag,false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @RabbitListener(bindings = @QueueBinding(</div><div class="line">            value = @Queue(value = &quot;$&#123;rabbitmq.order.queue&#125;&quot;,durable = &quot;true&quot;),</div><div class="line">            exchange = @Exchange(value = &quot;$&#123;rabbitmq.order.exchange&#125;&quot;,type = &quot;topic&quot;),</div><div class="line">            key = &quot;$&#123;rabbitmq.order.routingKey&#125;&quot;</div><div class="line">    ))</div><div class="line">    @RabbitHandler</div><div class="line">    public void onOrderMessage(@Payload Order order, @Headers Map&lt;String,Object&gt; headers, Channel channel) throws IOException &#123;</div><div class="line">        System.out.println(order);</div><div class="line">        channel.basicAck((Long) headers.get(AmqpHeaders.DELIVERY_TAG),false);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里比较核心的部分就是两个注解@RabbitListener和@RabbitHandler。@RabbitListener会自动创建queue,exchange和bingding。第一个RabbitHandler是我们默认的处理方式,第二个RabbitHandler我们将Message分离为两个注解,@Payload表示消息体,@Headers表示头信息。AMQP帮我们进行了封装,不需要我们在进行手动设置。</p><p>除此之外,类似队列名,交换机名称等可以通过配置文件进行配置,通过@Value注入,这样比较规范。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis底层数据结构</title>
      <link href="/2018/09/18/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/09/18/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>redis中常用的数据结构包括String,Hash,List,Set,Sorted Set,每种都有对应的底层C语言结构。如下图所示</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvdtlczh7wj30ra088t90.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String      : SDS</div><div class="line">Hash        : zipList/hashtable</div><div class="line">List        : quickList</div><div class="line">Set         : intSet/hashtable</div><div class="line">Sorted Set  : skipList</div></pre></td></tr></table></figure><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct SDS&lt;T&gt; &#123;</div><div class="line">    T capacity; // 数组容量</div><div class="line">    T len; // 数组长度</div><div class="line">    byte flags; // 特殊标识位</div><div class="line">    byte[] content; // 数组内容</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>SDS全称为simple dynamic string,由于c语言中的字符串,每次进行len()操作的时候,都要进行遍历,复杂度为O(n),对于单线程的redis来说,O(n)复杂度都是不可接受的,所以在C语言的String基础上改造成了SDS类型。</p><p>SDS内部会维护当前content的长度记为len,capacity为容量,&gt;=len。在字符串进行扩展是,redis会分配一部分额外的空间放置频繁的进行扩张</p><h2 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct ziplist&lt;T&gt; &#123;</div><div class="line">    int32 zlbytes; // 整个压缩列表占用字节数</div><div class="line">    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点</div><div class="line">    int16 zllength; // 元素个数</div><div class="line">    T[] entries; // 元素内容列表，挨个挨个紧凑存储</div><div class="line">    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>顾名思义,ZipList是一个紧凑的list,用于Hash结构元素较少的时候使用。压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。各个元素之间是双向的连接,配合zltail_offset可以实现从后向前遍历。</p><p>但是ZipList也存在局限性,导致它并不适合在大量元素的情况下使用。</p><p>由于ZipList是一块连续的内存区域,那么存在一种情况就是添加元素时已经没有地方realloc,那么这时候就需要重新找一块连续的内存进行分配,这时就需要将这块内存全部拷贝到新的地址空间上去。</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>List结构早期元素少时用 ziplist，元素多时用linkedlist。但是linkedlist会导致内存碎片化严重,并且linkedlist指针成本很高,所以在zipList和LinkedList的基础上改造成了QuickList。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">struct ziplist_compressed &#123;</div><div class="line">    int32 size;</div><div class="line">    byte[] compressed_data;</div><div class="line">&#125;</div><div class="line">struct quicklistNode &#123;</div><div class="line">    quicklistNode* prev;</div><div class="line">    quicklistNode* next;</div><div class="line">    ziplist* zl; // 指向压缩列表</div><div class="line">    int32 size; // ziplist 的字节总数</div><div class="line">    int16 count; // ziplist 中的元素数量</div><div class="line">    int2 encoding; // 存储形式 2bit，原生字节数组还是 LZF 压缩存储</div><div class="line"></div><div class="line">&#125;</div><div class="line">struct quicklist &#123;</div><div class="line">    quicklistNode* head;</div><div class="line">    quicklistNode* tail;</div><div class="line">    long count; // 元素总数</div><div class="line">    int nodes; // ziplist 节点的个数</div><div class="line">    int compressDepth; // LZF 算法压缩深度</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可见QuickList中的每个节点都是一个ZipList,ZipList之间通过指针双向连接。同时QuickList可以进行数据压缩,默认为0即不压缩。为1则表示QuickList首尾不压缩,2则表示就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><h2 id="DIC"><a href="#DIC" class="headerlink" title="DIC"></a>DIC</h2><p>Dic内部包含了两个hashtable,dict 结构内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的。但是在 dict 扩容缩容时，需要分配新的 hashtable，然后进行渐进式搬迁，这时候两个 hashtable 存储的分别是旧的 hashtable 和新的 hashtable。待搬迁结束后，旧的 hashtable 被删除，新的 hashtable 取而代之。</p><p>数据量较大的hash以及存储了非整数的set内部都是用了DIC结构,Hashtable和java中的HashTable非常类似。</p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>与java中的hashTable不同的是,redis中的hashtable使用的是渐进式的rehash,因为redis中的hashtable数据量可能非常大,redis单线程进行复制可能会造成阻塞。一般来说rehash操作会隐藏在一些指令之后,如果没有执行完成,redis会交给后台的定时任务去完成。</p><h3 id="扩容-缩容"><a href="#扩容-缩容" class="headerlink" title="扩容/缩容"></a>扩容/缩容</h3><p>hashtable扩容后会变为原数组的两倍大小。如果Redis 正在做 bgsave，为了减少内存页的过多分离 (Copy On Write)，Redis 尽量不去扩容 (dict_can_resize)，但是如果 hash 表已经非常满了，元素的个数已经达到了第一维数组长度的 5 倍 (dict_force_resize_ratio)，说明 hash 表已经过于拥挤了，这个时候就会强制扩容。</p><p>当元素的个数小于数组大小的10%,就会进行缩容,缩容不需要考虑bgsave。</p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>redis的sorted list内部使用skipList(跳表)实现。skipList的结构与java中的skipList几乎一致。SkipList首先要求是一个有序的列表,redis 通过set 一个score来实现。拿到这样一个list之后,redis会从list中利用算法均匀的筛选一些元素组成上层list,如此循环,redis中的跳表共有64层。理想情况下,跳表最终会形成如下的形状,也就是一个正态分布图。利用这种结构,redis每次从上到下进行匹配,可已将查询的复杂度从O(n)降低到O(1)</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvduzjv8nyj30eo0a2t8h.jpg" alt=""></p><h2 id="intSet"><a href="#intSet" class="headerlink" title="intSet"></a>intSet</h2><p>inSet是一个整数类型的集合,包括16位整数,32位整数,64位整数类型。个人理解这个结构是某些场景下用来节省空间的。例如set中只有整数类型是,当元素大小可以用16位表示,则这个set的encoding就是int16,当出现有元素必须用32位表示时,那么所有的整数都升级为int32,int64以此类推。但是当你删除了int32的数据,intSet是不会降级为int16的。也就是说只能升级不能降级。当set中出现了非整数类型时,redis使用hashtable代替intSet。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis的底层数据结构,几乎都针对redis本身进行了优化。无论在提高性能还是节省空间上,作者都花了很多功夫。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rabbitmq高级特性</title>
      <link href="/2018/09/18/rabbitmq%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2018/09/18/rabbitmq%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="消息可靠投递"><a href="#消息可靠投递" class="headerlink" title="消息可靠投递"></a>消息可靠投递</h2><blockquote><p>什么是生产端的可靠性投递</p></blockquote><ul><li>保证消息发出</li><li>保证MQ接收到消息</li><li>发送端收到MQ的应答</li><li>消息补偿机制</li></ul><h3 id="方案一-消息落库并设置状态"><a href="#方案一-消息落库并设置状态" class="headerlink" title="方案一:消息落库并设置状态"></a>方案一:消息落库并设置状态</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvbrjpf4okj30tl0dgdir.jpg" alt=""></p><p>通过上面的图示很容易理解这种方案的做法。首先要保证在第一步两个入库操作都要成功,这里必定涉及到事务,要做到同时成功,失败则要fail-fast。如果涉及到不同的库或者数据源还可能涉及分布式事务。所以这个设计最大的性能阻塞点就在这里,添加事务就无法应对高并发的场景。</p><p>分布式定时任务用来做消息补偿,重跑一些异常状态的消息。这里有一个可能存在一个问题,当一个消息刚发送出去,定时任务就启动了,导致消息重复发送的情况。所以定时任务出了要判断消息状态,还应该对间隔时间做一个限制。例如查询状态=1并且距离更新时间大于一分钟的消息进行补偿重试。</p><h3 id="方案二-消息延迟投递-做二次确认-回调检查"><a href="#方案二-消息延迟投递-做二次确认-回调检查" class="headerlink" title="方案二:消息延迟投递,做二次确认,回调检查"></a>方案二:消息延迟投递,做二次确认,回调检查</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvbrk01lblj30ke09p75o.jpg" alt=""></p><p>上面说了方案一并不适合在高并发的场景下使用,那么方案二就是应对高并发场景下的常用设计。</p><ol><li>首先上游业务模块将数据入库并发送到broker的业务队列,同时生成一条deley check消息发送到另一个队列,设置延迟发送时间几秒或几分钟之后</li><li>下游业务收到消息并消费后发送confirm消息到broker的一个队列</li><li>callback服务收到确认消息,做消息持久化。</li><li>当延迟确认消息到来之后,如果数据库中有,则成功,否则要callback服务需要进行rpc调用上游服务再次发送一遍消息</li></ol><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="消息幂等性"><a href="#消息幂等性" class="headerlink" title="消息幂等性"></a>消息幂等性</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>利用唯一ID+指纹码机制,利用数据库主键去重</p><p>select count(1) from db where id = 唯一ID+指纹码</p><p>好处  实现简单</p><p>坏处 存在数据库写入瓶颈</p><p>解决方案: 根据id分库分表进行路由</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>利用redis的原子特性,使用exist 获取这set指令</p><p>优点: 性能高</p><p>缺点: 考虑是否需要落库,如果落库如何做到数据库和redis的一致。如果不落库,定时同步策略怎样做。而且缓存不可靠</p><h2 id="消息投递-confirm-return"><a href="#消息投递-confirm-return" class="headerlink" title="消息投递: confirm/return"></a>消息投递: confirm/return</h2><h3 id="confirm机制"><a href="#confirm机制" class="headerlink" title="confirm机制"></a>confirm机制</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvbtaxozjuj30op0bs0v8.jpg" alt=""></p><blockquote><p>如何开启</p></blockquote><ol><li>channel 上确认开启channel.confirmSelect()</li><li>在channel上添加addConfirmListener,监听结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Producer &#123;</div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</div><div class="line">        ConnectionFactory cf = new ConnectionFactory();</div><div class="line">        cf.setVirtualHost(&quot;/&quot;);</div><div class="line">        cf.setHost(&quot;localhost&quot;);</div><div class="line">        cf.setPort(5672);</div><div class="line">        cf.setNetworkRecoveryInterval(3000);</div><div class="line">        cf.setAutomaticRecoveryEnabled(true);</div><div class="line"></div><div class="line">        Connection connection = cf.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line">        channel.confirmSelect();</div><div class="line">        channel.addConfirmListener(new ConfirmListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123;</div><div class="line">                System.out.println(&quot;yes &quot;+deliveryTag);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123;</div><div class="line">                System.out.println(&quot;no &quot;+deliveryTag);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        String exchange = &quot;test_confirm&quot;;</div><div class="line">        String routingKey = &quot;confrim.save&quot;;</div><div class="line"></div><div class="line">        channel.basicPublish(exchange,routingKey,null,&quot;confirm&quot;.getBytes());</div><div class="line"></div><div class="line">        Thread.sleep(10000000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Consumer &#123;</div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</div><div class="line">        ConnectionFactory cf = new ConnectionFactory();</div><div class="line">        cf.setVirtualHost(&quot;/&quot;);</div><div class="line">        cf.setHost(&quot;localhost&quot;);</div><div class="line">        cf.setPort(5672);</div><div class="line">        cf.setNetworkRecoveryInterval(3000);</div><div class="line">        cf.setAutomaticRecoveryEnabled(true);</div><div class="line"></div><div class="line">        Connection connection = cf.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line">        channel.confirmSelect();</div><div class="line">        channel.addConfirmListener(new MyConfirmListener());</div><div class="line"></div><div class="line">        String exchange = &quot;test_confirm&quot;;</div><div class="line">        String routingKey = &quot;confrim.save&quot;;</div><div class="line">        String queue_name = &quot;confirm_queue&quot;;</div><div class="line"></div><div class="line">        channel.exchangeDeclare(exchange,&quot;topic&quot;,true);</div><div class="line">        channel.queueDeclare(queue_name,false,false,false,null);</div><div class="line">        channel.queueBind(queue_name,exchange,routingKey);</div><div class="line"></div><div class="line">        QueueingConsumer qc = new QueueingConsumer(channel);</div><div class="line"></div><div class="line">        channel.basicConsume(queue_name,true,qc);</div><div class="line"></div><div class="line"></div><div class="line">        while (true)&#123;</div><div class="line">            QueueingConsumer.Delivery delivery = qc.nextDelivery();</div><div class="line">            System.out.println(delivery.getBody());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="return-消息机制"><a href="#return-消息机制" class="headerlink" title="return 消息机制"></a>return 消息机制</h3><p>Return Listener用于处理一些不可路由的消息</p><p>生产者通过exchange和routingkey将消息送到某个队列中去,消费者监听队列即可。</p><p>在某些情况下,如果exchange不存在或者routingkey不存在,如果我们需要监听这种不可达的消息,那么就需要return机制</p><blockquote><p>关键配置: Mandatory:如果为true则监听不可达消息。如果为false,则会自动删除消息。默认为false</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Producer &#123;</div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</div><div class="line">        ConnectionFactory cf = new ConnectionFactory();</div><div class="line">        cf.setVirtualHost(&quot;/&quot;);</div><div class="line">        cf.setHost(&quot;localhost&quot;);</div><div class="line">        cf.setPort(5672);</div><div class="line">        cf.setNetworkRecoveryInterval(3000);</div><div class="line">        cf.setAutomaticRecoveryEnabled(true);</div><div class="line"></div><div class="line">        Connection connection = cf.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line">        channel.confirmSelect();</div><div class="line">        channel.addReturnListener(new ReturnListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">                System.out.println(&quot;reply code&quot;+replyCode);</div><div class="line">                System.out.println(&quot;reply text&quot;+replyText);</div><div class="line">                System.out.println(&quot;exchange&quot;+exchange);</div><div class="line">                System.out.println(&quot;routingKey&quot;+routingKey);</div><div class="line">                System.out.println(&quot;properties&quot;+properties);</div><div class="line">                System.out.println(&quot;body&quot;+new String(body));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        String exchange = &quot;test_return&quot;;</div><div class="line">        String routingKey = &quot;return.a&quot;;</div><div class="line"></div><div class="line">        channel.basicPublish(exchange,routingKey,true,null,&quot;confirm&quot;.getBytes());</div><div class="line"></div><div class="line">        Thread.sleep(10000000);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class Consumer &#123;</div><div class="line">    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</div><div class="line">        ConnectionFactory cf = new ConnectionFactory();</div><div class="line">        cf.setVirtualHost(&quot;/&quot;);</div><div class="line">        cf.setHost(&quot;localhost&quot;);</div><div class="line">        cf.setPort(5672);</div><div class="line">        cf.setNetworkRecoveryInterval(3000);</div><div class="line">        cf.setAutomaticRecoveryEnabled(true);</div><div class="line"></div><div class="line">        Connection connection = cf.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        String exchange = &quot;test_return&quot;;</div><div class="line">        String routingKey = &quot;return.b&quot;;</div><div class="line">        String queueName = &quot;return&quot;;</div><div class="line"></div><div class="line">        channel.exchangeDeclare(exchange,&quot;topic&quot;,true);</div><div class="line">        channel.queueDeclare(queueName,false,false,false,null);</div><div class="line">        channel.queueBind(queueName,exchange,routingKey);</div><div class="line"></div><div class="line">        QueueingConsumer qc = new QueueingConsumer(channel);</div><div class="line"></div><div class="line">        channel.basicConsume(queueName,true,qc);</div><div class="line"></div><div class="line"></div><div class="line">        while (true)&#123;</div><div class="line">            QueueingConsumer.Delivery delivery = qc.nextDelivery();</div><div class="line">            System.out.println(delivery.getBody());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="自定义消费者"><a href="#自定义消费者" class="headerlink" title="自定义消费者"></a>自定义消费者</h2><p>自定义消费者可以实现更好的解耦,也是更常见的一种编码方式。之前使用的都是mq提供的QueueingConsumer耦合在代码中,现在我们自定义消费者,只要重写handleDelivery方法即可,如果有特殊的需要,可以重写其他方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.basicConsume(&quot;test01&quot;, false, new MyConsumer(channel));</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MyConsumer extends DefaultConsumer &#123;</div><div class="line">    /**</div><div class="line">     * Constructs a new instance and records its association to the passed-in channel.</div><div class="line">     *</div><div class="line">     * @param channel the channel to which this consumer is attached</div><div class="line">     */</div><div class="line">    public MyConsumer(Channel channel) &#123;</div><div class="line">        super(channel);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">        System.out.println(consumerTag);</div><div class="line">        System.out.println(envelope.getDeliveryTag());</div><div class="line">        System.out.println(properties);</div><div class="line">        System.out.println(new String(body));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="ACK与重回队列"><a href="#ACK与重回队列" class="headerlink" title="ACK与重回队列"></a>ACK与重回队列</h2><p>对于消息的手动签收可以调用,注意需要将自动签收关闭</p><blockquote><p>basicAck(String deleveryTag,bool mutil)</p><p>basicNack(String devertyTag,bool multi,bool requeue)</p></blockquote><p>第一个表示确认签收,第二个表示不签收。mutil参数表示是否支持批量签收,requeue参数如果设置为true则表示对于签收失败的消息,可以再次添加到队列的尾部,重新消费,也就是重回队列机制。但是实际上一般都会讲重回队列机制关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.basicConsume(queue_name, false, new MyConsumer(channel));</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class MyConsumer extends DefaultConsumer &#123;</div><div class="line">    private Channel channel;</div><div class="line">    public MyConsumer(Channel channel) &#123;</div><div class="line">        super(channel);</div><div class="line">        this.channel=channel;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">        System.out.println(&quot;收到消息 手动签收&quot;);</div><div class="line"></div><div class="line">        if(true)&#123;</div><div class="line">            channel.basicNack(envelope.getDeliveryTag(),false,false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        channel.basicAck(envelope.getDeliveryTag(),false);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="消息限流"><a href="#消息限流" class="headerlink" title="消息限流"></a>消息限流</h2><p>假设一个场景,mq中囤积了上万条消息,当我们启动一个消费端时,巨量的消息瞬间推过来,会将服务压垮。所以消费端需要做限流</p><p>rabbitmq提供了qos(服务质量保证)功能,即在非自动确认的消息的前提下,如果有一定数目的消息未被消费,则不能消费新的消息</p><blockquote><p>void basicQos(unit prefetchSize,uShort prefetchCount,bool golable);</p><p>第一个参数为消息的大小,一般设置为0不限制就好。</p><p>第二个是告诉mq每次推送不要超过n个消息,一旦有n个消息没有ack,则直接将consumer block,直到consumer ack。</p><p>第三个参数true/false 表示将限制设置为channle级别还是consumer级别</p><p>一定要注意设置为手动ack,不能做自动ack!</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">channel.basicQos(0,3,false);</div><div class="line"></div><div class="line">channel.basicConsume(&quot;test01&quot;, false, new MyConsumer(channel));</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class MyConsumer extends DefaultConsumer &#123;</div><div class="line">    private Channel channel;</div><div class="line">    public MyConsumer(Channel channel) &#123;</div><div class="line">        super(channel);</div><div class="line">        this.channel=channel;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</div><div class="line">        System.out.println(&quot;收到消息 手动签收&quot;);</div><div class="line">        channel.basicAck(envelope.getDeliveryTag(),false);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="TTL消息"><a href="#TTL消息" class="headerlink" title="TTL消息"></a>TTL消息</h2><p>TTL即time to live(生存时间),rabbitmq支持消息过期,在发送时指定限制时间。同时rabbitmq也支持队列级别的过期时间,从消息入队时间算起,一旦超过队列设置的过期时间,都会删除消息。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvcrj5rlt8j30hl06rwf3.jpg" alt=""></p><p>从rabbitmq的控制台中我们可以再创建队列的时候设置参数,点击message TTL就可以自动添加,然后设置时间即可,单位是ms。</p><p>通过这种设置方式,当队列中的消息,10s内没有被消费,则会被自动清除。</p><p>另一种方式是在发送端,通过properties设置,这条消息本身10s内没有被消费则会过期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AMQP.BasicProperties properties = new AMQP.BasicProperties().builder().expiration(&quot;10s&quot;).build();</div><div class="line"></div><div class="line">channel.basicPublish(exchange,routingKey,properties,&quot;hello mq ack&quot;.getBytes());</div></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>DLX即Dead-Letter-Exchange。利用DLX,当一条消息在一个队列中变成死信(dead message)后,会被重新publish到另一个exchange,这个exchange就是DLX。</p><blockquote><p>消息变成dead message的情况</p></blockquote><ol><li>消息被拒绝 （basic.reject/basic.nack） requeue=false</li><li>TTL过期</li><li>队列达到最大长度</li></ol><h3 id="死信队列设置"><a href="#死信队列设置" class="headerlink" title="死信队列设置"></a>死信队列设置</h3><p>Exchange :  dlx.ex<br>Queue : dlx_q<br>routingKey: #</p><p>在队列上添加参数 “x-dead-letter-exchange”:”dlx.ex”,代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//首先声明普通队列作为死信队列</div><div class="line">String exchange = &quot;dlx.ex&quot;;</div><div class="line">String routingKey = &quot;#&quot;;</div><div class="line">String queue_name = &quot;dlx.q&quot;;</div><div class="line">channel.exchangeDeclare(exchange,&quot;topic&quot;,true);</div><div class="line">channel.queueDeclare(queue_name,false,false,false,null);</div><div class="line">channel.queueBind(queue_name,exchange,routingKey);</div><div class="line"></div><div class="line"></div><div class="line">//声明一个普通队列</div><div class="line">String t_exchange = &quot;test_dlx.ex&quot;;</div><div class="line">String t_routingKey = &quot;#&quot;;</div><div class="line">String t_queue_name = &quot;test_dlx.q&quot;;</div><div class="line">channel.exchangeDeclare(exchange,&quot;topic&quot;,true);</div><div class="line">Map&lt;String,Object&gt; arg = new HashMap&lt;&gt;();</div><div class="line">arg.put(&quot;x-dead-letter-exchange&quot;,exchange);</div><div class="line">arg.put(&quot;x-message-ttl&quot;,10000);</div><div class="line">channel.queueDeclare(queue_name,false,false,false,arg);</div><div class="line">channel.queueBind(queue_name,exchange,routingKey);</div></pre></td></tr></table></figure><p>通过监听死信队列，10s后test_dlx.q的数据过期,数据会自动发送过来。</p></the>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ElasticSearch-分布式架构(5)</title>
      <link href="/2018/09/08/ElasticSearch%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-5/"/>
      <url>/2018/09/08/ElasticSearch%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84-5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fv2aitojvfj30xk0e0aa6.jpg" alt=""></p><p>ES是一套天生支持分布式的系统,分布式的目的是解决大数据量的问题。但是在我们使用的过程中,并没有对其分布式特性进行特殊配置。这时因为ES对用户隐藏了复杂的分布式机制,包括分片,集群发现,负载均衡,replica,路由,扩容以及reIndex。使得用户通过简单的配置就可以对ES实现开箱即用。但是对于开发人员,我们还是要理解ES隐藏的机制和架构,做到知其然也知其所以然。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="ES集群"><a href="#ES集群" class="headerlink" title="ES集群"></a>ES集群</h2><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fv35rpjsfuj30vm0f274t.jpg" alt=""></p><p>当ES节点启动后,会通过多播(multi cast)的方式寻找集群中的其他节点,并与之建立联系。在集群中，一个节点被选举成主节点(master node)。这个节点负责管理集群的状态，当群集的拓扑结构改变时把索引分片分派到相应的节点上。</p><p>寻找的依据就是配置文件中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cluster.name:</div></pre></td></tr></table></figure><p>默认为elasticsearch。</p><p>ES集群的主节点与其他中间件主节点的区别在于,主节点并不会处于一个特殊的地位。用户不需要知道哪个节点是主节点，因为所有操作都可以分发到任意的节点,任何节点都可以将查询语句分发到其他节点,将结果聚合之后再返回给用户。节点之间通过P2P的方式通信,而并非需要主节点进行中转。</p><h3 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h3><p>ES集群状态分为red/yellow/green,红色表示存在shard不可用的情况,黄色表示所有shard可用,但有replica不可用,绿色表示所有shard可用,并且replica也可用。</p><h3 id="节点失效"><a href="#节点失效" class="headerlink" title="节点失效"></a>节点失效</h3><p>Master节点会负责监控集群中的其他节点，若节点出现故障,这时就会启动容灾策略。由于节点不可用,其他节点会接管发送到这个节点的请求,同时新的主分片会从replica中选举出来</p><h3 id="Shard-amp-Replica"><a href="#Shard-amp-Replica" class="headerlink" title="Shard&amp;Replica"></a>Shard&amp;Replica</h3><ul><li>一个index可以有多个shard</li><li>每个shard都是一个最小的工作单元,是一个lucence实例，有完整的建立索引处理请求的能力。</li><li>增减节点，会触发shard的负载均衡</li></ul><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>ES的选举通过zenDiscovery模块进行,通过ping所有节点获取response过滤出有资格进行选举的节点。然后根据nodeId进行排序,选出nodeId排在第一的节点对它进行投票,如果这个节点本身也选择了自己并且票数达到了n(节点数量)/2+1,那么这次投票就是成功的,否则继续进行。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv39n4qac0j30pc13i763.jpg" alt=""></p><h3 id="如何避免脑裂"><a href="#如何避免脑裂" class="headerlink" title="如何避免脑裂"></a>如何避免脑裂</h3><ul><li><p>当集群数量不小于3，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p></li><li><p>当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题。</p></li></ul><h3 id="TransLog"><a href="#TransLog" class="headerlink" title="TransLog"></a>TransLog</h3><p>lucene索引过程中，数据会首先据缓存在内存中直到达到一个阈值才会写入到磁盘。这就会带来一个风险，如果在写入磁盘前系统崩溃，那么这些缓存数据就会丢失。ES的解决方式与HBase一致,通过预写日志来保证数据可恢复。也就是ES的Translog，每次写操作都会写入一个临时文件translog中，这样如果系统需要恢复数据可以从translog中读取</p><h2 id="ES-Search分析"><a href="#ES-Search分析" class="headerlink" title="ES Search分析"></a>ES Search分析</h2><p>首先search应区别于对单个文档的操作,search是指对于某种查询条件,对集群中所有节点来进行数据匹配。若一个index被分为N个shard,则至少有N个节点会参与到search中。</p><p>ES search数据的过程可以成为query then fetch,找到匹配的文档并抓取。</p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>在初始查询阶段时，查询会广播到索引中每一个分片副本（主分片或者副分片）。 每个分片在本地执行搜索并构建一个匹配文档的 优先队列。优先队列大小为分页参数 from + size。</p><p>QUERY_THEN_FETCH 搜索类型的查询阶段有以下步骤:</p><ol><li>客户端发送 search 请求到 Node 3。</li><li>Node 3 将查询请求转发到索引的每个主分片或副分片中。</li><li>每个分片在本地执行查询，并使用本地的Term/Document Frequency信息进行打分，添加结果到大小为 from + size 的本地有序优先队列中</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv3aho3nmgj312o0g4jrs.jpg" alt=""></p><p>每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，它合并这些值到自己的优先队列，产生一个全局排序后的列表。<br>协调节点广播查询请求到所有相关分片时，可以是主分片或副分片，协调节点将在之后的请求中轮询所有的分片副本来分摊负载。</p><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>Query 阶段知道了要取哪些数据，但是并没有取具体的数据，这就是 fetch 阶段要做的。</p><p>Fetch 阶段由以下步骤构成：</p><ol><li>协调节点向相关 node 发送 GET 请求</li><li>分片所在节点向协调节点返回数据</li><li>协调节点等待所有文档被取得，然后返回给客户端</li></ol><p>分片所在节点在返回文档数据时，处理有可能的_source 字段以及高亮参数。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fv3aij8dtij312e0fmdg8.jpg" alt=""></p><blockquote><p>参考 <a href="https://www.easyice.cn/archives/257" target="_blank" rel="external">https://www.easyice.cn/archives/257</a></p></blockquote><h2 id="ES-写流程分析"><a href="#ES-写流程分析" class="headerlink" title="ES 写流程分析"></a>ES 写流程分析</h2><blockquote><p>参考 <a href="https://www.easyice.cn/archives/180" target="_blank" rel="external">https://www.easyice.cn/archives/180</a></p></blockquote><ol><li><p>协调节点负责创建索引,将请求转发到主分片节点</p></li><li><p>主分片将数据写到本地,转发写副本分片请求,回复协调节点</p></li><li><p>协调节点将信息返回给客户端</p></li></ol></the>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hbase数据存取过程</title>
      <link href="/2018/09/08/Hbase%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/09/08/Hbase%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Hbase数据存储"><a href="#Hbase数据存储" class="headerlink" title="Hbase数据存储"></a>Hbase数据存储</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>在提交之前,Hbase client回去请求zk,从mate表中确定要存取regionServer的位置。根据rowKey找到对应的regionServer。拿到地址之后,默认情况下像put、delete这类操作是默认提交的,会直接提交到对应的regionServer上,也可以设置autoflush为false,当到达默认的2M的缓存阈值后才会异步批量提交到服务端。</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv21klmsihj30bv07dmxt.jpg" alt=""></p><p>至此,客户端的操作就完成了</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>到达服务器之后,首先获取到行锁(RowLock),保证同一行数据操作的互斥。接着把数据写入Hlog(WAL机制),保证数据的可靠性。接着将数据写入memstore。完成这一系列操作之后,释放行锁和共享锁。</p><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fv21os2178j308n04emxd.jpg" alt=""> </p><p>接着,HlogSyncer线程会异步将Hlog写到Hdfs,memsotre如果大于阈值会异步刷写为storefile,默认为64M。直到storefile的数量大于阈值,会进行compaction操作,将多个storefile合并为一个大的storefile,同时进行版本合并和数据删除。但是storefile可能会无限的增长,当大于某一个阈值之后,会触发split操作。将当前的region split为两个region,并通知Master,HMaster会分配新生成的两个region的位置,有可能会分配到其它regionServer上,保证负载均衡。</p><p>至此,服务端的操作也就完成了。</p><p><img src="https://ws2.sinaimg.cn/large/0069RVTdgy1fv21vo38jlj30jd076tap.jpg" alt=""></p><h2 id="HBase数据获取"><a href="#HBase数据获取" class="headerlink" title="HBase数据获取"></a>HBase数据获取</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>同上</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>regionServer接到客户端的Get或者Scan请求会做两件事情。首先构建scanner体系:首先在确定的region上构建一个regionScanner,准备检索。region会根据列族构建storeScanner,再去根据Hfile的数量构建StoreFileScanner去文件上执行检索。同时会对memstore构建一个memstoreScanner。通过这样的检索,就找到了KV结构的数据,接着封装为ResultSet返回客户端。</p><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fv224qbn8ej30km094q56.jpg" alt=""></p><h2 id="Hbase优化策略"><a href="#Hbase优化策略" class="headerlink" title="Hbase优化策略"></a>Hbase优化策略</h2><h3 id="服务端优化"><a href="#服务端优化" class="headerlink" title="服务端优化"></a>服务端优化</h3><ul><li>jvm与gc配置</li><li>hbase-site.xml配置</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftwtgjdbeyj30tx0djdq4.jpg" alt=""></p><p>hbase.hregion.majorcompaction建议设置为0,因为在生产环境中这个周期会持续几个小时,可以手动写脚本在业务低峰的时候执行。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ftwtlfd98ej30tx0fvwpf.jpg" alt=""></p><h3 id="Hbase常用优化"><a href="#Hbase常用优化" class="headerlink" title="Hbase常用优化"></a>Hbase常用优化</h3><ul><li>预先分区</li><li>Column优化</li><li>rowkey优化</li><li>schema优化</li></ul><h4 id="预先分区"><a href="#预先分区" class="headerlink" title="预先分区"></a>预先分区</h4><p>创建Hbase表的时候会自动创建一个region分区,而region的split操作是十分耗时的而且会阻塞其他动作,造成无法访问。我们可以在创建Hbase表的时候预先创建一些空的region,指定不同的rowkey分配到不同的region。除此之外,预先分区还可以解决数据倾斜的问题,将访问量大的数据放到一个region,访问量少的放在一个region</p><h4 id="Rowkey优化"><a href="#Rowkey优化" class="headerlink" title="Rowkey优化"></a>Rowkey优化</h4><ul><li>利用HBase默认排序的特点,将一起访问的数据放到一起。</li><li>防止热点问题,避免使用时序或者单调增减</li><li>尽可能短</li></ul><h4 id="Column优化"><a href="#Column优化" class="headerlink" title="Column优化"></a>Column优化</h4><ul><li>列族的名称和列的描述尽量短</li><li>同一张表中的CF尽量不要超过3个</li></ul><h4 id="schema优化"><a href="#schema优化" class="headerlink" title="schema优化"></a>schema优化</h4><ul><li>宽表: 列多行少的设计</li><li>高表: 列少行多的设计</li></ul><p>对于查询来说,高表的性能更好,高表的元数据开销比较大。由于Hbase的事务是建立在行上,所以宽表的事务性更好。</p><h3 id="Hbase写优化策略"><a href="#Hbase写优化策略" class="headerlink" title="Hbase写优化策略"></a>Hbase写优化策略</h3><p>Hbase写数据的流程为:数据先写入memstore,再写入Hlog。当memstore里面的数据达到一定的阈值之后会将memstore里面的数据flush到hdfs上的hfile中。当我们使用开发的程序执行写入操作的时候,我们需要考虑:</p><ul><li>同步批量提交or异步批量提交</li><li>WAL优化(默认开启,表示写入memstore的同时也要写入hfile),也就是说我们的业务能否忍受当发生异常的时候,部分数据丢失。如果我们需要更高的吞吐量,则可以将WAL关闭。   </li></ul><h3 id="Hbase读优化策略"><a href="#Hbase读优化策略" class="headerlink" title="Hbase读优化策略"></a>Hbase读优化策略</h3><ul><li>客户端: scan缓存设置,批量获取数据</li><li>服务端: BlockCache配置是否合理,Hfile是否过多</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hbase基础</title>
      <link href="/2018/09/07/Hbase%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/09/07/Hbase%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hbase是一个分布式的、面向列的开源数据库</p><p>Hbase在Hadoop之上提供了类似于Bigtable(源自google,建立在GFS之上)的能力</p><p>Hbase适合存储非结构化数据</p><h3 id="列是数据库是什么"><a href="#列是数据库是什么" class="headerlink" title="列是数据库是什么"></a>列是数据库是什么</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ftqyydrkx1j30p30con1i.jpg" alt=""></p><p>可以看到,列式数据库和传统的关系型数据库相比,旋转了90度,将关系型数据库的一列保存为一行。列式存储的主要优点之一就是可以大幅降低系统的I/O，尤其是在海量数据查询时,因为对一列的查询时一个连续的物理空间。行式更适合OLTP，比如传统的基于增删改查操作的应用。列式更适合OLAP，非常适合于在数据仓库领域发挥作用，比如数据分析、海量存储和商业智能；涉及不经常更新的数据。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="Hbase和HDFS"><a href="#Hbase和HDFS" class="headerlink" title="Hbase和HDFS"></a>Hbase和HDFS</h3><p>Hbase建立在Hadoop文件系统之上,利用了Hadoop系统的容错能力</p><p>Hbase提供对数据随机实时读写访问</p><p>Hbase内部使用哈希表,并存储索引,可将在HDFS文件中的数据进行快速查找</p><p>###Hbase使用场景</p><p>瞬间写入量很大,使用关系型数据库成本很高</p><p>数据需要长久保存,并且持续增长</p><p>不涉及join,多级索引或复杂表操作</p><h2 id="Hbase基本概念"><a href="#Hbase基本概念" class="headerlink" title="Hbase基本概念"></a>Hbase基本概念</h2><ul><li><p>NameSpace: 可以理解为RDBMS的数据库</p></li><li><p>Table: 表,表名必须是一个文件路径中的合法名字</p></li><li><p>Row: 在表中,每一行代表一个数据对象,每一个行有唯一行键(Row Key)来进行唯一标示,以二级制字节来存储,不可变。</p></li><li><p>Column: Hbase的列由Column Family和Column qualifier组成,由冒号:进行间隔。Column Family是列的集合,Column Family一经定义便不可变,但其中包含的column可以动态添加或删除。Column qualifier可以理解为列名。</p></li></ul><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftr1g4gynxj305g03x3yr.jpg" alt=""></p><p>简单搭建一个伪分布式的Hbase,其中Hmaster、HRegionServer和HQuorumPeer(zookeeper)属于hbase系统,依次看一下作用</p><h3 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h3><p>HMaster是hbase主从集群架构中的中央节点,用于将region分配给RegionServer,协调regionServer负载并维护集群的状态。region就是Hbase中存储的最小单元.Hmaster还负责维护表和region的元数据,不参与数据的输入输出过程</p><h3 id="RegionServer"><a href="#RegionServer" class="headerlink" title="RegionServer"></a>RegionServer</h3><p>维护HMaster分配的region,处理这些region的io请求,并且对运行过程中增大的region进行切分</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>Hbase集群的协调器,保存Hbase的一个mate信息,维护hbase regionserver的状态信息</p><h2 id="HBase存储设计"><a href="#HBase存储设计" class="headerlink" title="HBase存储设计"></a>HBase存储设计</h2><h3 id="Log-Structured-Merge-Trees-（LSM）"><a href="#Log-Structured-Merge-Trees-（LSM）" class="headerlink" title="Log Structured Merge Trees （LSM）"></a>Log Structured Merge Trees （LSM）</h3><p>LSM是日志结构合并树,它是由两个或两个以上存储数据的结构组成。每个数据结构各自对应一种存储介质。简易LSM由两个树状结构组成。分别为C0、C1。</p><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fv1c7b76kyj30dy04hjrg.jpg" alt=""></p><p>C0比较小,并全部存储于内存之中,而C1存储于磁盘上。当有数据时,先插入到C0中,如果这一次C0的插入超过了阈值,C0中的数据片段会刷写到C1上。一般来说,第一层是以快速读写为目标,第二层提供持久化,可以继续扩展第三层,作用是对第二层的持久化文件进行合并拆分。</p><h3 id="LSM在Hbase中的体现"><a href="#LSM在Hbase中的体现" class="headerlink" title="LSM在Hbase中的体现"></a>LSM在Hbase中的体现</h3><ol><li>当数据到达regionServer,数据并不会直接写到硬盘之中,为了加速随机读写。而是写到log和memstore中,写日志是因为内存中的数据易丢失不稳定。</li><li>当memsotre的数据超过阈值,后台线程会将这部分数据flush到磁盘,生成storefile</li><li>系统不断刷写会产生很多小文件,这样不利于查询和读写。在某一时刻,hbase会将这些小文件合并为一个大文件，也就是一个多路归并算法。</li></ol><h3 id="Hbase各级组织模块"><a href="#Hbase各级组织模块" class="headerlink" title="Hbase各级组织模块"></a>Hbase各级组织模块</h3><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv1cwh9hoqj30dp07yabp.jpg" alt=""></p><p>RegionServer包含多个Hregion,Hregion是我们可见的存储数据的最小单元。每个region包含的数据都是互斥的。</p><p>每个Region包含多个store,Store对应Hbase表的列族。每个store都包含一个memstore,它是一个内存式的数据结构。Memstore满了之后写到storefile中,最后会将storefile刷写成hdfs上的hfile文件。</p><p>每个regionServer都有一个Hlog实例,用于实现WAL。HLog+Memstore构成了Hbase LSM的第一层结构。storefile+hfile构成了第二次结构,实现了不可靠数据的持久化。</p><h3 id="Hbase-Region解析"><a href="#Hbase-Region解析" class="headerlink" title="Hbase Region解析"></a>Hbase Region解析</h3><p><img src="https://ws4.sinaimg.cn/large/0069RVTdgy1fv1d4w73e6j30e008wdh4.jpg" alt=""></p><p>每个Region都存在于一个确定的RegionServer上,Hbase表在行键的方向上分割为多个Region,是Hbase分布式存储的最小单元。并且Hbase保证了一行数据只可能在一个region上。当列族的大小到达一定的阈值,一个region会被分为两个region,region在regionServer运行过程中会出现移动,当一个regionServer挂掉,Hmaster会将这些region分配到其它regionServer上去。每个region都有三个参数标识:表名、startRowKey、createTime(最早的数据插入时间)。总结如下:</p><ul><li>region 是Hbase负载均衡和分布式存储的最小单元，并不是存储的最小单元</li><li>region 的数量太多性能就会下降,太少就会降低并行能力(region数量不要低于hbase节点数量) </li><li>region 的分割操作是不可见的,做法是先将这个region下线,然后将子region加入到meta信息中, 然后加入原有的region,最后同步到master</li></ul><h3 id="HFile解析"><a href="#HFile解析" class="headerlink" title="HFile解析"></a>HFile解析</h3><p>HFile是Hbase存储数据的最基本组织形式,底层是Hadoop的二进制格式文件。</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv1duk2mowj30bb08b764.jpg" alt=""></p><p>Hfile可以分为四个部分:</p><ol><li>scanned block: 用户数据存储区域</li><li>Nonscanned block: 元数据区</li><li>Load on open: regionServer启动时加载到内存,主要是Hfile的元数据</li><li>trailer: 记录了Hfile的基本信息,各部分的偏移量,寻址信息,也可以理解为元数据的一部分</li></ol><p>用户的数据真正存储于scanned block区域中的data block中,Data block是一种key-value的结构</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv1dzycx57j30ku070goe.jpg" alt=""></p><p>可以看出key的结构非常复杂,通过rowkey+cf+cq+timestamp+keyType才能唯一确定一个value值</p><h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>数据写入时首先会在Hlog中记录一条日志,然后在写入memstore内存中</p><p>WAL即预写日志,最重要的功能就是灾难恢复。用于恢复那些写入memstore但没有来得及flush到磁盘就丢失的数据。 </p><h3 id="compaction"><a href="#compaction" class="headerlink" title="compaction"></a>compaction</h3><p>compaction即从一个hregion的store中选取一些storefile文件进行合并。先从待合并的文件中读取key-value数据,在按照rowkey从小到大排序写到一个新的文件,新的文件就会替代合并的文件向外提供服务。</p><p>为什么会有compaction这样的机制呢,因为文件过多会降低查询的效率并且不易维护。</p><blockquote><p>compaction分为两类: minor compaction和major compaction。</p></blockquote><p>minor compaction是指合并一些临近的较小的storefile为一个较大的storefile</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv1eg80gjxj30be083gn0.jpg" alt=""></p><p>major compaction是指将所有的storefile合并为一个大的storefile,在这个过程中还会执行一些清理操作</p><ol><li>将那些标记为删除的数据进行物理删除</li><li>删除ttl过期的数据</li><li>版本号超过最大版本的数据</li></ol><blockquote><p>compaction触发时机</p></blockquote><ol><li>memstore flush数据到storefile,文件数量到达阈值会触发</li><li>后台线程(compaction checker)周期性检查，首先会判断文件数量是否达到阈值,之后会检查是否达到一个设定的合并时间范围,默认为[7-7*0.2,7+7*0.2]，也就是周期性的进行大合并。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hbase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(10) Netty中的性能调优</title>
      <link href="/2018/07/22/Netty-10-Netty%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2018/07/22/Netty-10-Netty%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h2 id="单机百万调优"><a href="#单机百万调优" class="headerlink" title="单机百万调优"></a>单机百万调优</h2><ul><li><p>如何模拟百万连接</p></li><li><p>如何突破局部文件句柄的限制</p></li><li><p>如何突破全局文件句柄的限制</p></li></ul><p>首先第一个问题,当我们启动一个服务端,我们会绑定一个端口。当客户端去连接,默认连接数是有限制的,是65535,并且1024以下只能被root使用,所以单机只有6W左右的连接可以介入。所以可以采取的办法就是服务端开启8000-8100共100个端口,客户端使用1025~65535去连接服务端。100*6w大约600W连接。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><blockquote><p>服务端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public class MillionServer &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private  static void start(int start,int n)&#123;</div><div class="line">        System.out.println(&quot;opening&quot;);</div><div class="line">        EventLoopGroup boss = new NioEventLoopGroup();</div><div class="line">        EventLoopGroup worker = new NioEventLoopGroup();</div><div class="line"></div><div class="line">        ServerBootstrap bootstrap = new ServerBootstrap();</div><div class="line">        bootstrap.group(boss,worker);</div><div class="line">        bootstrap.channel(NioServerSocketChannel.class);</div><div class="line">        bootstrap.childOption(ChannelOption.SO_REUSEADDR,true);</div><div class="line">        bootstrap.childHandler(new ConnectionCountHandler());</div><div class="line"></div><div class="line">        for(int i=0;i&lt;n;i++)&#123;</div><div class="line">            int port = start+i;</div><div class="line">            bootstrap.bind(port).addListener((ChannelFutureListener)future -&gt; &#123;</div><div class="line">                System.out.println(&quot;connection &quot;+port);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;start&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ConnectionCountHandler extends ChannelInboundHandlerAdapter &#123;</div><div class="line">    private AtomicInteger conn = new AtomicInteger();</div><div class="line"></div><div class="line">    public ConnectionCountHandler()&#123;</div><div class="line">        Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(()-&gt;&#123;</div><div class="line">            System.out.println(&quot;count&quot;+conn.get());</div><div class="line">        &#125;,0,2, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class="line">        conn.getAndIncrement();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class="line">        conn.getAndDecrement();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>客户端</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</div><div class="line">        EventLoopGroup worker = new NioEventLoopGroup();</div><div class="line">        final Bootstrap bootstrap = new Bootstrap();</div><div class="line"></div><div class="line">        bootstrap.group(worker);</div><div class="line">        bootstrap.channel(NioSocketChannel.class);</div><div class="line">        bootstrap.option(ChannelOption.SO_REUSEADDR,true);</div><div class="line">        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        int index = 0;</div><div class="line"></div><div class="line">        int port;</div><div class="line"></div><div class="line">        while (!Thread.interrupted())&#123;</div><div class="line">            port = 8000+index;</div><div class="line">            ChannelFuture future = bootstrap.connect(&quot;localhost&quot;, port);</div><div class="line">            future.addListener((ChannelFutureListener)future1 -&gt;&#123;</div><div class="line">                if(!future1.isSuccess())&#123;</div><div class="line">                    System.out.println(&quot;bye&quot;);</div><div class="line">                    System.exit(0);</div><div class="line">                &#125;</div><div class="line">            &#125; );</div><div class="line">            future.get();</div><div class="line">            if(++index==100)&#123;</div><div class="line">                index=0;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将代码打包后成jar放在两台服务器上运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xms6.5G -Xmx6.5G  -xx newSize5.5G -xx:MaxDirectMemorySize=1g</div></pre></td></tr></table></figure><p>将项目启动后,可以发现连接数到800左右就已经停止服务</p><h2 id="突破连接数限制"><a href="#突破连接数限制" class="headerlink" title="突破连接数限制"></a>突破连接数限制</h2><p>在linux下执行</p><blockquote><p>ulimit -n 可以查看系统支持单个进程打开的最大文件句柄数</p></blockquote><p>要突破这个限制修改配置文件</p><blockquote><p>vim /etc/security/limits.conf</p></blockquote><p>末尾添加</p><blockquote><ul><li>hard nofile 1000000</li></ul><ul><li>soft nofile 1000000</li></ul></blockquote><p>接着我们重新启动服务,发现连接数可以增加到9000左右,比之前的几百高了十倍。</p><h2 id="突破全局文件句柄限制"><a href="#突破全局文件句柄限制" class="headerlink" title="突破全局文件句柄限制"></a>突破全局文件句柄限制</h2><blockquote><p>cat /proc/sys/fs/file-max</p><p>vim /etc/sysctl.conf</p><p>在文件末尾添加 fs.file-max = 1000000</p><p>sysctl -p</p></blockquote><p>经过这样一番折腾,应该能达到90W左右,可能会受限于本机的配置。</p><h2 id="应用性能调优"><a href="#应用性能调优" class="headerlink" title="应用性能调优"></a>应用性能调优</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class BuzHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt;&#123;</div><div class="line">    @Override</div><div class="line">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</div><div class="line">        ByteBuf data = Unpooled.directBuffer();</div><div class="line">        data.writeBytes(msg);</div><div class="line">        //耗时业务处理</div><div class="line">        Object res = data;</div><div class="line">        ctx.pipeline().writeAndFlush(res);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>假设有这样一个业务handler,我们定位到耗时的业务处理代码,这时我们可以使用线程池来提高性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class BuzHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt;&#123;</div><div class="line"></div><div class="line">    private static  ExecutorService  threadPool = Executors.newFixedThreadPool(1000);</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</div><div class="line">        ByteBuf data = Unpooled.directBuffer();</div><div class="line">        data.writeBytes(msg);</div><div class="line">        //耗时业务处理</div><div class="line">        threadPool.submit(()-&gt;&#123;</div><div class="line">            Object res = data;</div><div class="line">            ctx.pipeline().writeAndFlush(res);</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>如果不想手动创建线程池,Netty同样支持将业务代码放入NioEventLoop中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NioEventLoopGroup buz = new NioEventLoopGroup(1000);</div><div class="line">socketChannel.pipeline().addLast(buz,new BizHandler());</div></pre></td></tr></table></figure><p>虽然这样做看起来代码更简洁,但是业务逻辑中如果有分配buffer的代码,这样做就会造成将buffer分配到业务线程中,所以在性能要求高的地方还是推荐第一个种。</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(9) Netty中的设计模式</title>
      <link href="/2018/07/22/Netty-9-Netty%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/22/Netty-9-Netty%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><ul><li><p>一个类全局只有一个对象</p></li><li><p>延迟加载</p></li><li><p>线程安全</p></li></ul><blockquote><p>ReadTimeOutException</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public final class ReadTimeoutException extends TimeoutException &#123;</div><div class="line"></div><div class="line">    private static final long serialVersionUID = 169287984113283421L;</div><div class="line"></div><div class="line">    public static final ReadTimeoutException INSTANCE = new ReadTimeoutException();</div><div class="line"></div><div class="line">    private ReadTimeoutException() &#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里通过private修饰保证了全局只有一个实例</p><p>当我们没有使用到这个类的时候,static变量保证了它是不会被初始化的,这样就保证了延迟加载</p><p>最后我们注意到这个class 使用final修饰的,这样在初始化的时候jvm会默认加上一个同步代码块,保证线程安全</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><ul><li><p>封装一系列可替换的算法家族</p></li><li><p>支持动态选择某个策略</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public EventExecutorChooser newChooser(EventExecutor[] executors) &#123;</div><div class="line">    if (isPowerOfTwo(executors.length)) &#123;</div><div class="line">        return new PowerOfTowEventExecutorChooser(executors);</div><div class="line">    &#125; else &#123;</div><div class="line">        return new GenericEventExecutorChooser(executors);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里根据executors的长度选择不同的chooser策略。</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><ul><li><p>装饰者和被装饰者继承同一个接口</p></li><li><p>装饰者给被装饰者动态修改行为</p></li></ul><p>一般来说使用装饰者模式都会有wrap关键字,Netty也不例外,比如WrappedByteBuf</p><p>在构造这个对象的时候,会传入一个被装饰者ByteBuf,WrappedByteBuf最终会被委托到ByteBuf的方法中。<br>WrappedByteBuf算是ByteBuf的一个装饰基类,基本都是直接调用了ByteBuf的方法,接着ByteBuf有子类UnreleasableByteBuf、AdvancedLeakAwareByteBuf、SimpleLeakAwareByteBuf。</p><p>以SimpleLeakAwareByteBuf为例 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean release() &#123;</div><div class="line">    boolean deallocated =  super.release();</div><div class="line">    if (deallocated) &#123;</div><div class="line">        leak.close();</div><div class="line">    &#125;</div><div class="line">    return deallocated;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先调用了父类的release方法,接下来的代码就是一些装饰的作用,也就是在原有方法上额外做的一些工作。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul><li><p>观察者和被观察者</p></li><li><p>观察者订阅消息,被观察者发布消息</p></li><li><p>订阅消息才可以收到消息</p></li></ul><p>Netty中最常见的观察者模式就是channelFuture.addListener()</p><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><ul><li><p>责任处理器接口</p></li><li><p>创建添加责任处理器接口</p></li><li><p>上下文</p></li><li><p>责任终止</p></li></ul><p>通过上面的描述,大家肯定都能猜到这是pipeline,责任链的每个节点就是hanlder。责任处理则是我们每次复写类所完成的方法,pipeline的头尾有head和tail节点以保证事件传播的终止。ChannelHandlerContext则负责保存上下文信息。</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(8) 性能优化工具类</title>
      <link href="/2018/07/09/Netty-8-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2018/07/09/Netty-8-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Netty中有两个比较常见的优化工具类</p><ul><li>FastThreadLocal</li><li>Recycler对象池</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class FastThreadLocalTest &#123;</div><div class="line">    private static FastThreadLocal&lt;Object&gt; threadLocal = new FastThreadLocal&lt;Object&gt;()&#123;</div><div class="line">        @Override</div><div class="line">        protected Object initialValue() throws Exception &#123;</div><div class="line">            return new Object();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            Object o = threadLocal.get();</div><div class="line">            System.out.println(o);</div><div class="line">        &#125;).start();</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            Object o = threadLocal.get();</div><div class="line">            System.out.println(o);</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过这个简单的test,多次打印object的内存地址,就会发现一个object被多次复用。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="FastThreadLocal机制"><a href="#FastThreadLocal机制" class="headerlink" title="FastThreadLocal机制"></a>FastThreadLocal机制</h2><h3 id="FastThreadLocal创建"><a href="#FastThreadLocal创建" class="headerlink" title="FastThreadLocal创建"></a>FastThreadLocal创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public FastThreadLocal() &#123;</div><div class="line">    index = InternalThreadLocalMap.nextVariableIndex();</div><div class="line">&#125;</div><div class="line">private final int index;</div><div class="line"></div><div class="line">int index = nextIndex.getAndIncrement();</div></pre></td></tr></table></figure><p>FastThreadLocal的初始化只有一行代码,设定了一个final的index值,并且这个值是通过一个原子类进行赋值的。当第一个次初始化时index=0,第二次index=1…通过index便可以唯一标识一个FastThreadLocal。</p><h3 id="FastThreadLocal-get"><a href="#FastThreadLocal-get" class="headerlink" title="FastThreadLocal get()"></a>FastThreadLocal get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">获取ThreadLocalMap</div><div class="line">直接通过索引取出对象</div><div class="line">初始化</div></pre></td></tr></table></figure><p>首先判断当前线程是否是FastThreadLocalThread,如果是则执行fastGet,通常情况下我们初始化一个线程都是使用的普通线程,所以先进入slowGet,slowGet方法就是通过JDK的ThreadLocal获取变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static InternalThreadLocalMap get() &#123;</div><div class="line">    Thread thread = Thread.currentThread();</div><div class="line">    if (thread instanceof FastThreadLocalThread) &#123;</div><div class="line">        return fastGet((FastThreadLocalThread) thread);</div><div class="line">    &#125; else &#123;</div><div class="line">        return slowGet();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果是Netty创建的FastThreadLocalThread,它的内部维护了一个变量InternalThreadLocalMap,这样每次取数据的时候就是去它自己的成员变量里面去取,这也是fast和slow的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private static InternalThreadLocalMap fastGet(FastThreadLocalThread thread) &#123;</div><div class="line">    InternalThreadLocalMap threadLocalMap = thread.threadLocalMap();</div><div class="line">    if (threadLocalMap == null) &#123;</div><div class="line">        thread.setThreadLocalMap(threadLocalMap = new InternalThreadLocalMap());</div><div class="line">    &#125;</div><div class="line">    return threadLocalMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>紧接着,由于每个FastThread都有一个index唯一标识,那么通过这个标识,可以直接拿到当前线程对应的ThreadLocalMap。ThreadLocalMap是一个一维数组,index就是这个一位数组的一个下标,通过这个下表可以拿到这个线程的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object v = threadLocalMap.indexedVariable(index);</div></pre></td></tr></table></figure><h3 id="FastThreadLocal-set"><a href="#FastThreadLocal-set" class="headerlink" title="FastThreadLocal set()"></a>FastThreadLocal set()</h3><p>set的方法比较简单,核心就是下面一句。将index对应的数组下表的值设置为value</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public final void set(InternalThreadLocalMap threadLocalMap, V value) &#123;</div><div class="line">    if (value != InternalThreadLocalMap.UNSET) &#123;</div><div class="line">        if (threadLocalMap.setIndexedVariable(index, value)) &#123;</div><div class="line">            addToVariablesToRemove(threadLocalMap, this);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        remove(threadLocalMap);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="轻量级对象池Recycler"><a href="#轻量级对象池Recycler" class="headerlink" title="轻量级对象池Recycler"></a>轻量级对象池Recycler</h2><p>一个简单的demo看一下Recycler的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class RecyclerTest &#123;</div><div class="line">    private static final Recycler&lt;Users&gt; RECYCLER = new Recycler&lt;Users&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected Users newObject(Handle&lt;Users&gt; handle) &#123;</div><div class="line">            return new Users(handle);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    private static class Users&#123;</div><div class="line">        private final Recycler.Handle&lt;Users&gt; handle;</div><div class="line"></div><div class="line">        public Users(Recycler.Handle&lt;Users&gt; handle) &#123;</div><div class="line">            this.handle = handle;</div><div class="line">        &#125;</div><div class="line">        public void recycle()&#123;</div><div class="line">            handle.recycle(this);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Users u = RECYCLER.get();</div><div class="line">        u.recycle();</div><div class="line">        Users u2 =RECYCLER.get();</div><div class="line">        System.out.println(u==u2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Recycler的作用是每次创建对象的时候不需要每次都new出来,如果Recycler有这个对象,那么就从Recycler里面取出来重用,不需要这个对象的时候,就放回Recycler。</p><p>可以看到每个Recycler都维护了一个Stack对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">private final FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = new FastThreadLocal&lt;Stack&lt;T&gt;&gt;();</div><div class="line"></div><div class="line">    private final FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = new FastThreadLocal&lt;Stack&lt;T&gt;&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        protected Stack&lt;T&gt; initialValue() &#123;</div><div class="line">            return new Stack&lt;T&gt;(Recycler.this, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</div><div class="line">                    ratioMask, maxDelayedQueuesPerThread);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">        Stack(Recycler&lt;T&gt; parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor,</div><div class="line">            int ratioMask, int maxDelayedQueues) &#123;</div><div class="line">            this.parent = parent;</div><div class="line">            this.thread = thread;</div><div class="line">            this.maxCapacity = maxCapacity;</div><div class="line">            availableSharedCapacity = new AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));</div><div class="line">            elements = new DefaultHandle[min(INITIAL_CAPACITY, maxCapacity)];</div><div class="line">            this.ratioMask = ratioMask;</div><div class="line">            this.maxDelayedQueues = maxDelayedQueues;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1ftifxqs1luj30sm0cfq4y.jpg" alt=""></p><p>可以看到stack都与当前线程绑定,每个handle就是我们回收的对象,radioMask控制对象的回收比例,也就是说并不是每个对象都可以回收。maxCapacity表示栈的最大容量。maxDelayedQueues比较特殊,表示有多少个其他线程可以缓存这个对象,当我们在其他线程中需要销毁这个对象时,并不会直接跨线程去销毁,而是把这个对象添加到weakOrderQueue中去做销毁</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public final T get() &#123;</div><div class="line">    if (maxCapacityPerThread == 0) &#123;</div><div class="line">        return newObject((Handle&lt;T&gt;) NOOP_HANDLE);</div><div class="line">    &#125;</div><div class="line">    Stack&lt;T&gt; stack = threadLocal.get();</div><div class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</div><div class="line">    if (handle == null) &#123;</div><div class="line">        handle = stack.newHandle();</div><div class="line">        handle.value = newObject(handle);</div><div class="line">    &#125;</div><div class="line">    return (T) handle.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先判断当前线程maxCapacityPerThread,如果为0,则表示当前线程不能回收对象,所以直接创建返回。</p><p>下面从当前线程中获取stack,接着pop拿出一个对象。如果这个对象为null,表示当前stack为空,new一个对象,然后将对象关联到这个hanlde,返回handle。</p><p>我们可以进入pop()方法,大部分代码都是常规的stack的pop操作,有一个方法scavenge(),这个方法功能是:如果当前栈为空,那么这个对象可能在其他线程中正在等待删除,那么就去这些线程中看一下是否有这种情况,如果有则取消它的销毁状态,将对象拿回来。</p><h3 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h3><p>对象的回收要考虑两种情况</p><ol><li>同线程的对象回收</li><li>异线程的对象回收</li></ol><p>对象的回收最终会调用到stack.push(obj)方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void push(DefaultHandle&lt;?&gt; item) &#123;</div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">        if (thread == currentThread) &#123;</div><div class="line">        // The current Thread is the thread that belongs to the Stack, we can try to push the object now.</div><div class="line">        pushNow(item);</div><div class="line">        &#125; else &#123;</div><div class="line">        // The current Thread is not the one that belongs to the Stack, we need to signal that the push</div><div class="line">        // happens later.</div><div class="line">        pushLater(item, currentThread);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先会去判断当前线程是否是创建这个stack的线程,如果是则执行pushNow</p><blockquote><p>同线程回收</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">private void pushNow(DefaultHandle&lt;?&gt; item) &#123;</div><div class="line">    if ((item.recycleId | item.lastRecycledId) != 0) &#123;</div><div class="line">        throw new IllegalStateException(&quot;recycled already&quot;);</div><div class="line">    &#125;</div><div class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</div><div class="line">    int size = this.size;</div><div class="line">    if (size &gt;= maxCapacity || dropHandle(item)) &#123;</div><div class="line">        // Hit the maximum capacity or should drop - drop the possibly youngest object.</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (size == elements.length) &#123;</div><div class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; 1, maxCapacity));</div><div class="line">    &#125;</div><div class="line">    elements[size] = item;</div><div class="line">    this.size = size + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里将回收的对象设定了一个OWN_THREAD_ID,表示在整个Recycler中是唯一的。接着判断stack是否已经满了,满了则丢弃,由于Recycler并不会一开始就创建maxSize这么大的数组,如果判断当前size不足,则扩容为原来的两倍,将对象放进去。</p><blockquote><p>异线程回收</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) &#123;</div><div class="line">    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</div><div class="line">    WeakOrderQueue queue = delayedRecycled.get(this);</div><div class="line">    if (queue == null) &#123;</div><div class="line">        if (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</div><div class="line">            // Add a dummy queue so we know we should drop the object</div><div class="line">            delayedRecycled.put(this, WeakOrderQueue.DUMMY);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        // Check if we already reached the maximum number of delayed queues and if we can allocate at all.</div><div class="line">        if ((queue = WeakOrderQueue.allocate(this, thread)) == null) &#123;</div><div class="line">            // drop object</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        delayedRecycled.put(this, queue);</div><div class="line">    &#125; else if (queue == WeakOrderQueue.DUMMY) &#123;</div><div class="line">        // drop object</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    queue.add(item);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先获取WeakOrderQueue,这个数据结构就存储了需要释放的在其他线程中存储的对象。如果要回收的对象的线程之前没有绑定过,则创建一个weakOrderQ与之绑定,否则直接将对象插入队列</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>FastThreadLocal主要解决变量的线程隔离 问题。Recycler则是解决频繁创建大对象的问题,减少YoungGC,但是如果对象很小,创建频率不高可能得不偿失</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(7) 编码</title>
      <link href="/2018/07/08/Netty-7-%E7%BC%96%E7%A0%81/"/>
      <url>/2018/07/08/Netty-7-%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个问题</p></blockquote><p>Netty如何将对象编码成字节流,写到socket底层</p><p>这里我们在 服务端添加两个handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">new Encoder();</div><div class="line">new BizHandler();</div><div class="line"></div><div class="line"></div><div class="line">public class BizHandler extends ChannelInboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class="line">        User u = new User(&quot;sc&quot;,12);</div><div class="line">        ctx.channel().writeAndFlush(u);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Encoder extends MessageToByteEncoder&lt;User&gt; &#123;</div><div class="line">    @Override</div><div class="line">    protected void encode(ChannelHandlerContext ctx, User user, ByteBuf out) throws Exception &#123;</div><div class="line">        byte[] bytes = user.getName().getBytes();</div><div class="line">        out.writeInt(4+bytes.length);</div><div class="line">        out.writeInt(user.getAge());</div><div class="line">        out.writeBytes(bytes);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的Encode方法使用了如下的编码方式:第一个字段为正整数长度,在java平台上统一为4字节,第二个Age正整数,为4个字节,Name是可变长度的string类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  -------------------------</div><div class="line"> * | Length |   Age |    Name|</div><div class="line"> * ---------------------------</div><div class="line"> * |    4   |   4   |    ??   |</div><div class="line"> * --------------------------</div><div class="line"> */</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="writeAndFlush抽象步骤"><a href="#writeAndFlush抽象步骤" class="headerlink" title="writeAndFlush抽象步骤"></a>writeAndFlush抽象步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">从tail节点向前传播</div><div class="line">逐个调用channelHandler的wirite方法 </div><div class="line">逐个调用channelHandler的flush方法</div></pre></td></tr></table></figure><p>首先进入writeAndFlush方法,定位到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail.writeAndFlush(msg);</div></pre></td></tr></table></figure><p>可见这个方法是从pipeLine的tail节点开始传播,接着调用write方法,判断该线程是否是eventLoop里面的线程,如果是则执行,否则封装成task扔进队列中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">executor.inEventLoop()</div></pre></td></tr></table></figure><p>接着会调用,也就是说如果我们自定义的handler实现了write方法,则会进行调用,但是我们在encoder类中实现的是一个encode方法。这时因为Encoder继承自MessageToByteEncoder,而父类的write方法调用了encode方法,所以我们只需要重写encode方法即可。最终会传播到头结点的write方法:unsafe.write(msg, promise);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((ChannelOutboundHandler) handler()).write(this, msg, promise);</div></pre></td></tr></table></figure><p>接着会进行flush操作,因为一般我们自定义的handler很少会去复写handler方法,所以大部分情况下它会一直传播到头结点。并最终调用unsafe.flush();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((ChannelOutboundHandler) handler()).flush(this);</div></pre></td></tr></table></figure><h2 id="HeadContext-write"><a href="#HeadContext-write" class="headerlink" title="HeadContext.write()"></a>HeadContext.write()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">direct化byteBuf</div><div class="line">插入写队列</div><div class="line">设置写状态</div></pre></td></tr></table></figure><p>首先对于传入的msg调用此方法,这个方法首先会判断是否是ByteBuf,如果是directBuffer则直接返回,如果是heapBuff则包装成DirectBuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">msg = filterOutboundMessage(msg);</div><div class="line"></div><div class="line">if (msg instanceof ByteBuf) &#123;</div><div class="line">            ByteBuf buf = (ByteBuf) msg;</div><div class="line">            if (buf.isDirect()) &#123;</div><div class="line">                return msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return newDirectBuffer(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着将buf加入到写队列中,这里可以看到是三个Entry:tailEntry/flushedEntry/unflushedEntry,可以理解为三个指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">outboundBuffer.addMessage(msg, size, promise);</div><div class="line"></div><div class="line"></div><div class="line">public void addMessage(Object msg, int size, ChannelPromise promise) &#123;</div><div class="line">        Entry entry = Entry.newInstance(msg, size, total(msg), promise);</div><div class="line">        if (tailEntry == null) &#123;</div><div class="line">            flushedEntry = null;</div><div class="line">            tailEntry = entry;</div><div class="line">        &#125; else &#123;</div><div class="line">            Entry tail = tailEntry;</div><div class="line">            tail.next = entry;</div><div class="line">            tailEntry = entry;</div><div class="line">        &#125;</div><div class="line">        if (unflushedEntry == null) &#123;</div><div class="line">            unflushedEntry = entry;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        incrementPendingOutboundBytes(size, false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>三个指针的排列状况如下:把队列分为了两个部分,前面一个部分表示已经flush过得数据,后面一部分表示没有flush过得数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Entry(flushedEntry) --&gt; ... Entry(unflushedEntry) --&gt; ... Entry(tailEntry)</div></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ft2t54z5qpj310a0i240a.jpg" alt=""></p><p>最后是设置写状态,每次添加数据之后,Netty都要统计一个有多少数据需要写出。这里会比较一个buffer水位值getWriteBufferHighWaterMark(),默认是64K。如果超过这个值,就会在pipeline中传播一个无法写入的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void incrementPendingOutboundBytes(long size, boolean invokeLater) &#123;</div><div class="line">    if (size == 0) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);</div><div class="line">    if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;</div><div class="line">        setUnwritable(invokeLater);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="HeadContext-flush"><a href="#HeadContext-flush" class="headerlink" title="HeadContext.flush()"></a>HeadContext.flush()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">添加刷新标志并设置写状态</div><div class="line">遍历buffer队列,过滤ByteBuf</div><div class="line">调用jdk的api写入</div></pre></td></tr></table></figure><p>进入到addFlush方法,首先将当前指向为flushedEntry标记为已刷新。接着decrementPendingOutboundBytes会减去flush的数据的大小,直到空间小于默认的32K时,pipeline会传播一个可写的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Entry entry = unflushedEntry;</div><div class="line">        if (entry != null) &#123;</div><div class="line">            if (flushedEntry == null) &#123;</div><div class="line">                flushedEntry = entry;</div><div class="line">            &#125;</div><div class="line">            do &#123;</div><div class="line">                flushed++;</div><div class="line">                if (!entry.promise.setUncancellable()) &#123;</div><div class="line">                    int pending = entry.cancel();</div><div class="line">                    decrementPendingOutboundBytes(pending, false, true);</div><div class="line">                &#125;</div><div class="line">                entry = entry.next;</div><div class="line">            &#125; while (entry != null);</div><div class="line">            unflushedEntry = null;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>接着进入flsuh0的doWrite方法,通过一个for循环,通过in.current()每次拿到一个flushedEntry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object msg = in.current();</div></pre></td></tr></table></figure><p>这里Netty获取一个自旋锁,默认为16.通过自旋锁提高内存的使用率并提高吞吐量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">writeSpinCount = config().getWriteSpinCount();</div></pre></td></tr></table></figure><p>接着将Netty的ByteBuf塞进jdk的ByteBuffer里面,调用JDK的write方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ByteBuffer tmpBuf;</div><div class="line">        if (internal) &#123;</div><div class="line">            tmpBuf = internalNioBuffer();</div><div class="line">        &#125; else &#123;</div><div class="line">            tmpBuf = memory.duplicate();</div><div class="line">        &#125;</div><div class="line">        index = idx(index);</div><div class="line">        tmpBuf.clear().position(index).limit(index + length);</div><div class="line">        return out.write(tmpBuf);</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(6) 解码</title>
      <link href="/2018/07/07/Netty-6-%E8%A7%A3%E7%A0%81/"/>
      <url>/2018/07/07/Netty-6-%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>所谓解码,就是讲二进制数据流解析为指定协议的数据包,之后交给业务逻辑进行处理。</p><blockquote><p>两个问题</p></blockquote><p>解码器抽象的解码过程</p><p>Netty有哪些开箱即用的解码器</p><h2 id="基类ByteToMessageDecoder"><a href="#基类ByteToMessageDecoder" class="headerlink" title="基类ByteToMessageDecoder"></a>基类ByteToMessageDecoder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">累加字节流</div><div class="line">调用子类的decode方法进行解析</div><div class="line">将解析的ByteBuf向下传播</div></pre></td></tr></table></figure><p>进入channelRead方法,这里将传入的数据包装为bytebuf然后交给cumulator,将数据进行累加。然后调用callDecode方法,利用不同的子类实现进行解析,将解析后的结果放在List<object> out中</object></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</div><div class="line"></div><div class="line">callDecode(ctx, cumulation, out);</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="基于固定长度解码器"><a href="#基于固定长度解码器" class="headerlink" title="基于固定长度解码器"></a>基于固定长度解码器</h2><p>FixedLengthFrameDecoder是Netty中最为简单的一个解码器,他只有一个成员变量frameLength,这个解码器只能根据指定的长度来对数据进行解码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</div><div class="line">    Object decoded = decode(ctx, in);</div><div class="line">    if (decoded != null) &#123;</div><div class="line">        out.add(decoded);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dprotected Object decode(</div><div class="line">    ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;</div><div class="line">    if (in.readableBytes() &lt; frameLength) &#123;</div><div class="line">        return null;</div><div class="line">    &#125; else &#123;</div><div class="line">        return in.readRetainedSlice(frameLength);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的in就是父类中的累加器,这里的decode方法判断如果累加器传入的数据长度小于frameLength,则不进行处理,否则调用readRetainedSlice将数据切分,解析之后将对象添加到list中。</p><h2 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h2><p>LineBasedFrameDecoder是指以\r\n或者\n结尾的数据为结束符进行数据解析。</p><p>首先从bytebuf中找到标志换行的字符标记为eol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final int eol = findEndOfLine(buffer);</div></pre></td></tr></table></figure><p>接下来判断是否是discarding的状态,因为LineBasedFrameDecoder内部有最大长度的限制,所以如果超过了最大长度,就会丢弃消息,discarding为True,这里默认为False。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft1nfn71iej318y0e6gn4.jpg" alt=""></p><p>这里会进行一次判断,如果当前读取到一行的数据超过了最大长度,那么readIndex会指向分隔符的下一个字符,也就是说,当超过了最大长度,Netty会将这部分数据完全抛弃。当没有找到换行符,就把当前取到的数据丢弃到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (length &gt; maxLength) &#123;</div><div class="line">    buffer.readerIndex(eol + delimLength);</div><div class="line">    fail(ctx, length);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着看看丢弃模式处理逻辑,如果截取到了换行符,那么直接将这一段丢弃,然后将丢弃模式设置为false,那么下一次处理的时候就会进入上面的处理逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if (eol &gt;= 0) &#123;</div><div class="line">    final int length = discardedBytes + eol - buffer.readerIndex();</div><div class="line">    final int delimLength = buffer.getByte(eol) == &apos;\r&apos;? 2 : 1;</div><div class="line">    buffer.readerIndex(eol + delimLength);</div><div class="line">    discardedBytes = 0;</div><div class="line">    discarding = false;</div><div class="line">    if (!failFast) &#123;</div><div class="line">        fail(ctx, length);</div><div class="line">    &#125;</div><div class="line">&#125; else &#123;</div><div class="line">    discardedBytes += buffer.readableBytes();</div><div class="line">    buffer.readerIndex(buffer.writerIndex());</div><div class="line">    &#125;</div><div class="line">return null;</div></pre></td></tr></table></figure><h2 id="分隔符解码器-DelimiterBasedFrameDecoder"><a href="#分隔符解码器-DelimiterBasedFrameDecoder" class="headerlink" title="分隔符解码器 DelimiterBasedFrameDecoder"></a>分隔符解码器 DelimiterBasedFrameDecoder</h2><p>分隔符处理器会要求传递两个参数,第一个是最大处理的数据长度,第二就是分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (lineBasedDecoder != null) &#123;</div><div class="line">    return lineBasedDecoder.decode(ctx, buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先会判断分割符是否是行分隔符,如果是则交给lineBasedDecoder去处理。</p><p>由于netty支持传递多个分割符进行分割,所以接下来Netty遍历分隔符集合,然后找出数据量最少的那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (ByteBuf delim: delimiters) &#123;</div><div class="line">    int frameLength = indexOf(buffer, delim);</div><div class="line">    if (frameLength &gt;= 0 &amp;&amp; frameLength &lt; minFrameLength) &#123;</div><div class="line">        minFrameLength = frameLength;</div><div class="line">        minDelim = delim;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是先找到readIndex到A的数据</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1ft1r40zgemj316y0eo0tz.jpg" alt=""></p><p>接下来进行解码,首先还是会对数据长度和maxLength以及丢弃策略进行判断,丢弃不合法的数据包,逻辑上与行分隔符很像,代码也比较清晰,所以就不一个一个分析了。</p><h2 id="基于长度域解码器-LengthFieldBasedFrameDecoder"><a href="#基于长度域解码器-LengthFieldBasedFrameDecoder" class="headerlink" title="基于长度域解码器 LengthFieldBasedFrameDecoder"></a>基于长度域解码器 LengthFieldBasedFrameDecoder</h2><p>LengthFieldBasedFrameDecoder有两个最重要的参数,lengthFieldOffset表示数据的长度数据从第几个字节开始,lengthFieldLength表示长度数据占了几个字节</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft1rce0xojj318q0i4tb2.jpg" alt=""></p><p>除此之外,长度解码器还有两个重要的参数lengthAdjustment和initialBytesToStrip,下面的例子展示了他们组合起来的作用</p><blockquote><p>1  这是一种最简单的情况,Length字段从0开始占用了2个字节</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lengthFieldOffset  = 0</div><div class="line">lengthFieldLength  = 2</div><div class="line">lengthAdjustment    = 0</div><div class="line">initialBytesToStrip = 0</div><div class="line"></div><div class="line"> * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)</div><div class="line"> * +--------+----------------+      +--------+----------------+</div><div class="line"> * | Length | Actual Content |-----&gt;| Length | Actual Content |</div><div class="line"> * | 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |</div><div class="line"> * +--------+----------------+      +--------+----------------+</div></pre></td></tr></table></figure><blockquote><p>2  这个例子显示了initialBytesToStrip的作用,就是跳过从头开始的N个字节,这里我们一般可以设置一个数值,将长度字段过滤掉,将数据包交给业务逻辑处理即可。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lengthFieldOffset  = 0</div><div class="line">lengthFieldLength  = 2</div><div class="line">lengthAdjustment    = 0</div><div class="line">initialBytesToStrip = 2</div><div class="line"></div><div class="line"> * BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)</div><div class="line"> * +--------+----------------+      +----------------+</div><div class="line"> * | Length | Actual Content |-----&gt;| Actual Content |</div><div class="line"> * | 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |</div><div class="line"> * +--------+----------------+      +----------------+</div></pre></td></tr></table></figure><blockquote><p>3   在大多数情况下,Length字段的含义是数据段的长度,但是有的协议长度字段是Length字段的长度+数据段的长度,那么这时我们可以调整lengthAdjustment为正数或者负数,表示增加或减少N个长度,用来减去Length字段所占用的长度。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lengthFieldOffset  = 0</div><div class="line">lengthFieldLength  = 2</div><div class="line">lengthAdjustment    = -2</div><div class="line">initialBytesToStrip = 0</div><div class="line"></div><div class="line"> * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)</div><div class="line"> * +--------+----------------+      +--------+----------------+</div><div class="line"> * | Length | Actual Content |-----&gt;| Length | Actual Content |</div><div class="line"> * | 0x000E | &quot;HELLO, WORLD&quot; |      | 0x000E | &quot;HELLO, WORLD&quot; |</div><div class="line"> * +--------+----------------+      +--------+----------------+</div></pre></td></tr></table></figure><p>源码中的decode方法比较复杂,大概可分为三个步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">计算需要抽取的数据包长度</div><div class="line">跳过字节处理逻辑</div><div class="line">丢弃模式下的处理</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(5) ByteBuf</title>
      <link href="/2018/07/06/Netty-5-ByteBuf/"/>
      <url>/2018/07/06/Netty-5-ByteBuf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个问题</p></blockquote><ol><li>内存的类别有哪些</li><li>如何减少多线程内存分配的竞争</li><li>不同大小的内存是如何进行分配的</li></ol><h2 id="内存与内存管理器的抽象"><a href="#内存与内存管理器的抽象" class="headerlink" title="内存与内存管理器的抽象"></a>内存与内存管理器的抽象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">* &lt;pre&gt;</div><div class="line">*      +-------------------+------------------+------------------+</div><div class="line">*      | discardable bytes |  readable bytes  |  writable bytes  |</div><div class="line">*      |                   |     (CONTENT)    |                  |</div><div class="line">*      +-------------------+------------------+------------------+</div><div class="line">*      |                   |                  |                  |</div><div class="line">*      0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</div><div class="line">* &lt;/pre&gt;</div></pre></td></tr></table></figure><p>byteBuf有三个非常重要的指针,readerIndex/writerIndex/capacity。0到readerIndex是已经读完,可以丢弃的数据,readerIndex和writerIndex之间是可读区域,writerIndex到capacity是可写区域。</p><h2 id="不同大小和不同类型的内存分配策略"><a href="#不同大小和不同类型的内存分配策略" class="headerlink" title="不同大小和不同类型的内存分配策略"></a>不同大小和不同类型的内存分配策略</h2><p>Netty中对ByteBuf进行分配的基类是ByteBufAllocator,提供了一些内存分配的抽象方法。在注释中可以看到关于直接内存和堆内存的不同分配。</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180706153084075739585.png" alt="20180706153084075739585.png"></p><p>可以看到ByteBufAllocator是一个最顶层的抽象,AbstractByteBufAllocator实现了接口的大部分功能,然后最终暴露出两个方法(new DirectByteBuf和new HeapByteBuf)。这两个方法就交给子类pool和unpool,创建堆内和堆外内存的实现。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="UnpooledByteBufAllocator"><a href="#UnpooledByteBufAllocator" class="headerlink" title="UnpooledByteBufAllocator"></a>UnpooledByteBufAllocator</h3><blockquote><p>堆内分配</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected ByteBuf newHeapBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class="line">    return PlatformDependent.hasUnsafe() ? new UnpooledUnsafeHeapByteBuf(this, initialCapacity, maxCapacity)</div><div class="line">            : new UnpooledHeapByteBuf(this, initialCapacity, maxCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先看堆内存的分配,判断JDK是否有unsafe对象,这是由JDK平台决定的。如果有则new一个unpool/unsafe/heap三维度的bytebuf,否则创建一个unpool/safe/heap的bytebuff。这两个类的初始化都是调用了相同的函数,那么这个safe是如何体现的。</p><p>当使用UnpooledUnsafeHeapByteBuf时,调用getByte方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static byte getByte(byte[] data, int index) &#123;</div><div class="line">    return UNSAFE.getByte(data, BYTE_ARRAY_BASE_OFFSET + index);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>UnpooledHeapByteBuf的getByte方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static byte getByte(byte[] memory, int index) &#123;</div><div class="line">    return memory[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到两者的区别在于获取字节时unsafe调用的是jdk底层的api,通过指针获取数据。而safe则是通过数组以及下表获取数据。理论上来说,unsafe的方式会更快。</p><blockquote><p>堆外分配</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class="line">    ByteBuf buf = PlatformDependent.hasUnsafe() ?</div><div class="line">            UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :</div><div class="line">            new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class="line"></div><div class="line">    return disableLeakDetector ? buf : toLeakAwareBuffer(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样是根据JDK的api来区分safe or  unsafe。</p><p>首先来看UnpooledDirectByteBuf,源码中传入了一个参数</p><p>setByteBuffer(ByteBuffer.allocateDirect(initialCapacity));</p><p>这里就是调用了JDK底层的ByteBuffer并分配堆外内存。下面看UnpooledUnsafeDirectByteBuf,跟进到底层后发现有这样的一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">final void setByteBuffer(ByteBuffer buffer, boolean tryFree) &#123;</div><div class="line">    ...</div><div class="line">    memoryAddress = PlatformDependent.directBufferAddress(buffer);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里通过unsafe,计算出byteBuf在内存中的地址然后保存。这样做的目的就是调用getByte()时可以直接使用这个地址加上一个偏移量,获取数据。而通过safe的方式getByte,就是传递一个index参数,从字节数组获取数据。</p><p>总结来说safe和unsafe的区别在于一个直接操作内存地址,一个操作数组。</p><h3 id="PooledByteBufAllocator"><a href="#PooledByteBufAllocator" class="headerlink" title="PooledByteBufAllocator"></a>PooledByteBufAllocator</h3><p>进入PooledByteBufAllocator.newHeapBuffer和newDirectBuffer,一个很明显的特征就是出现了cache,两个方法很相似,所以就拿 newDirectBuffer做一个简单的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class="line">    PoolThreadCache cache = threadCache.get();</div><div class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</div><div class="line"></div><div class="line">    ByteBuf buf;</div><div class="line">    if (directArena != null) &#123;</div><div class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (PlatformDependent.hasUnsafe()) &#123;</div><div class="line">            buf = UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class="line">        &#125; else &#123;</div><div class="line">            buf = new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return toLeakAwareBuffer(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大概梳理一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">拿到线程局部缓存 PoolThreadCache</div><div class="line">在线程局部的Area上分配内存</div></pre></td></tr></table></figure><p>在初始化PoolThreadCache,可以看到内部初始化了两个PoolArena,一个用于分配堆内存,一个用于分配堆外内存,并保存为成员变量。<br>heapArena和directArena都是在PooledByteBufAllocator初始化的时候进行的初始化,两个区域都是Arena类型的数组,默认情况下回初始化cpu核数<em>2的大小。这里其实是因为NioEventLoop初始化的时候默认是cpu核数</em>2,这样做就可以默认情况下每个线程有一个Arena数组,不会产生竞争。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protected synchronized PoolThreadCache initialValue() &#123;</div><div class="line">    final PoolArena&lt;byte[]&gt; heapArena = leastUsedArena(heapArenas);</div><div class="line">    final PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</div><div class="line"></div><div class="line">    return new PoolThreadCache(</div><div class="line">            heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</div><div class="line">            DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除此之外还可以看到 tinyCacheSize, smallCacheSize, normalCacheSize这三个参数。这三个参数可以分别去初始化对应规格的缓存。</p><h4 id="directArena分配direct内存流程"><a href="#directArena分配direct内存流程" class="headerlink" title="directArena分配direct内存流程"></a>directArena分配direct内存流程</h4><ul><li>从对象池拿到PooledByteBuf进行复用</li></ul><p>入口方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">buf = directArena.allocate(cache, initialCapacity, maxCapacity);</div></pre></td></tr></table></figure><p>最终定位到PoolArena.allocate方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">        protected PooledByteBuf&lt;ByteBuffer&gt; newByteBuf(int maxCapacity) &#123;</div><div class="line">            if (HAS_UNSAFE) &#123;</div><div class="line">                return PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</div><div class="line">            &#125; else &#123;</div><div class="line">                return PooledDirectByteBuf.newInstance(maxCapacity);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">static PooledUnsafeDirectByteBuf newInstance(int maxCapacity) &#123;</div><div class="line">        PooledUnsafeDirectByteBuf buf = RECYCLER.get();</div><div class="line">        buf.reuse(maxCapacity);</div><div class="line">        return buf;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>首先会newByteBuf,由于默认情况下HAS_UNSAFE为True,然后通过RECYCLER获取,从名字可以看出RECYCLER是一个带有回收性质的对象池。如果有则拿出一个,否则创建。然后调用reuse方法,将buf的状态初始化。至此拿到一个干净的Bytebuf。</p><p>之后会进入一个非常长的allocate方法,也就是主要的内存分配逻辑,首先会尝试从在缓存buf中分配,如果分配失败,则直接到内存上去分配,并且对于不同大小的内存,分配逻辑是不一样的。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft0c83ojmdj318o0b8mz5.jpg" alt=""></p><p>可以看到大于16M,就到内存堆上去分配,这是因为系统内存申请是以chunk为单位,后续所有的内存分配都是在chunk里面做操作。比如现在我需要一个1MB的空间,那么我首先到操作系统申请1个chunk也就是16MB,然后取1m分配。8K则是操作系统的一个page,也就是把chunk切分成2048个page。0~8K的空间也有个名字,叫做subpage</p><h4 id="命中缓存的逻辑"><a href="#命中缓存的逻辑" class="headerlink" title="命中缓存的逻辑"></a>命中缓存的逻辑</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft0cfcdn0xj31be0o2q6j.jpg" alt=""></p><p>与缓存命中逻辑相关的数据结构就是MemeoryRegionCache</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">MemoryRegionCache(int size, SizeClass sizeClass) &#123;</div><div class="line">    this.size = MathUtil.safeFindNextPositivePowerOfTwo(size);</div><div class="line">    queue = PlatformDependent.newFixedMpscQueue(this.size);</div><div class="line">    this.sizeClass = sizeClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft0da3sdg2j31b60noaep.jpg" alt=""></p><p>关于MemoryRegionCache结构其实相当复杂,对于sizeClass{tiny,small,normal}又进行了细分。比如对于tiny一个512B的空间,每8个Byte又分了一个小空间,每个小空间组成一个queue,这样将tiny类型就凑成了一个chunk,当需要分配一个空间时,去拿一个最接近的空间即可。small和normal也是同理。</p><p>以tiny为例可以看源码:tinyCacheSize默认是512B,第二个值默认为512/16=32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tinySubPageHeapCaches = createSubPageCaches(tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</div></pre></td></tr></table></figure><p>这里首先创建了一个MemoryRegionCache[32]的数组,然后对于每个数组在进入循环,创建subpage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">private static &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createSubPageCaches(</div><div class="line">        int cacheSize, int numCaches, SizeClass sizeClass) &#123;</div><div class="line">    if (cacheSize &gt; 0) &#123;</div><div class="line">        MemoryRegionCache&lt;T&gt;[] cache = new MemoryRegionCache[numCaches];</div><div class="line">        for (int i = 0; i &lt; cache.length; i++) &#123;</div><div class="line">            cache[i] = new SubPageMemoryRegionCache&lt;T&gt;(cacheSize, sizeClass);</div><div class="line">        &#125;</div><div class="line">        return cache;</div><div class="line">    &#125; else &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面进入allocate代码的逻辑,首先会进行代码规格化。具体做法就是若申请分配的长度属于tiny,则以16为倍数进行自增。small和normal则是2的幂次方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final int normCapacity = normalizeCapacity(reqCapacity);</div></pre></td></tr></table></figure><p>接着就会找到对应size的MemoryRegionCache,如果大小是16B则除以16=1,到第一个queue中取,32则到第二个queue,以此类推。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int tinyIdx(int normCapacity) &#123;</div><div class="line">    return normCapacity &gt;&gt;&gt; 4;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着就会从queue从弹出一个entry给ByteBuf进行初始化,然后将弹出的entry扔到对象池进行复用。如果这里对象不进行复用,后面有个能被gc掉,这也是netty在最大化复用对象,减少对象的创建和销毁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public final boolean allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity) &#123;</div><div class="line">            Entry&lt;T&gt; entry = queue.poll();</div><div class="line">            if (entry == null) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            initBuf(entry.chunk, entry.handle, buf, reqCapacity);</div><div class="line">            entry.recycle();</div><div class="line"></div><div class="line">            // allocations is not thread-safe which is fine as this is only called from the same thread all time.</div><div class="line">            ++ allocations;</div><div class="line">            return true;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><h4 id="arena、chunk、page、subpage"><a href="#arena、chunk、page、subpage" class="headerlink" title="arena、chunk、page、subpage"></a>arena、chunk、page、subpage</h4><p>这是Netty内存分配过程中非常重要的几个概念。</p><ul><li>arena</li></ul><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1ft1eqe9s69j30ti0omac4.jpg" alt=""></p><p>在每个线程去分配对应的内存的时候,首先会通过threadLocal的方式,获取到PoolThreadCache。通过PoolThreadCache.allocate方法去分配内存,这个PoolThreadCache分为两部分:一部分是不同规格大小的cache(MemoryRegionCache),另一部分就是arena(PoolArena),区别在于缓存是直接缓存了一块内存，Arena是直接开辟了一块内存。</p><ul><li>chunk</li></ul><p>arena的数据结构如图所示</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1ft1evz7mk0j31cq0r0q90.jpg" alt=""></p><p>内部是多个chunklist,每个chunklist以双向链表的方式进行连接。chunklist的节点是chunk,也就是向操作系统申请的最小内存空间–16M。这里的链表结构是因为Netty会实时进行每个chunk的使用情况,按照内存使用率分别组成chunklist,方便以后进行分配能够快速找到一个合适的内存块。这里初始化的时候可以看到,第一个参数就是list的名字,第二个参数是最小使用率,第三个参数是最大使用率 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private final PoolChunkList&lt;T&gt; q050;</div><div class="line">private final PoolChunkList&lt;T&gt; q025;</div><div class="line">private final PoolChunkList&lt;T&gt; q000;</div><div class="line">private final PoolChunkList&lt;T&gt; qInit;</div><div class="line">private final PoolChunkList&lt;T&gt; q075;</div><div class="line">private final PoolChunkList&lt;T&gt; q100;</div><div class="line"></div><div class="line">q100 = new PoolChunkList&lt;T&gt;(null, 100, Integer.MAX_VALUE, chunkSize);</div><div class="line">q075 = new PoolChunkList&lt;T&gt;(q100, 75, 100, chunkSize);</div><div class="line">q050 = new PoolChunkList&lt;T&gt;(q075, 50, 100, chunkSize);</div><div class="line">q025 = new PoolChunkList&lt;T&gt;(q050, 25, 75, chunkSize);</div><div class="line">q000 = new PoolChunkList&lt;T&gt;(q025, 1, 50, chunkSize);</div><div class="line">qInit = new PoolChunkList&lt;T&gt;(q000, Integer.MIN_VALUE, 25, chunkSize);</div></pre></td></tr></table></figure><ul><li>page</li></ul><p>由于内存申请时很少有需要16M内存的时候,那么把16M进行切分,分为一个一个8K的页,则能更好的利用空间。Netty认为8K还是太大,于是继续细分了page,分为4个2K的subpage</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft1f66pr7uj31e00omgou.jpg" alt=""></p><p>这里就可以知道Netty的内存分配策略,如果申请的空间大于8K,则按照page进行分配,如果申请的空间小于8K,则找到一个page,切分为多个subpage,使用subpage进行分配。</p><h4 id="page级别的内存分配-allocateNormal"><a href="#page级别的内存分配-allocateNormal" class="headerlink" title="page级别的内存分配 allocateNormal"></a>page级别的内存分配 allocateNormal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private synchronized void allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class="line">    if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</div><div class="line">        q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</div><div class="line">        q075.allocate(buf, reqCapacity, normCapacity)) &#123;</div><div class="line">        ++allocationsNormal;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // Add a new chunk.</div><div class="line">    PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</div><div class="line">    long handle = c.allocate(normCapacity);</div><div class="line">    ++allocationsNormal;</div><div class="line">    assert handle &gt; 0;</div><div class="line">    c.initBuf(buf, handle, reqCapacity);</div><div class="line">    qInit.add(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这部分代码大致有两层。首先尝试在现有的chunk上进行分配,也就是if代码块的内容,首次进入的话都没有初始化。所以进入下面新建chunk的逻辑。新建chunk之后进行分配内存,返回一个handle指向chunk中的一块连续内存区域。最后初始化ByteBuf</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1ft1fmwjhqlj31bw0pwn17.jpg" alt=""></p><p>这里Netty快速定位一个page使用了一种完全二叉树的结构,可以将查找一个page的时间复杂度稳定在logn。</p><h4 id="subpage级别的内存分配-allocateTiny"><a href="#subpage级别的内存分配-allocateTiny" class="headerlink" title="subpage级别的内存分配 allocateTiny"></a>subpage级别的内存分配 allocateTiny</h4><ul><li>定位一个page对象</li><li>创建一个subpage</li><li>初始化bytebuf</li></ul><p>这里subpage的大小不一定是2K,这与需要分配的空间大小有关。例如在初始化时,若申请1K的空间,则会将page的8K分为8份1K的空间。</p><h2 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h2><p>通过调用bytebuf.realease()方法可以将内存释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected final void deallocate() &#123;</div><div class="line">    if (handle &gt;= 0) &#123;</div><div class="line">        final long handle = this.handle;</div><div class="line">        this.handle = -1;</div><div class="line">        memory = null;</div><div class="line">        chunk.arena.free(chunk, handle, maxLength, cache);</div><div class="line">        recycle();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里首先将这块内存的handle标记为-1,表示无法索引到这块区域,将memeory置为null。接着free()和recycle()做了以下几件事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">连续的内存区段加到缓存</div><div class="line">标记内存区段为未使用</div><div class="line">ByteBuf加入对象池</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ByteBuf的分类可以按照三个维度来分,堆内堆外、safe和unsafe、pool和unpool</p><p>direct和heap的区别在于,堆内是基于字节数组进行分配,堆外是基于JDK的API进行分配。Unsafe是基于JDK的unsafe对象对物理内存地址进行读写,非unsafe是通过jdk的api进行读写。unpool每次直接申请物理内存,而pool则是预先分配好内存,需要使用的时候根据算法取出一块连续空间。</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(4) Pipeline</title>
      <link href="/2018/07/04/Netty-4-Pipeline/"/>
      <url>/2018/07/04/Netty-4-Pipeline/</url>
      
        <content type="html"><![CDATA[<blockquote><p>三个问题</p></blockquote><ul><li>Netty如何判断ChannelHandler类型(in  out)</li><li>ChannelHandler添加应按照什么样的顺序</li><li>用户手动触发事件传播,不同的触发方式有什么区别</li></ul><h2 id="Pipeline的初始化"><a href="#Pipeline的初始化" class="headerlink" title="Pipeline的初始化"></a>Pipeline的初始化</h2><p>在之前的代码分析中,不管服务端还是客户端,最后都会进入AbstractChannel,创建PipeLine</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">protected AbstractChannel(Channel parent, ChannelId id) &#123;</div><div class="line">    this.parent = parent;</div><div class="line">    this.id = id;</div><div class="line">    unsafe = newUnsafe();</div><div class="line">    pipeline = newChannelPipeline();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="添加或删除ChannelHandler"><a href="#添加或删除ChannelHandler" class="headerlink" title="添加或删除ChannelHandler"></a>添加或删除ChannelHandler</h2><p>在我们自己编写的代码中,大多会写到ch.pipeline().addLast(xxx),此方法就是添加PipeLine的入口。最终跟进到ChannelPipeline.addLast()</p><p>默认情况下回创建头尾两个节点,并连接为双向列表。这两个节点都是ChannelHandlerContext数据结构,所以pipeline中的节点都是ChannelHandlerContext。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">protected DefaultChannelPipeline(Channel channel) &#123;</div><div class="line">    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class="line">    succeededFuture = new SucceededChannelFuture(channel, null);</div><div class="line">    voidPromise =  new VoidChannelPromise(channel, true);</div><div class="line">    tail = new TailContext(this);</div><div class="line">    head = new HeadContext(this);</div><div class="line">    head.next = tail;</div><div class="line">    tail.prev = head;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着看一下头结点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HeadContext(DefaultChannelPipeline pipeline) &#123;</div><div class="line">    super(pipeline, null, HEAD_NAME, false, true);</div><div class="line">    unsafe = pipeline.channel().unsafe();</div><div class="line">    setAddComplete();</div><div class="line">&#125;</div><div class="line">TailContext(DefaultChannelPipeline pipeline) &#123;</div><div class="line">    super(pipeline, null, TAIL_NAME, true, false);</div><div class="line">    setAddComplete();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里第三个和第四个参数分别是inbound和outbound。与我们直觉相反,head节点是outbound而tail是inbound。另外一个不同在于,tail节点内部的操作一般都为空,而head节点都会原模原样向后传播。并且读写操作会调用unsafe进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">判断是否重复添加</div><div class="line">创建节点并添加到链表</div><div class="line">回调添加完成事件</div></pre></td></tr></table></figure><p>在addLast的具体过程中,可以看到节点实际上是添加到了尾节点的前一个节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void addLast0(AbstractChannelHandlerContext newCtx) &#123;</div><div class="line">    AbstractChannelHandlerContext prev = tail.prev;</div><div class="line">    newCtx.prev = prev;</div><div class="line">    newCtx.next = tail;</div><div class="line">    prev.next = newCtx;</div><div class="line">    tail.prev = newCtx;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>添加handler是一个非常常见的场景,但是删除一个handler却很少见，删除handler主要用在权限校验的场景上。</p><p>我们可以自己实现一个AuthHandler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class AuthHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;</div><div class="line">    @Override</div><div class="line">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</div><div class="line">        if(isPass(msg))&#123;</div><div class="line">            ctx.pipeline().remove(this);</div><div class="line">        &#125;else &#123;</div><div class="line">            ctx.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    private boolean isPass(ByteBuf pwd)&#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里如果通过权限校验就删除这个handler,没有通过就关闭连接,以此实现一个高效的权限校验。</p><p>remove的操作也是一个标准的链表删除方式,删除掉之后会进行用户回调,完成删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void remove0(AbstractChannelHandlerContext ctx) &#123;</div><div class="line">    AbstractChannelHandlerContext prev = ctx.prev;</div><div class="line">    AbstractChannelHandlerContext next = ctx.next;</div><div class="line">    prev.next = next;</div><div class="line">    next.prev = prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="InBound事件传播"><a href="#InBound事件传播" class="headerlink" title="InBound事件传播"></a>InBound事件传播</h2><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180705153077643452289.png" alt="20180705153077643452289.png"></p><p>首先看一下顶级的接口ChannelHanlder有哪些功能,包括channel添加,删除,抛出异常方法以及一个Sharable注解,表示这个handler可以被多个channel共享。</p><p>ChannelInboundHandler继承自ChannelHanlder,并添加了一些register,active,read这样一些事件,其中主要的是channelRead方法。</p><p>添加三个自定义的handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">socketChannel.pipeline().addLast(new HandlerA());</div><div class="line">socketChannel.pipeline().addLast(new HandlerB());</div><div class="line">socketChannel.pipeline().addLast(new HandlerC());</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">public class HandlerA extends ChannelInboundHandlerAdapter&#123;</div><div class="line">    @Override</div><div class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class="line">        System.out.println(&quot;A &quot;+msg);</div><div class="line">        ctx.fireChannelRead(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HandlerB extends ChannelInboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class="line">        ctx.channel().pipeline().fireChannelRead(&quot;hello &quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class="line">        System.out.println(&quot;B &quot; + msg);</div><div class="line">        ctx.fireChannelRead(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class HandlerC extends ChannelInboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class="line">        System.out.println(&quot;c &quot;+msg);</div><div class="line">        ctx.fireChannelRead(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>输出<br>A hello<br>B hello<br>c hello </p></blockquote><p>可以看到inbound的read顺序和添加顺序相关,按顺序进行读取,并且可以在中间开始传播。其中还隐藏了不少细节,其实inbound事件都是从head节点开始传播,但是head节点什么都不做,只是fire这条消息,所以没有感觉,如果消息是bytebuff类型,在tail节点会调用realse方法进行释放。所以如果一个节点接收到消息不需要向后传播时,应该手动进行realse,否则会占用空间导致内存泄漏。考虑到这一点,Netty提供了SimpleChannelInboundHandler类,可以继承这个类,Netty会帮我们释放不用的bytebuffer。</p><h2 id="outBound事件传播"><a href="#outBound事件传播" class="headerlink" title="outBound事件传播"></a>outBound事件传播</h2><p>outBound的传播主要体现在write方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">socketChannel.pipeline().addLast(new OutA());</div><div class="line">socketChannel.pipeline().addLast(new OutB());</div><div class="line">socketChannel.pipeline().addLast(new OutC());</div><div class="line"></div><div class="line"></div><div class="line">public class OutA extends ChannelOutboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class="line">        System.out.println(&quot;A &quot;+msg);</div><div class="line">        ctx.write(msg,promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OutB extends ChannelOutboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class="line">        System.out.println(&quot;B &quot;+msg);</div><div class="line">        ctx.write(msg,promise);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handlerAdded(final ChannelHandlerContext ctx) throws Exception &#123;</div><div class="line">        ctx.executor().schedule(()-&gt;&#123;</div><div class="line">            ctx.channel().write(&quot;hello&quot;);</div><div class="line">        &#125;,3, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class OutC extends ChannelOutboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class="line">        System.out.println(&quot;C &quot;+msg);</div><div class="line">        ctx.write(msg,promise);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>输出<br>C hello<br>B hello<br>A hello</p></blockquote><p>可以看到,outBound的添加顺序与执行顺序相反,后添加的先执行。这里我们看到了两种write的写法,那么有什么区别呢:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx.write(msg);</div><div class="line">ctx.channel().write(&quot;hello&quot;);</div></pre></td></tr></table></figure><p>首先看ctx.channel().write(“hello”),可以看到首先调用了内部的pipeline,然后进入尾节点,也就是从tail节点向前写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public ChannelFuture write(Object msg) &#123;</div><div class="line">    return pipeline.write(msg);</div><div class="line">&#125;</div><div class="line">@Override</div><div class="line">public final ChannelFuture write(Object msg) &#123;</div><div class="line">    return tail.write(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>而ctx.write(msg)的作用则是从当前节点开始传播,不会从尾节点开始</p><h2 id="异常传播"><a href="#异常传播" class="headerlink" title="异常传播"></a>异常传播</h2><blockquote><p>假设我们已经添加了 A B C三个handler,各有一个inbound处理器和一个outbound处理器,目前的pipeline状况为head&lt;-&gt;A&lt;-&gt;B&lt;-&gt;C&lt;-&gt;tail</p></blockquote><p>现在手动在A抛出一个异常,则打印错误为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Inboud B Exception</div><div class="line">Inboud C Exception</div><div class="line">Onboud A Exception</div><div class="line">Onboud B Exception</div><div class="line">Onboud C Exception</div><div class="line"></div><div class="line">A的错误日志。。。。</div></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fszdgzc385j31dc0eodia.jpg" alt=""></p><p>可见异常并没有像之前的inbound和outbound与添加顺序相同或相反,而是只与handler的添加顺序有关,并且从当前节点向后传播。</p><p>默认情况下如果不做处理,异常会一直传播,那么异常处理的最佳实践就是在最后添加一个异常处理器,对异常进行处理,否则错误最后会抛出,影响程序运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class ExceptionHandler extends ChannelInboundHandlerAdapter &#123;</div><div class="line">    @Override</div><div class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</div><div class="line">        //业务处理</div><div class="line">        if(cause instanceof RuntimeException)&#123;</div><div class="line">            //deal with exception</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="开头的问题"><a href="#开头的问题" class="headerlink" title="开头的问题"></a>开头的问题</h2><ul><li>Netty如何判断ChannelHandler类型(in  out)</li></ul><p>用户自定义的handler会选择继承自Inbound或者OutBound,Netty会用instance判断</p><ul><li>ChannelHandler添加应按照什么样的顺序</li></ul><p>InbundHandler事件的传播与添加顺序正相关,OutbundHandler事件的传播与添加顺序逆相关</p><ul><li>用户手动触发事件传播,不同的触发方式有什么区别</li></ul><p>通过channel触发事件时,从head或者tail节点开始传播,如果从当前节点触发,那么事件只会从当前节点开始触发。</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(3) 新连接接入</title>
      <link href="/2018/07/03/Netty-%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5-3/"/>
      <url>/2018/07/03/Netty-%E6%96%B0%E8%BF%9E%E6%8E%A5%E6%8E%A5%E5%85%A5-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>提出两个问题</p></blockquote><ol><li>Netty在哪里检测到新连接的接入</li><li>新连接怎样注册到NioEventLoop线程</li></ol><p>我们知道Nio的多路复用是指多个连接复用一条线程,对应netty就是nioeventloop,新连接处理主要有四个步骤</p><ol><li><p>检测新连接: 新连接通过服务端Channel绑定的selector轮询出ACCEPT事件</p></li><li><p>创建Channel:基于JDK的nioChannel创建出Netty NioSocketChannel</p></li><li><p>Netty给客户端channel分配NioEventLoop,并将channel绑定</p></li><li><p>向selector注册读事件</p></li></ol><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="检测新连接"><a href="#检测新连接" class="headerlink" title="检测新连接"></a>检测新连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">processSelectedKey(key,channel) [入口]</div><div class="line">    NioMessageUnsafe.read()</div><div class="line">        doReadMessage()  [while 循环]</div><div class="line">            javaChannel().accept()</div></pre></td></tr></table></figure><h2 id="创建NioSocketChannel"><a href="#创建NioSocketChannel" class="headerlink" title="创建NioSocketChannel"></a>创建NioSocketChannel</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">new NioSocketChannel(parent,ch)  [入口]</div><div class="line">    AbstractNioByteChannel(p,ch,opread)</div><div class="line">        configBlocking(false) &amp; interest_op [注册事件]</div><div class="line">        create id,unsafe,pipeline</div><div class="line">    new NioSocketChannelConfig()  [创建绑定配置]</div><div class="line">        setTcpNoDelay(true)       [禁止Nagle算法,小数据包尽量快发送]</div></pre></td></tr></table></figure><p>跟进到NioServerSocketChannel.doReadMessages(buf):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;</div><div class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</div><div class="line">    try &#123;</div><div class="line">        if (ch != null) &#123;</div><div class="line">            buf.add(new NioSocketChannel(this, ch));</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>首先创建一个jdk的channel,然后将jdk的channel与当前类this,共同构造一个Netty的NioSocketChannel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public NioSocketChannel(Channel parent, SocketChannel socket) &#123;</div><div class="line">    super(parent, socket);</div><div class="line">    config = new NioSocketChannelConfig(this, socket.socket());</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) &#123;</div><div class="line">        super(parent, ch, SelectionKey.OP_READ);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里跟进到父类,发现Netty默认传递了一个OP_READ事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</div><div class="line">    super(parent);</div><div class="line">    this.ch = ch;</div><div class="line">    this.readInterestOp = readInterestOp;</div><div class="line">    try &#123;</div><div class="line">        ch.configureBlocking(false);</div><div class="line">    &#125;</div><div class="line">    ....</div></pre></td></tr></table></figure><p>在这里,将read事件注册到了channel,并且设置为非阻塞模式,继续向上跟进父类,就会创建id,unsafe,pipeline组件。NioSocketChannelConfig主要作用就是设置setTcpNoDelay(true)。如果是false,则会将小的数据包尽量集合成大的数据包然后发送出去,而Netty默认是关闭的,如果运行在Android系统上,则默认开启。</p><h2 id="Netty中Channel的分类"><a href="#Netty中Channel的分类" class="headerlink" title="Netty中Channel的分类"></a>Netty中Channel的分类</h2><h3 id="Channel层级关系"><a href="#Channel层级关系" class="headerlink" title="Channel层级关系"></a>Channel层级关系</h3><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180704153067048025149.png" alt="20180704153067048025149.png"></p><p>顶层接口channel主要定义了网络IO的读写,绑定,是一个最顶级的抽象。AbstractChannel是一个抽象的实现,并且定义了重要的成员变量。</p><p>接着是AbstractNioChannel,他有两个子类channel,这两个子类差别主要是向AbstractNioChannel注册的io事件不同,可以看一下构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</div><div class="line">        super(null, channel, SelectionKey.OP_ACCEPT);</div><div class="line">        config = new NioServerSocketChannelConfig(this, javaChannel().socket());</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected AbstractNioByteChannel(Channel parent, SelectableChannel ch) &#123;</div><div class="line">    super(parent, ch, SelectionKey.OP_READ);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到服务端channel感兴趣的是accept事件,而客户端channel感兴趣的是read事件。除此之外可以发现,服务端channel和客户端channel对应的unsafe不同,对于服务端NioMessageUnsafe处理的是连接的读取,而客户端NioByteUnsafe是字节读取。</p><p>客户端和服务端都有相应的config进行配置</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsxmlg099gj30zc0j6ach.jpg" alt=""></p><h2 id="新连接NioEventLoop分配和selector注册"><a href="#新连接NioEventLoop分配和selector注册" class="headerlink" title="新连接NioEventLoop分配和selector注册"></a>新连接NioEventLoop分配和selector注册</h2><p>方法的入口为MultithreadEventLoopGroup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public ChannelFuture register(Channel channel) &#123;</div><div class="line">    return next().register(channel);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里会next()返回一个NioEventLoop,然后chooser选择一个NioEventLoop,调用register方法,过程中利用了串行无锁化技术,调用底层jdk channel,注册一个accept事件</p><h2 id="NioSocketChannel读事件注册"><a href="#NioSocketChannel读事件注册" class="headerlink" title="NioSocketChannel读事件注册"></a>NioSocketChannel读事件注册</h2><p>入口方法位于AbstractChannel的register0()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (isActive()) &#123;</div><div class="line">    if (firstRegistration) &#123;</div><div class="line">        pipeline.fireChannelActive();</div><div class="line">    &#125; else if (config().isAutoRead()) &#123;</div><div class="line">        beginRead();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里因为新连接已经介入,所以isActive()返回true,并且firstRegistration也为true。调用  pipeline.fireChannelActive();后续会调用readIfIsAutoRead(),默认情况下是自动读的,AbstractNioChannel.beginRead()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void doBeginRead() throws Exception &#123;</div><div class="line">    // Channel.read() or ChannelHandlerContext.read() was called</div><div class="line">    final SelectionKey selectionKey = this.selectionKey;</div><div class="line">    if (!selectionKey.isValid()) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    readPending = true;</div><div class="line"></div><div class="line">    final int interestOps = selectionKey.interestOps();</div><div class="line">    if ((interestOps &amp; readInterestOp) == 0) &#123;</div><div class="line">        selectionKey.interestOps(interestOps | readInterestOp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里由于初始化设置interestOps为0,所以会再添加一个readInterestOp,也就可以监听OP_READ事件了。</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty(2) NioEventLoop</title>
      <link href="/2018/07/02/Netty-NioEventLoop-2/"/>
      <url>/2018/07/02/Netty-NioEventLoop-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>相关的三个问题</p></blockquote><ol><li>默认情况下,Netty服务端起多少线程,何时启动</li><li>Netty如何解决JDK空轮训bug</li><li>Netty如何保证异步串行无锁化</li></ol><h2 id="NioEventLoop创建"><a href="#NioEventLoop创建" class="headerlink" title="NioEventLoop创建"></a>NioEventLoop创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">new NioEventLoopGroup() [线程组,默认cpu*2]</div><div class="line">    new ThreadPerTaskExecutor() [线程创建器]</div><div class="line">    for()&#123;new Child()&#125; [构造Eventloop]</div><div class="line">    chooserFactory.newChooser()[线程选择器]</div></pre></td></tr></table></figure><p>从用户代码进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NioEventLoopGroup boss = new NioEventLoopGroup(1);</div><div class="line">NioEventLoopGroup worker = new NioEventLoopGroup();</div></pre></td></tr></table></figure><p>跟进到这里可以看到,默认不传参数的eventgroup会赋予一个DEFAULT_EVENT_LOOP_THREADS大小的线程,为cpu数量的2倍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123;</div><div class="line">    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>接着进入父类可以进入方法MultithreadEventExecutorGroup</p><p>首先创建线程选择器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (executor == null) &#123;</div><div class="line">    executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着构造一个Eventloop数组并循环创建,最后        </p><p>chooser = chooserFactory.newChooser(children);</p><p>创建一个线程选择器</p><h3 id="ThreadPerTaskExecutor"><a href="#ThreadPerTaskExecutor" class="headerlink" title="ThreadPerTaskExecutor"></a>ThreadPerTaskExecutor</h3><ul><li>每次执行任务都会创建一个线程实体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());</div><div class="line"></div><div class="line">@Override</div><div class="line">public void execute(Runnable command) &#123;</div><div class="line">    threadFactory.newThread(command).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Netty线程命名规则 nioEventLoop-x-xx</li></ul><ul><li>FastThreadLocalThread    </li></ul><p>这里Netty创建的线程是FastThreadLocalThread,这种Thread对JDK底层的Thread进行了包装,优化了ThreadlocalMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected Thread newThread(Runnable r, String name) &#123;</div><div class="line">        return new FastThreadLocalThread(threadGroup, r, name);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h3 id="newChild"><a href="#newChild" class="headerlink" title="newChild()"></a>newChild()</h3><ul><li><p>保存线程执行器ThreadPerTaskExecutor</p></li><li><p>创建一个MpscQueue</p></li><li><p>创建一个selector</p></li></ul><p>我们通过children[i] = newChild(executor, args);进入NioEventLoopGroup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</div><div class="line">            SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</div><div class="line">    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</div><div class="line">    if (selectorProvider == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;selectorProvider&quot;);</div><div class="line">    &#125;</div><div class="line">    if (strategy == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;selectStrategy&quot;);</div><div class="line">    &#125;</div><div class="line">    provider = selectorProvider;</div><div class="line">    final SelectorTuple selectorTuple = openSelector();</div><div class="line">    selector = selectorTuple.selector;</div><div class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</div><div class="line">    selectStrategy = strategy;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里一个nioeventLoop和一个selector作绑定,继续跟进父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,</div><div class="line">                                        boolean addTaskWakesUp, int maxPendingTasks,</div><div class="line">                                        RejectedExecutionHandler rejectedHandler) &#123;</div><div class="line">        super(parent);</div><div class="line">        this.addTaskWakesUp = addTaskWakesUp;</div><div class="line">        this.maxPendingTasks = Math.max(16, maxPendingTasks);</div><div class="line">        this.executor = ObjectUtil.checkNotNull(executor, &quot;executor&quot;);</div><div class="line">        taskQueue = newTaskQueue(this.maxPendingTasks);</div><div class="line">        rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这部分代码比较清晰,首先将线程执行器保存起来,因为后面创建NioEventloop底层线程要用到。</p><p>然后创建了一个taskQueue,这个taskQ是用在一些外部线程执行Netty任务,如果判断不是在NioEventloop里面去执行,它会放到一个任务队列里,然后由NioEventloop里对应的一个线程去执行。这里创建了一个newMpscQueue,这里的MpscQ意思是Mutli producer single consumer的意思,这里的consumer就是NioEventloop</p><h3 id="创建Chooser"><a href="#创建Chooser" class="headerlink" title="创建Chooser"></a>创建Chooser</h3><p>chooser的作用就是当一个连接进入,chooser选择一个NioEventloop进行服务,例如NioEventLoop大小为N。第一个请求分配nioEventLoop[0],第N个分配nioEventLoop[N-1]。第n+1个分配nioEventLoop[0],如此循环往复。但是在这样简单的功能中,netty也做了优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">chooser = chooserFactory.newChooser(children);</div><div class="line">    isPowerOfTwo[判断nioeventloop长度是否是2的幂]</div><div class="line">        PowerOfTwoEventExecutorChooser [优化]</div><div class="line">            index++&amp;(length-1)</div><div class="line">        GenericEventExecutorChooser    [未优化]</div><div class="line">            abs(index++%length)</div></pre></td></tr></table></figure><p>在DefaultEventExecutorChooserFactory类下的next方法可以看到区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">return executors[Math.abs(idx.getAndIncrement() % executors.length)];</div><div class="line"></div><div class="line">return executors[idx.getAndIncrement() &amp; executors.length - 1];</div></pre></td></tr></table></figure><p>通过上面的几个小过程,就完成了NioEventLoop的创建</p><h2 id="NioEventLoop启动"><a href="#NioEventLoop启动" class="headerlink" title="NioEventLoop启动"></a>NioEventLoop启动</h2><p>NioEventLoop的启动依赖于两大触发器</p><ul><li><p>服务端启动绑定接口</p></li><li><p>新连接接入,绑定一个NioEventLoop</p></li></ul><p>先以第一个为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bind()-&gt;execute(task)  [入口]</div><div class="line">    startThread()</div><div class="line">        ThreadPerTaskExecutor.execute()</div><div class="line">            thread = Thread.currentThread</div><div class="line">            NioEventLoop.run()  [启动]</div></pre></td></tr></table></figure><p>回到AbstractBootStrap的dobind0()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">channel.eventLoop().execute(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                if (regFuture.isSuccess()) &#123;</div><div class="line">                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</div><div class="line">                &#125; else &#123;</div><div class="line">                    promise.setFailure(regFuture.cause());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p><p>跟进execute方法到SingleThreadEventExecutor</p><p>在这里判断了当前线程是否在NioEventLoop中,在这里返回一个False,所以进入startThread()-&gt;doStartThread()</p><p>这部分代码首先做的就是把当前线程进行一个保存,也就是绑定到NioEventLoop,接着调用一个run()最终启动</p><h2 id="NioEventLoop执行逻辑"><a href="#NioEventLoop执行逻辑" class="headerlink" title="NioEventLoop执行逻辑"></a>NioEventLoop执行逻辑</h2><p>NioEventLoop的执行逻辑从SingleThreadEventExecutor.doStartThread()中SingleThreadEventExecutor.this.run();开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">run()-&gt;for(;;)</div><div class="line">    select [轮询注册到selector上的事件]</div><div class="line">    processSelectedKeys [处理轮询出来的事件]</div><div class="line">    runAllTasks [处理异步任务队列]</div></pre></td></tr></table></figure><p>首先select的过程比较简单,不在多说。然后对selectKeys进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (ioRatio == 100) &#123;</div><div class="line">    try &#123;</div><div class="line">        processSelectedKeys();</div><div class="line">    &#125; finally &#123;</div><div class="line">        runAllTasks();</div><div class="line">    &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        final long ioStartTime = System.nanoTime();</div><div class="line">        try &#123;</div><div class="line">            processSelectedKeys();</div><div class="line">        &#125; finally &#123;</div><div class="line">            final long ioTime = System.nanoTime() - ioStartTime;</div><div class="line">            runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到这里根据ioRatio进入了不同的分支。这里的ioRatio默认是50,所以进入了else分支。ioRatio是用来控制processSelectedKeys和runAllTasks的执行时间,processSelectedKey处理io相关的逻辑,runAllTasks是用来处理外部线程扔到taskQ里面的任务,这里的taskQ之前说过是一个MpscQ.</p><p>在else分支中,首先记录一下开始时间,处理完成计算完成时间，由于radio是50,所以runAllTask也可以处理相同的时间,更细致的分析以后再写</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="检测io事件"><a href="#检测io事件" class="headerlink" title="检测io事件"></a>检测io事件</h4><ul><li>deadline以及任务穿插逻辑处理</li><li>阻塞式select</li><li>避免jdk空轮训的bug</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for (;;) &#123;</div><div class="line">    long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;</div><div class="line">        if (timeoutMillis &lt;= 0) &#123;</div><div class="line">            if (selectCnt == 0) &#123;</div><div class="line">                selector.selectNow();</div><div class="line">                selectCnt = 1;</div><div class="line">        &#125;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先,通过long currentTimeNanos = System.nanoTime();获取当前时间</p><blockquote><p>long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</p></blockquote><p>这里是因为nioEventLoop底层有一个定时任务队列,它是按照任务截止从小到大排列。这样做的目的是判断是否有定时任务需要启动<br>接着进入for循环,先计算当前是否超时,如果超时并且没有select,则进行一次非阻塞的select,那么本次select操作就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class="line">    elector.selectNow();</div><div class="line">    selectCnt = 1;</div><div class="line">    break;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着判断taskQ是否为空,及MpscQ是否为空,如果有任务,则调用一个非阻塞的select方法</p><p>如果上面的条件都不满足,则调用一个阻塞式的select操作,timeout就是本次可以select的最大时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int selectedKeys = selector.select(timeoutMillis);</div><div class="line">selectCnt ++;</div></pre></td></tr></table></figure></p><p>接下来的操作可以避免JDK空轮询的bug</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">long time = System.nanoTime();</div><div class="line">if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class="line">    selectCnt = 1;</div><div class="line">    &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class="line">        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</div><div class="line">        logger.warn(</div><div class="line">        &quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,</div><div class="line">        selectCnt, selector);</div><div class="line">        rebuildSelector();</div><div class="line">        selector = this.selector;</div><div class="line">        selector.selectNow();</div><div class="line">        selectCnt = 1;</div><div class="line">        break;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当执行到这里表明已经执行过一次阻塞式的select操作,在这里判断当前时间减去阻塞式执行的时间是否大于等于进入这个方法的时间,如果小于,则可能进行了空轮询,那么这个时候会判断空轮训的次数是否大于一个阈值(默认512次),如果大于,执行rebuildSelector()操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newSelectorTuple = openSelector();</div><div class="line">for (SelectionKey key: oldSelector.keys()) &#123;...&#125;</div><div class="line">selector = newSelectorTuple.selector;</div></pre></td></tr></table></figure><p>rebuildSelector的主要内容就是创建一个新的NioEventLoop,将原来的NioEventLoop上的时间重新注册到新的,并将Netty的channel绑定,接着将新的NioEventLoop保存,将旧的释放掉</p><h4 id="处理io事件"><a href="#处理io事件" class="headerlink" title="处理io事件"></a>处理io事件</h4><p>io事件的处理主要涉及processSelectedKeys()的执行逻辑</p><ul><li>selected KeySet优化</li><li>processSelectedKeysOptimized()</li></ul><p>对于io事件轮询的优化,在selector创建的时候体现,即openSelector()</p><p>首先调用jdk的api去创建一个selector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unwrappedSelector = provider.openSelector();</div></pre></td></tr></table></figure><p>接着判断是否需要优化,默认情况下这里为false,所以需要进行优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (DISABLE_KEYSET_OPTIMIZATION) &#123;</div><div class="line">    return new SelectorTuple(unwrappedSelector);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着创建了这样一种数据结构,替换了原生JDK的selectionKey的数据结构,进入源码看一看哪里做了优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();</div></pre></td></tr></table></figure><p>这里由于keySet并不需要jdk底层的一些方法,只需要关注add方法即可。所以这里用一个一维数组替换了原有的HashSet。在极端情况下,将复杂度从O(n)降低到O(1)</p><p>回到源码,Netty继续通过反射的方式获取到JDK的selector以及属性,并且将自己实现的数据结构赋予了JDK的selector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Field selectedKeysField = selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);</div><div class="line">Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);</div><div class="line">...</div><div class="line">selectedKeysField.set(unwrappedSelector, selectedKeySet);</div><div class="line">publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</div></pre></td></tr></table></figure><p>这个过程就是Netty对selectionKey作优化,即使用数组对hashset作替换,将时间复杂度稳定到O(1)</p><p>接下来调用processSelectedKeysOptimized()处理优化后的selector,进入代码中的processSelectedKey方法。如果这个Key是合法的,这里就列出了可处理的事件,包括读/写/连接请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class="line">        int ops = k.interestOps();</div><div class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class="line">            k.interestOps(ops);</div><div class="line">            unsafe.finishConnect();</div><div class="line">        &#125;</div><div class="line">        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123;</div><div class="line">                ch.unsafe().forceFlush();</div><div class="line">        &#125;</div><div class="line">        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class="line">                unsafe.read();</div><div class="line">        &#125;</div></pre></td></tr></table></figure><h3 id="task执行"><a href="#task执行" class="headerlink" title="task执行"></a>task执行</h3><p>task的执行入口在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">runAllTasks()</div><div class="line">runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div></pre></td></tr></table></figure><ul><li><p>task分类和添加</p></li><li><p>任务聚合</p></li><li><p>任务执行</p></li></ul><p>Netty中默认有两个任务队列,一个是普通任务队列MpscQ,在创建NioEventLoop时就创建了。定时任务队列是一个普通的PriorityQ,如果是当前Eventloop添加定时任务,则直接添加,否则创建一个新的线程去添加任务,这样才是线程安全的。</p><p>首先进入代码到fetchFromScheduledTaskQueue(),这会从定时任务Q拉去第一个任务,我们说过这是一个优先级队列,他排序的标准就是两个任务的截止时间,时间相同按照添加顺序进行排序,那么第一个任务必定是最早结束的一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">taskQueue.offer(scheduledTask)</div></pre></td></tr></table></figure><p>这里拿到定时任务以后,把它加入到普通的任务队列,如果失败则重新添加到定时任务队列。完成这个方法之后,所有需要执行的定时任务都放入普通队列中了。</p><p>拿到任务之后计算一下截止时间.当任务执行的数量到64的时,比较一下截止时间,如果超出时间就退出,任务队列中的任务只能等下次再执行。如果时间没有超过,则继续执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if ((runTasks &amp; 0x3F) == 0) &#123;</div><div class="line">    lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class="line">        if (lastExecutionTime &gt;= deadline) &#123;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Netty源码(1)-服务端启动</title>
      <link href="/2018/07/02/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8-1/"/>
      <url>/2018/07/02/Netty%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fsv8rbjw9gj30u30l3my4.jpg" alt=""></p><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">        ServerBootstrap serverBootstrap = new ServerBootstrap();</div><div class="line">        EventLoopGroup boss = new NioEventLoopGroup(1);</div><div class="line">        EventLoopGroup worker = new NioEventLoopGroup();</div><div class="line">        try &#123;</div><div class="line">            serverBootstrap.group(boss, worker)</div><div class="line">                    .channel(NioServerSocketChannel.class)</div><div class="line">                    .option(ChannelOption.SO_BACKLOG, 128)</div><div class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, false)</div><div class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">                        @Override</div><div class="line">                        public void initChannel(SocketChannel socketChannel) throws Exception &#123;</div><div class="line">                            ocketChannel.pipeline().addLast(new MyHandler());</div><div class="line"></div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();</div><div class="line">            channelFuture.channel().closeFuture().sync();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            boss.shutdownGracefully();</div><div class="line">            worker.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>以上是一段Netty官网提供的一个最简单的server端代码,通过这段代码来分析Netty服务端的启动过程</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Netty服务端启动流程"><a href="#Netty服务端启动流程" class="headerlink" title="Netty服务端启动流程"></a>Netty服务端启动流程</h2><ul><li>创建服务端Channel</li><li>初始化服务端Channel</li><li>注册Selector</li><li>端口绑定</li></ul><p>我们知道Netty其实是对JAVA NIO 底层API进行了一些封装,那么我们首先提出两个问题</p><ul><li>服务端socket在哪里初始化</li><li>在哪里accept连接</li></ul><p>带着问题我们逐步分析上述的过程</p><h2 id="创建服务端Channel"><a href="#创建服务端Channel" class="headerlink" title="创建服务端Channel"></a>创建服务端Channel</h2><p>大致梳理一下源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bind() [用户代码入口]</div><div class="line">initAndRegister() [初始化并注册]</div><div class="line">newChannel() [创建服务端Channel]</div></pre></td></tr></table></figure><p>我们首先根据代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">serverBootstrap.bind(8080).sync();</div></pre></td></tr></table></figure><p>进入bind()方法,并最终进入到doBind(),看到第一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final ChannelFuture regFuture = initAndRegister();</div></pre></td></tr></table></figure><p>进入initAndRegister</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel = channelFactory.newChannel();</div></pre></td></tr></table></figure><p>这里就可以看到Netty创建了一个Channel,我们这部分主要的目的就是看Netty创建一个Channel具体做了些什么</p><p>通过newChannel(),进入实现类ReflectiveChannelFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public T newChannel() &#123;</div><div class="line">    try &#123;</div><div class="line">        return clazz.newInstance();</div><div class="line">    &#125; catch (Throwable t) &#123;</div><div class="line">        throw new ChannelException(&quot;Unable to create Channel from class &quot; + clazz, t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看出Netty用反射的方式去创建了一个Channel,那么这个clazz是什么呢。那么我们需要返回到channelFactory,看看它是怎么初始化的,初始化的时候传递了哪种Channel</p><p>回到我们自己写的用户代码,可以找到我们传递的一个Channel类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.channel(NioServerSocketChannel.class)</div></pre></td></tr></table></figure><p>进入源码,果然初始化了ReflectiveChannelFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public B channel(Class&lt;? extends C&gt; channelClass) &#123;</div><div class="line">    if (channelClass == null) &#123;</div><div class="line">        throw new NullPointerException(&quot;channelClass&quot;);</div><div class="line">    &#125;</div><div class="line">    return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(channelClass));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以Netty是通过反射的方式,创建了一个用户指定类型的Channel,那么接下来我们要去看看NioServerSocketChannel的构造函数,看它在初始化的时候做了哪些事情。由于这个类比较复杂,先给出梳理后的结果再仔细分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">new Socket() [通过JDK创建底层jdk channel]</div><div class="line">NioServerSocketChannelConfig() [tcp参数配置]</div><div class="line">AbstractNioChannel()</div><div class="line">  configureBlocking(false) [阻塞模式]</div><div class="line">  AbstractChannel(创建ID,unsafe,pipline)</div></pre></td></tr></table></figure><p>进入构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public NioServerSocketChannel() &#123;</div><div class="line">    this(newSocket(DEFAULT_SELECTOR_PROVIDER));</div><div class="line">&#125;</div><div class="line">  </div><div class="line">  private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;</div><div class="line">    try &#123;</div><div class="line">        return provider.openServerSocketChannel();</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        throw new ChannelException(</div><div class="line">                &quot;Failed to open a server socket.&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里其实就是调用了JDK底层的API,创建了一个serverSocketChannel,来自java.nio</p><p>继续进入构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public NioServerSocketChannel(ServerSocketChannel channel) &#123;</div><div class="line">    super(null, channel, SelectionKey.OP_ACCEPT);</div><div class="line">    config = new NioServerSocketChannelConfig(this, javaChannel().socket());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Netty将JDK的channel传入config,进行一些封装,将一些tcp参数配置进去,接着进入父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">    protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;</div><div class="line">        super(parent);</div><div class="line">        this.ch = ch;</div><div class="line">        this.readInterestOp = readInterestOp;</div><div class="line">        try &#123;</div><div class="line">            ch.configureBlocking(false);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            try &#123;</div><div class="line">                ch.close();</div><div class="line">            &#125; catch (IOException e2) &#123;</div><div class="line">                if (logger.isWarnEnabled()) &#123;</div><div class="line">                    logger.warn(</div><div class="line">                            &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">protected AbstractChannel(Channel parent) &#123;</div><div class="line">        this.parent = parent;</div><div class="line">        id = newId();</div><div class="line">        unsafe = newUnsafe();</div><div class="line">        pipeline = newChannelPipeline();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里我们看到了原生API的常见代码,将channel设置为非阻塞模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ch.configureBlocking(false);</div></pre></td></tr></table></figure><p>通过父类,创建了ID,unsafe,pipeline三个属性。ID是一个channel的唯一标示,unsafe做一些channel的读写操作,pipeline是Netty的一个重要抽象,我们所做的大部分工作都在pipeline上进行</p><p>至此,一个服务端的Channel创建也就完成了</p><h2 id="初始化服务端Channel"><a href="#初始化服务端Channel" class="headerlink" title="初始化服务端Channel"></a>初始化服务端Channel</h2><p>我们继续回到AbstractBootstrap.initAndRegister(),上面完成了Channel的创建,下面将返回的channel传入init(channel)方法,进行一些初始化,具体看一下init Channel的过程,首先总结一些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">init(channel) [入口]</div><div class="line">set ChannelOptions ChannelAttrs</div><div class="line">set ChildOptions ChildAttrs</div><div class="line">config handler [配置服务端pipeline]</div><div class="line">add ServerBootstrapAcceptor [添加连接器]</div></pre></td></tr></table></figure><p>进入ServerBootStrap.init(),这部分代码逻辑清晰,直接在源码上做标注</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    void init(Channel channel) throws Exception &#123;</div><div class="line">    </div><div class="line">      //set ChannelOptions ChannelAttrs</div><div class="line">    </div><div class="line">        final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</div><div class="line">        synchronized (options) &#123;</div><div class="line">            channel.config().setOptions(options);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</div><div class="line">        synchronized (attrs) &#123;</div><div class="line">            for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</div><div class="line">                @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</div><div class="line">                channel.attr(key).set(e.getValue());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line"></div><div class="line">        ChannelPipeline p = channel.pipeline();</div><div class="line"></div><div class="line">        final EventLoopGroup currentChildGroup = childGroup;</div><div class="line">        final ChannelHandler currentChildHandler = childHandler;</div><div class="line">        final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</div><div class="line">        final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</div><div class="line">        </div><div class="line">        //set ChildOptions ChildAttrs</div><div class="line">        </div><div class="line">        </div><div class="line">        </div><div class="line">        synchronized (childOptions) &#123;</div><div class="line">            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</div><div class="line">        &#125;</div><div class="line">        synchronized (childAttrs) &#123;</div><div class="line">            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">//配置pipeline</div><div class="line">        p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void initChannel(Channel ch) throws Exception &#123;</div><div class="line">                final ChannelPipeline pipeline = ch.pipeline();</div><div class="line">                ChannelHandler handler = config.handler();</div><div class="line">                if (handler != null) &#123;</div><div class="line">                    pipeline.addLast(handler);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">         //添加 ServerBootstrapAcceptor [添加连接器],处理新连接的接入,Netty默认会添加的一个handler</div><div class="line">         </div><div class="line">                ch.eventLoop().execute(new Runnable() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void run() &#123;</div><div class="line">                        pipeline.addLast(new ServerBootstrapAcceptor(</div><div class="line">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="注册Selector"><a href="#注册Selector" class="headerlink" title="注册Selector"></a>注册Selector</h2><p>Channel初始化完成之后,要把Channel注册到事件轮询器Selector上面去。我们继续回到AbstractBootstrap.initAndRegister()。在init()之后执行方法</p><blockquote><p>ChannelFuture regFuture = config().group().register(channel);</p></blockquote><p>这段代码最终会调用到AbstractChannel的Register()方法,先对这个方法的流程进行一个概括:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AbstractChannel.Register()</div><div class="line">    this.eventLoop = eventLoop [绑定Nio线程]</div><div class="line">    register0() [实际注册]</div><div class="line">        doRegister()  [调用底层api进行注册]</div><div class="line">        invokerHandlerIfNeeded  [事件回调]</div><div class="line">        fireChannelRegister()   [注册成功进行广播]</div></pre></td></tr></table></figure><p>源码的逻辑比较清晰,会看到doRegister()这个方法,直接进入AbstractNioChannel的doRegister()方法中,这是Netty注册Selector调用JDK底层API的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selectionKey = javaChannel().register(eventLoop().selector(), 0, this);</div></pre></td></tr></table></figure><p>这里javaChannel就是Netty创建的JDK底层Channel,0表示这个Channel不关心任何监听事件,只是简单的绑定上去。this表示Attachment属性,在这里就是服务端的Channel,通过attachment绑定到selector上面去。这样做的目的就是当Selector将这个javaChannel轮询出来,那么就可以拿到这个attachment,针对Netty的channle做事件的传播。</p><h2 id="服务端端口绑定"><a href="#服务端端口绑定" class="headerlink" title="服务端端口绑定"></a>服务端端口绑定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AbstractUnsafe.bind()[入口]</div><div class="line">    doBind()</div><div class="line">        javaChannel().bind() [jdk底层]</div><div class="line">    pipeline.fireChannelActive() [传播事件]</div><div class="line">        headContext.readIfIsAutoRead()</div></pre></td></tr></table></figure><p>对于JDK底层的绑定代码,可以定位到NioServerSocketChannel中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void doBind(SocketAddress localAddress) throws Exception &#123;</div><div class="line">    if (PlatformDependent.javaVersion() &gt;= 7) &#123;</div><div class="line">        javaChannel().bind(localAddress, config.getBacklog());</div><div class="line">    &#125; else &#123;</div><div class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着进入DefaultChannelPipline.channelActive。首先执行fireChannelActive方法,传播ChannelActive事件,如果用户代码重写了这个方法,那么现在就会执行,接着readIfIsAutoRead(),进入这个方法,可以发现这个方法作用在pipeline上,从head到tail都会执行,最后进入AbstractNioChannel.doBeginRead()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">protected void doBeginRead() throws Exception &#123;</div><div class="line">    final SelectionKey selectionKey = this.selectionKey;</div><div class="line">    if (!selectionKey.isValid()) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    readPending = true;</div><div class="line"></div><div class="line">    final int interestOps = selectionKey.interestOps();</div><div class="line">    if ((interestOps &amp; readInterestOp) == 0) &#123;</div><div class="line">        selectionKey.interestOps(interestOps | readInterestOp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在注册这个Channel的时候,selectKey赋予了0,在这里重新注册了accept事件(readInterestOp),也就是说从此开始,selector再轮询到新的连接接入事件,就可以交给这个NettyChannel来处理了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fsvapazei0j314w0hkmz8.jpg" alt=""></p><p>首先创建一个JDK底层Channel,然后Netty将它包装为自己的Channel,同时创建一些基本的组件并绑定。然后调用init方法,初始化channel,最重要的就是为服务端Channel创建一个连接处理器,随后调用register注册Selector,即将JDK底层Channel绑定到Selector,并将Netty的服务端channel作为attachement绑定,最后调用dobind,并重新注册一个OP_ACCEPT事件,这样Netty就可以接收新的连接了。</p></the>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka架构与核心概念</title>
      <link href="/2018/06/24/Kafka-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/06/24/Kafka-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fsm7slh4efj30hy097jso.jpg" alt=""></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>Kafka是是一个高性能跨语言分布式发布订阅消息队列系统,具有消息持久化,吞吐量高,支持消息分区等特点。Kafka自0.10版本提供对流式计算的支持。</p><ul><li>Producer </li></ul><p>提供消息的系统</p><ul><li>Consumer</li></ul><p>消费消息的系统</p><ul><li>Broker</li></ul><p>一个Kafka实例就是一个Broker,多个Kafka就是多个Broker构成的Kafka集群。Producer向某个Topic发送消息,Broker负责向订阅这个topic的所有consumer传递消息。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p>Kafka消息的发送和接收都依赖于Topic这个概念,producer把消息send到topic A,consumer订阅topic A,当producer发送消息,consumer就会接收到消息</p><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>每个Topic都可以设置多个Partition,Partition是一个有序的队列,是topic物理上的分组,即一个磁盘上的文件夹,这样做的目的是为了提高Kafka的吞吐量。</p><p>实际上Producer发送一条消息到broker,消息会被分发到这个topic下的某个partition中,consuemr按照consumer group来接收数据.每个partition的数据只能由同一个consumer group的同一个consumer来消费,如果同时想要多个consumer消费一个partition,则需要设置不同的consumer group。</p><p>所以在设置Partition的数量时最好和consumer的数量保持一致,consumer多,则有的consumer没有数据可以消费,consumer少则其他的consumer负载就会过大。</p><p>在 Kafka 内部存在两种默认的分区分配策略：Range 和 RoundRobin,通过Java API我们可以更加灵活的控制消息分配到哪个Partition以及指定consumer消费哪个partition</p><blockquote><p>Range策略</p></blockquote><p>Kafka的默认分配策略,首先对同一个topic里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序,如果除不尽,则前面的consumer group会多得到几个partition。例如，排完序的分区将会是0, 1, 2, 3, 4, 5, 6, 7, 8, 9；消费者线程排完序将会是C1-0, C2-0, C2-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C1-0 将消费 0, 1, 2, 3 分区</div><div class="line">C2-0 将消费 4, 5, 6 分区</div><div class="line">C2-1 将消费 7, 8, 9 分区</div></pre></td></tr></table></figure><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><p>每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset，用于partition唯一标识一条消息。Kafka对于消息可靠性的保证都是围绕着offset这一概念展开的。</p><p>对于一个消息系统,客户消费了哪些信息,即消费状态是一个消息系统必须提供的功能,Kafka提供3种消息传输一致性语义:</p><ul><li><p>at most once </p><p>  消息最多发送一次,这种有可能造成数据丢失。consumer fetch消息,然后commit offset并处理消息。但是在消息处理过程中consumer进程失效(crash),导致消息未能完成处理.那么此后可能其他consumer会接管当前consumer的数据,但是因为offset已经commit,那么新的consumer将不能fetch到未处理完成的数据,这就是”at most once”.</p></li><li><p>at least once </p><p>  消息最少发送一次,会造成消息的重复消费。consumer fetch消息,然后处理消息commit offset.如果消息处理成功之后,但是在commit offset阶段zookeeper异常或其他原因,导致commit offset失败,这就导致接下来再次fetch时可能获得上次已经处理过的消息,这就是”at least once”.</p></li><li><p>exactly once </p><p>  并不是指真正只传输一次，只不过有一个机制。确保不会出现“数据被重复处理”和“数据丢失”的情况。最少1次＋consumer的输出中额外增加已处理消息最大编号：由于已处理消息最大编号的存在，不会出现重复处理消息的情况。</p></li></ul><h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。replication策略是基于partition,而不是topic。kafka将每个partition数据复制到多个server上,任何一个partition有一个leader和多个follower(可以没有)。replica的个数可以通过broker配置文件来设定。leader处理所有的read-write请求,follower需要和leader保持同步.Follower就像一个”consumer”,消费消息并保存在本地日志中。当生产者发送一条消息到Broker,leader写入消息。一条消息只有被ISR里的所有follower都从leader复制过去才会被认为已提交。而对于producer而言，它可以选择是否等待消息 commit，这可以通过 request.required.acks 来设置。消息复制延迟受最慢的follower限制,重要的是快速检测慢副本,如果follower”落后”太多或者失效,leader将会把它从replicas从ISR移除。</p><blockquote><p>ISR队列</p></blockquote><p>ISR即In-Sync Replica,Replica定期的主动向Leader请求同步数据。在默认情况下,只有在Isr中的replica才有资格进行leader 选举。如果配置了unclean.election=true,这种情况下虽然保证了可用性,但是会造成数据的大量丢失,也叫脏选举。</p><p>一个replica在isr中表示,这个副本与leader的状态非常接近,即使leader crash,这个副本也可以保证数据的丢失在可容忍的范围内。具体可以看两条配置:</p><ul><li>replica.lag.max.messages=3</li><li>replica.lag.time.max=500ms</li></ul><p>表示副本的数据与leader相比最多相差三条,否则被踢出isr队列,同时必须在500ms内发送同步请求,否则也会被踢出isr。</p><h2 id="Reblance"><a href="#Reblance" class="headerlink" title="Reblance"></a>Reblance</h2><h3 id="触发rebalane-的时机"><a href="#触发rebalane-的时机" class="headerlink" title="触发rebalane 的时机"></a>触发rebalane 的时机</h3><ul><li><p>消费者加入或退出消费者组</p></li><li><p>消费者组订阅的topic出现分区数量变化</p></li><li><p>消费者调用unsubscrible取消对某topic的订阅</p></li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>总体上可以分为两步:Join和Sync</p><ol><li><p>Join</p><p> 所有成员都向协调器发送JoinGroup请求，请求入组。一旦所有成员都发送了JoinGroup请求，coordinator会从中选择一个consumer担任leader的角色，并把组成员信息以及订阅信息发给leader</p></li><li><p>Sync</p><p> 这一步leader开始分配消费方案，即哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案封装进SyncGroup请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。coordinator接收到分配方案之后会把方案塞进SyncGroup的response中发给各个consumer。这样组内的所有成员就都知道自己应该消费哪些分区了</p></li></ol><h2 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h2><p>  如果partition所在的leader发生故障导致不可用，kafka会从该分区的其他的副本中选择一个作为新的Leader。之后所有的读写就会转移到这个新的Leader上。显然，只有那些跟Leader保持同步的Follower才应该被选作新的Leader。</p><p>  Kafka会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica，已同步的副本）的集合，该集合中是一些分区的副本。如果某个分区的Leader不可用，Kafka就会从ISR集合中选择一个副本作为新的Leader。</p><blockquote><p>如果所有的ISR副本都失败了怎么办</p></blockquote><p>  此时有两种方法可选，一种是等待ISR集合中的副本复活，一种是选择任何一个立即可用的副本，而这个副本不一定是在ISR集合中(unclean.election).如果要等待ISR副本复活，虽然可以保证一致性，但可能需要很长时间。而如果选择立即可用的副本，则很可能该副本并不一致。</p></the>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka Streaming 分支</title>
      <link href="/2018/06/24/Kafka-Streaming-%E5%88%86%E6%94%AF/"/>
      <url>/2018/06/24/Kafka-Streaming-%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a>Branch</h2><p>首先创建一个输入源 topic s-in,有多个partition</p><ul><li>./kafka-topics.sh –create –topic s-in –partitions 3 –zookeeper localhost:2181 –replication-factor 1 </li><li>./kafka-topics.sh –create –topic s1 –partitions 1 –zookeeper localhost:2181 –replication-factor 1 </li><li>./kafka-topics.sh –create –topic s2 –partitions 1 –zookeeper localhost:2181 –replication-factor 1 </li></ul><p>我们可以通过一定的业务逻辑判断,让stream将不同的消息处理后发送给不同的topic,这里简单的通过判断字符串长度,发送给s1和s2两个不同的topic</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class BranchStream &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Properties properties = new Properties();</div><div class="line">        properties.put(StreamsConfig.APPLICATION_ID_CONFIG,&quot;branch&quot;);</div><div class="line">        properties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,&quot;localhost:9092&quot;);</div><div class="line">        properties.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</div><div class="line">        properties.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG,Serdes.String().getClass());</div><div class="line"></div><div class="line">        KStreamBuilder builder = new KStreamBuilder();</div><div class="line"></div><div class="line">        KStream&lt;String, String&gt;[] branch = builder.stream(Serdes.String(), Serdes.String(), &quot;s-in&quot;).branch((k, v) -&gt;</div><div class="line">                v.length() &gt; 12, (k, v) -&gt; v.length() &lt;= 12);</div><div class="line">        branch[0].mapValues(String::toUpperCase).to(&quot;s1&quot;);</div><div class="line">        branch[1].mapValues(v-&gt;&quot;enhance&quot;+v).to(&quot;s2&quot;);</div><div class="line">        KafkaStreams streams = new KafkaStreams(builder,properties);</div><div class="line">        streams.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka Streaming 入门</title>
      <link href="/2018/06/24/Kafka-Streaming-%E5%85%A5%E9%97%A8/"/>
      <url>/2018/06/24/Kafka-Streaming-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fsl9w3d2iqj30fp05edgr.jpg" alt=""></p><h2 id="什么是流式计算"><a href="#什么是流式计算" class="headerlink" title="什么是流式计算"></a>什么是流式计算</h2><p>流的本质特征是one pass和sequence。可以想象一条管道,数据经过管道,在管道内经过一系列计算。数据以流的形式,不可逆的向前流动。大多数将响应异步的返回,然后增量地更新。一句话概括就是持续输入,持续输出,各个输入输出之间没有明显的边界。</p><h2 id="Kafka-Stream-优势在哪"><a href="#Kafka-Stream-优势在哪" class="headerlink" title="Kafka Stream 优势在哪"></a>Kafka Stream 优势在哪</h2><ol><li>目前流式计算已经有了很多成熟的框架,如spark streaming,strom以及flink。这些框架对于kafka的劣势就在于过于笨重,非常依赖于框架本身的调度,需要将流式的作业提交到计算平台,通过平台来计算。而Kafka流式计算则是提供一个库,通过调用Api即可实现流式计算,但是这些Api的数据来源都必须是一个Topic。所以相比于其他流式计算框架,Kafka streaming 更加轻量,仅依赖kafka本身。 </li></ol><p>但是Kafka streaming并不可能去替代spark streaming这样一种流计算框架,可以把它视作spark streaming的local model</p><ol><li>由于kafka本身提供了诸如partition,replica,reblance,数据持久化等机制,所以Kafka streaming可以在线动态调整并行度,实现重新消费或者数据回滚等操作</li></ol><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>实现一个简单的Kafka streaming的demo,需要本地运行Kafka环境。Demo的效果就是producer发送小写的hello world到topic “stream-in”,consumer 订阅 “stream-out” topic,而stream连接”stream-in”和”stream-out”,将输入的小写数据转换为大写</p><blockquote><p>Maven</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;kafka_2.12&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.11.0.1&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.11.0.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><blockquote><p>生产者</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class AsyncSender &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Properties properties = FireAndForgetSender.initProps();</div><div class="line">        KafkaProducer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties);</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            ProducerRecord&lt;String,String&gt; record = new ProducerRecord&lt;String, String&gt;(&quot;stream-in&quot;,String.valueOf(i),&quot;hello word&quot;);</div><div class="line">            producer.send(record, new Callback() &#123;</div><div class="line">                @Override</div><div class="line">                public void onCompletion(RecordMetadata recordMetadata, Exception e) &#123;</div><div class="line">                    System.out.println(&quot;callback &quot; + recordMetadata.topic() );</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        producer.flush();</div><div class="line">        producer.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>消费者</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class SimpleConsumer &#123;</div><div class="line">    public static Properties init()&#123;</div><div class="line">        Properties properties = new Properties();</div><div class="line">        properties.put(&quot;bootstrap.servers&quot;,&quot;localhost:9092&quot;);</div><div class="line">        properties.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</div><div class="line">        properties.put(&quot;value.deserializer&quot;,&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</div><div class="line">        properties.put(&quot;group.id&quot;,&quot;test&quot;);</div><div class="line"></div><div class="line">        return properties;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(init());</div><div class="line">        consumer.subscribe(Collections.singletonList(&quot;stream-out&quot;));</div><div class="line">        while (true)&#123;</div><div class="line">            ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(100);</div><div class="line">            consumerRecords.forEach(i-&gt;&#123;</div><div class="line">                System.out.println(i.key());</div><div class="line">                System.out.println(i.value());</div><div class="line">                System.out.println(&quot;---------------&quot;);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>stream</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Stream &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Properties properties = new Properties();</div><div class="line">        properties.put(StreamsConfig.APPLICATION_ID_CONFIG,&quot;SC&quot;);</div><div class="line">        properties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,&quot;localhost:9092&quot;);</div><div class="line">        properties.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</div><div class="line">        properties.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG,Serdes.String().getClass());</div><div class="line"></div><div class="line">        KStreamBuilder builder = new KStreamBuilder();</div><div class="line"></div><div class="line">        builder.stream(Serdes.String(),Serdes.String(),&quot;stream-in&quot;).mapValues(String::toUpperCase).to(&quot;stream-out&quot;);</div><div class="line">        KafkaStreams streams = new KafkaStreams(builder,properties);</div><div class="line">        streams.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kafka消息可靠性保证</title>
      <link href="/2018/06/24/Kafka%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/"/>
      <url>/2018/06/24/Kafka%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs9xddv57oj30gm0933z8.jpg" alt=""></p><h2 id="Reliability-Guarantees"><a href="#Reliability-Guarantees" class="headerlink" title="Reliability Guarantees"></a>Reliability Guarantees</h2><p>kafka会把每个topic分为若干个partition。可以把topic理解为一个表,partition就是它的多个分区,一个partition会存放到单独的一个磁盘。每个partition都有多个副本(replica),其中一个会被选举为leader,所有的读写操作都是由leader来执行，其他的副本仅仅是用来维持一个In-Sync的状态,也就是说follower会不断地向leader发起一些fetch request，获取数据。</p><p>一个副本被认为是处于In-Sync(可参与leader选举)的状态必须满足几个条件:</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><ol><li><p>与zookeeper保持有效的连接</p></li><li><p>在一定时间内没有向leader发起fetch data 的 request(默认10秒)</p></li></ol><p>不满足条件的broker会被加入到out-sync队列中,直到broker恢复与zk的连接,并且将数据同步到一个最小的临界值(LogEndOffset)</p><h2 id="Broker-prevent-data-loss"><a href="#Broker-prevent-data-loss" class="headerlink" title="Broker prevent data loss"></a>Broker prevent data loss</h2><ul><li><p>副本机制保证了Kafka集群的可用性也保证了kafka的可靠性,通过配置副本因子N,允许丢失N-1个broker，但是这样会牺牲一些性能,参数的设置需要进行权衡。官方推荐的副本因子在3-5之间。</p></li><li><p>当leader挂掉之后,kafka集群会进行选举。处于In-Sync Replica(ISR)的副本有权力进行投票选举,详细可以看这篇文章  </p></li></ul><blockquote><p><a href="http://www.importnew.com/25247.html" target="_blank" rel="external">http://www.importnew.com/25247.html</a></p></blockquote><ul><li><p>Unclean Election: 当leader挂掉,ISR队列没有可用的副本,那么Kalfk只能从(Out-sync Replica)OSR中选择一个副本作为leader,那么这样就造成了数据的丢失。在0.11的版本中,Kafka对这种情况的默认配置进行了修改,Kalfka不允许选择OSR中的replica作为leader,必须等到一个ISR中的Replica可用,这个partition才可以继续使用。在0.11版本之前是可以选举OSR中的replica进行读写操作的。也就是说在0.11之后,Kalfka增强了CP,减弱了AP.可以设置 unclean.leader.election.enable</p></li><li><p>min.insync.replicas 这个配置用于指定多少个ISR中的副本同步到这个数据之后才返回写入成功,否则会返回一个Not Enough Replica异常</p></li></ul><h2 id="Producer-deliver-reliable"><a href="#Producer-deliver-reliable" class="headerlink" title="Producer deliver reliable"></a>Producer deliver reliable</h2><p>一个非常关键的配置就是acks,提供了0,1,all三个选项。默认配置为0，表示producer只把数据发送出去,并不在乎数据到底有没有写入partition。1表示leader必须返回ack才认为这条数据写入成功,all则是该partition的leader和follower必须全部都同步到数据才会返回ack。为了保证数据的可靠性,acks显然不能设置为0</p><h2 id="Consumer-deliver-reliable"><a href="#Consumer-deliver-reliable" class="headerlink" title="Consumer deliver reliable"></a>Consumer deliver reliable</h2><p>consumer保证数据可靠性的一个重要参数就是offset,consumer每次会从broker拿到一批数据,并记录这批数据消费到了哪一个offset.</p><p>当同一个consumer group的一个consumer挂掉,另一个consumer会捡起挂掉consumer的工作，那么这台consumer就需要知道挂掉consumer的offset是多少。consumer对于offset的处理关乎数据的可靠性,吞吐量。</p><ul><li><p>一种解决方式就是配置每次都从头开始读取数据(auto.offset.reset),但是这样有个限制,consumer不能是同一个group,否则还是会从offset开始处理,另外消息重复消费需要靠业务代码进行控制。</p></li><li><p>enable.auto.commit 该参数默认为true,但是自动提交并没有想象中的那样好用。例如consumer从broker拉取了30条数据,但是在处理到第10条数据的时候可能就会将offset=30提交，那么这样就可能造成10-30的数据丢失,所以要求数据可靠性时最好把这个参数关掉,手动控制offset的提交,一种比较推荐的代码格式如下:</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 在try里面 异步提交 不会自动retry 降低吞吐量,在finally块里进行同步提交</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(init());</div><div class="line">        consumer.subscribe(Collections.singletonList(&quot;fireAndForget&quot;));</div><div class="line">        try &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(100);</div><div class="line">                consumerRecords.forEach(i -&gt; &#123;</div><div class="line">                    System.out.println(i.key());</div><div class="line">                    System.out.println(i.value());</div><div class="line">                    System.out.println(&quot;---------------&quot;);</div><div class="line">                &#125;);</div><div class="line">                consumer.commitAsync();</div><div class="line">            &#125;</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;finally &#123;</div><div class="line">            consumer.commitSync();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li>Consumer Reblance,由于rebalace的操作对导致整个group停止向 broker fetch data的操作,并重新分配message,这时就有可能造成数据的duplicate</li></ul></the>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ElasticSearch-简单聚合分析(4)</title>
      <link href="/2018/03/31/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90-4/"/>
      <url>/2018/03/31/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90-4/</url>
      
        <content type="html"><![CDATA[<p>环境方面继续使用上一篇的数据环境,根据模拟不同的需求,体验不同的聚合分析语法</p><ol><li>简单聚合: 计算每个tag下的商品数量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /ecomic/product/_search</div><div class="line">&#123;</div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_tag&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;tags&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>语法如上,但是返回结果可能会出现如下错误:</p><blockquote><p>default. Set fielddata=true on [tags] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.”</p></blockquote><p>这段错误提示的意思就是需要对索引进行一些额外的配置,fielddata=true,因为我们在使用聚合功能的时候,ES会对索引进行正排,并且把正排数据放入内存中来进行聚合分析操作,具体的fielddata会在以后解释。</p><p>这里我们需要一些操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PUT /ecomic/_mapping/product</div><div class="line">&#123;</div><div class="line">  &quot;properties&quot;:&#123;</div><div class="line">    &quot;tags&quot;:&#123;</div><div class="line">      &quot;type&quot;:&quot;text&quot;,</div><div class="line">      &quot;fielddata&quot;:true</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样再次使用聚合查询就可以了,并且在返回结果中多了这样一个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&quot;aggregations&quot;: &#123;</div><div class="line">  &quot;group_by_tags&quot;: &#123;</div><div class="line">    &quot;doc_count_error_upper_bound&quot;: 0,</div><div class="line">    &quot;sum_other_doc_count&quot;: 0,</div><div class="line">    &quot;buckets&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;key&quot;: &quot;fangzhu&quot;,</div><div class="line">        &quot;doc_count&quot;: 4</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;key&quot;: &quot;meibai&quot;,</div><div class="line">        &quot;doc_count&quot;: 4</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;key&quot;: &quot;sb&quot;,</div><div class="line">        &quot;doc_count&quot;: 3</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>其中bucket就是对聚合结果进行分组,每个tag就是一个bucket。这样就是一个简单的数据聚合,可以发现,聚合数据还返回了原有的全部数据,如果不想返回这些数据,只需要添加size:0就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET ecomic/product/_search</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0, </div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_tags&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;tags&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>聚合+搜索: 对名称中包含gaolujie的商品,计算每个tag的商品数量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">GET ecomic/product/_search</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0, </div><div class="line">  &quot;query&quot;: &#123;</div><div class="line">    &quot;match&quot;: &#123;</div><div class="line">      &quot;name&quot;: &quot;gaolujie&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;, </div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_tags&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;tags&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>很简单,aggs+query就可以做到先搜索再分析</p><ol><li>嵌套聚合:计算每个tag下商品的平均价格</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">GET ecomic/product/_search</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0, </div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_tags&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;tags&quot;</div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;avg_price&quot;: &#123;</div><div class="line">          &quot;avg&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;price&quot;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到我们先用aggs对tag进行了分组,分组之后再嵌套了一层aggs对价格求avg也就是平均值</p><ol><li>加入排序: 我们使用3的数据,并对聚合价格进行降序排序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">GET ecomic/product/_search</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0, </div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_tags&quot;: &#123;</div><div class="line">      &quot;terms&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;tags&quot;,</div><div class="line">        &quot;order&quot;: &#123;</div><div class="line">          &quot;avg_price&quot;: &quot;desc&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;avg_price&quot;: &#123;</div><div class="line">          &quot;avg&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;price&quot;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>按照指定的价格范围区间进行分组.然后在每组内再按照tag进行分组,最后再计算每组的平均价格(这个需求看起来很复杂,单其实就是三层的aggs嵌套)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">GET ecomic/product/_search</div><div class="line">&#123;</div><div class="line">  &quot;size&quot;: 0, </div><div class="line">  &quot;aggs&quot;: &#123;</div><div class="line">    &quot;group_by_price&quot;: &#123;</div><div class="line">      &quot;range&quot;: &#123;</div><div class="line">        &quot;field&quot;: &quot;price&quot;,</div><div class="line">        &quot;ranges&quot;: [</div><div class="line">          &#123;</div><div class="line">            &quot;from&quot;: 0,</div><div class="line">            &quot;to&quot;: 30</div><div class="line">          &#125;,&#123;</div><div class="line">            &quot;from&quot;: 30,</div><div class="line">            &quot;to&quot;: 50</div><div class="line">          &#125;,&#123;</div><div class="line">            &quot;from&quot;: 50,</div><div class="line">            &quot;to&quot;: 100</div><div class="line">          &#125;</div><div class="line">        ]</div><div class="line">      &#125;, </div><div class="line">      &quot;aggs&quot;: &#123;</div><div class="line">        &quot;group_by_tags&quot;: &#123;</div><div class="line">          &quot;terms&quot;: &#123;</div><div class="line">            &quot;field&quot;: &quot;tags&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;aggs&quot;: &#123;</div><div class="line">            &quot;avg_price&quot;: &#123;</div><div class="line">              &quot;avg&quot;: &#123;</div><div class="line">                &quot;field&quot;: &quot;price&quot;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上,相比于需求4,增加了一个range字段,用于进行分组</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ElasticSearch-多种搜索方式(3)</title>
      <link href="/2018/03/30/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-%E5%A4%9A%E7%A7%8D%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F-3/"/>
      <url>/2018/03/30/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-%E5%A4%9A%E7%A7%8D%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F-3/</url>
      
        <content type="html"><![CDATA[<p>ES中提供了多种索引的搜索方式,总结起来应该有六种,那么依次展示以下这些搜索方式,环境基于上一篇CRUD的数据。</p><h2 id="Query-String-Search"><a href="#Query-String-Search" class="headerlink" title="Query String Search"></a>Query String Search</h2><p>例如我想查找所有的商品信息,那么可以这样做</p><blockquote><p>GET /索引名称/类型名称/_search</p></blockquote><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180330152237444945639.png" alt="20180330152237444945639.png"></p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>下面解释一下返回信息中几个关键字段的含义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">took: 耗费了多少毫秒</div><div class="line">shards: 这里数据被拆成了五个分配,那么对于搜索请求,会打到所有的primary shard(或者它的某个replica shard)上去,共成功了五个。</div><div class="line">hits.total: 查询结果的数量,共3个document</div><div class="line">max_score: document对于一个search的相关度的匹配分数,越相关分数就越高</div><div class="line">hits.hits:包含了匹配搜索的document的详细数据</div></pre></td></tr></table></figure><p>接下来进行一下复杂一点的查询,要求商品名称包含gaolujie,并且按价格降序排序</p><blockquote><p>get /ecomic/product/_search?q=name:gaolujie&amp;sort=price:desc</p></blockquote><p>对于Query String这种方式来说,我们在生产环境中其实很少会用,因为它把参数全部放入了url中,所以构建一个复杂查询是非常困难的,仅限于学习测试。</p><h2 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h2><p>DSL全程是Domain Specified Language 特定领域语言,也就是ES中的特定语法</p><p>同样是查询所有商品,我们看一下语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Get /索引名称/类型名称/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DSL会将所有的查询条件放入query的body中,这样构建复杂的查询语法就比较容易</p><p>条件查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">GET /ecomic/product/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">        &quot;match&quot;:&#123;</div><div class="line">            &quot;name&quot;:&quot;gaolujie&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;sort&quot;:[</div><div class="line">        &quot;price&quot;:&quot;desc&quot;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>这里有个细节要注意,如果使用Kibana,GET/POST/PUT/DELETE 一定要大写,否则返回值可能就是错误的</p></blockquote><p>分页查询:</p><blockquote><p>GET /ecomic/product/_search {<br>    “query”:{“match_all”:{}},<br>    “from”:1,<br>    “size”:2<br>}</p></blockquote><p>表示从第一条数据开始,共查询两条数据</p><p>指定要查询的字段:</p><blockquote><p>GET /ecomic/product/_search<br>{<br>    “query”:{“match_all”:{}},<br>    “_source”: [“name”,”price”]<br>}</p></blockquote><p>这样查询就只包含name和price两个字段</p><h2 id="Query-Filter"><a href="#Query-Filter" class="headerlink" title="Query Filter"></a>Query Filter</h2><p>例如我们需要搜索商品名称包含gaolujie,并且售价大于30的商品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">GET /ecomic/product/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">      &quot;bool&quot;: &#123;</div><div class="line">        &quot;must&quot;:&#123;</div><div class="line">          &quot;match&quot;:&#123;</div><div class="line">            &quot;name&quot;:&quot;gaolujie&quot;</div><div class="line">          &#125;</div><div class="line">        &#125;,</div><div class="line">        &quot;filter&quot;: &#123;</div><div class="line">          &quot;range&quot;: &#123;</div><div class="line">            &quot;price&quot;: &#123;</div><div class="line">              &quot;gt&quot;: 30</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与上面不同的是,查询的条件全都包含在query这个body中,这里bool的意思先不用理会,条件must表示必须匹配name:gaoluejie这个关键字,并且过滤出价格大于30的索引</p><h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p>全文检索本身的语法并不复杂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /ecomic/product/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">      &quot;match&quot;: &#123;</div><div class="line">        &quot;name&quot;: &quot;gaolujie yunnanbaiyao&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到就是使用了 query.match字段,这里的意图就是查询name中包含gaolujie或yunnanbaiyao的记录,这里因为我们使用的是英文,所以默认会按照空格进行分词,如果使用中文的话,我们需要对分词器进行配置,这一项后面会涉及到,所以目前都使用汉语拼音。</p><p>上面的请求就可以查询到name包含gaoluejie和yunnanbaiyao的记录,从下面的返回结果我们可以看出,不同的匹配词,_score的分数是不同的。在全文检索这个过程中,name首先会被拆分并建立倒排索引,根据倒排索引所匹配到的次数计算得分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 1,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 3,</div><div class="line">    &quot;max_score&quot;: 0.2876821,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;ecomic&quot;,</div><div class="line">        &quot;_type&quot;: &quot;product&quot;,</div><div class="line">        &quot;_id&quot;: &quot;3&quot;,</div><div class="line">        &quot;_score&quot;: 0.2876821,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;yunnanbaiyao&quot;,</div><div class="line">          &quot;desc&quot;: &quot;meibai&quot;,</div><div class="line">          &quot;price&quot;: 40,</div><div class="line">          &quot;producer&quot;: &quot;gaolujie&quot;,</div><div class="line">          &quot;tags&quot;: [</div><div class="line">            &quot;meibai&quot;,</div><div class="line">            &quot;fangzhu&quot;,</div><div class="line">            &quot;sb&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;ecomic&quot;,</div><div class="line">        &quot;_type&quot;: &quot;product&quot;,</div><div class="line">        &quot;_id&quot;: &quot;put2&quot;,</div><div class="line">        &quot;_score&quot;: 0.25811607,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;gaolujie yagao1&quot;,</div><div class="line">          &quot;desc&quot;: &quot;meibai&quot;,</div><div class="line">          &quot;price&quot;: 40,</div><div class="line">          &quot;producer&quot;: &quot;gaolujie&quot;,</div><div class="line">          &quot;tags&quot;: [</div><div class="line">            &quot;meibai&quot;,</div><div class="line">            &quot;fangzhu&quot;,</div><div class="line">            &quot;sb&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;ecomic&quot;,</div><div class="line">        &quot;_type&quot;: &quot;product&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0.25811607,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;gaolujie yagao1&quot;,</div><div class="line">          &quot;desc&quot;: &quot;meibai&quot;,</div><div class="line">          &quot;price&quot;: 30,</div><div class="line">          &quot;producer&quot;: &quot;gaolujie&quot;,</div><div class="line">          &quot;tags&quot;: [</div><div class="line">            &quot;meibai&quot;,</div><div class="line">            &quot;fangzhu&quot;,</div><div class="line">            &quot;sb&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Phrase-Search-短语搜索"><a href="#Phrase-Search-短语搜索" class="headerlink" title="Phrase Search(短语搜索)"></a>Phrase Search(短语搜索)</h2><p>和全文检索相反,全文检索会将输入的字符串拆解,并到倒排索引中去匹配,只要能匹配上任意一个拆解后的单词,就可以返回</p><p>Phrase Search要求输入的字符串必须完整的存在于文本中,才能算匹配并返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GET /ecomic/product/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">      &quot;match_phrase&quot;: &#123;</div><div class="line">        &quot;name&quot;: &quot;gaolujie yunnanbaiyao&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样我们就完全命中不到数据了</p><h2 id="高亮搜索"><a href="#高亮搜索" class="headerlink" title="高亮搜索"></a>高亮搜索</h2><p>这种搜索是非常常见的一种形式,例如我们百度搜索一下关键字都会用红色字体标注,比如我们进行全文检索,并对匹配到的关键词用<em>标签进行包裹</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">GET /ecomic/product/_search</div><div class="line">&#123;</div><div class="line">    &quot;query&quot;:&#123;</div><div class="line">      &quot;match&quot;: &#123;</div><div class="line">        &quot;name&quot;: &quot;gaolujie yunnanbaiyao&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;highlight&quot;: &#123;</div><div class="line">      &quot;fields&quot;: &#123;</div><div class="line">        &quot;name&quot;: &#123;&#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果如下,匹配到的单词会被标注出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot;: 27,</div><div class="line">  &quot;timed_out&quot;: false,</div><div class="line">  &quot;_shards&quot;: &#123;</div><div class="line">    &quot;total&quot;: 5,</div><div class="line">    &quot;successful&quot;: 5,</div><div class="line">    &quot;failed&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot;: &#123;</div><div class="line">    &quot;total&quot;: 3,</div><div class="line">    &quot;max_score&quot;: 0.2876821,</div><div class="line">    &quot;hits&quot;: [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;ecomic&quot;,</div><div class="line">        &quot;_type&quot;: &quot;product&quot;,</div><div class="line">        &quot;_id&quot;: &quot;3&quot;,</div><div class="line">        &quot;_score&quot;: 0.2876821,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;yunnanbaiyao&quot;,</div><div class="line">          &quot;desc&quot;: &quot;meibai&quot;,</div><div class="line">          &quot;price&quot;: 40,</div><div class="line">          &quot;producer&quot;: &quot;gaolujie&quot;,</div><div class="line">          &quot;tags&quot;: [</div><div class="line">            &quot;meibai&quot;,</div><div class="line">            &quot;fangzhu&quot;,</div><div class="line">            &quot;sb&quot;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;highlight&quot;: &#123;</div><div class="line">          &quot;name&quot;: [</div><div class="line">            &quot;&lt;em&gt;yunnanbaiyao&lt;/em&gt;&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;ecomic&quot;,</div><div class="line">        &quot;_type&quot;: &quot;product&quot;,</div><div class="line">        &quot;_id&quot;: &quot;put2&quot;,</div><div class="line">        &quot;_score&quot;: 0.25811607,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;gaolujie yagao1&quot;,</div><div class="line">          &quot;desc&quot;: &quot;meibai&quot;,</div><div class="line">          &quot;price&quot;: 40,</div><div class="line">          &quot;producer&quot;: &quot;gaolujie&quot;,</div><div class="line">          &quot;tags&quot;: [</div><div class="line">            &quot;meibai&quot;,</div><div class="line">            &quot;fangzhu&quot;,</div><div class="line">            &quot;sb&quot;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;highlight&quot;: &#123;</div><div class="line">          &quot;name&quot;: [</div><div class="line">            &quot;&lt;em&gt;gaolujie&lt;/em&gt; yagao1&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot;: &quot;ecomic&quot;,</div><div class="line">        &quot;_type&quot;: &quot;product&quot;,</div><div class="line">        &quot;_id&quot;: &quot;1&quot;,</div><div class="line">        &quot;_score&quot;: 0.25811607,</div><div class="line">        &quot;_source&quot;: &#123;</div><div class="line">          &quot;name&quot;: &quot;gaolujie yagao1&quot;,</div><div class="line">          &quot;desc&quot;: &quot;meibai&quot;,</div><div class="line">          &quot;price&quot;: 30,</div><div class="line">          &quot;producer&quot;: &quot;gaolujie&quot;,</div><div class="line">          &quot;tags&quot;: [</div><div class="line">            &quot;meibai&quot;,</div><div class="line">            &quot;fangzhu&quot;,</div><div class="line">            &quot;sb&quot;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;highlight&quot;: &#123;</div><div class="line">          &quot;name&quot;: [</div><div class="line">            &quot;&lt;em&gt;gaolujie&lt;/em&gt; yagao1&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上就是ES中常用的几种搜索方式</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ElasticSearch-CRUD(2)</title>
      <link href="/2018/03/29/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-CRUD-2/"/>
      <url>/2018/03/29/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-CRUD-2/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p>ES 5.5  kibana 5.5 </p></blockquote><h2 id="电商案例"><a href="#电商案例" class="headerlink" title="电商案例"></a>电商案例</h2><p>假设我们有一个java pojo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class product&#123;</div><div class="line">    private String name;</div><div class="line">    private String desc;</div><div class="line">    private Integer price;</div><div class="line">    private String producer;</div><div class="line">    private List  tags;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么我们首先将pojo对应的一条数据存储到ES中,相信大家都知道将上上面的pojo存储到数据库中应该怎么做,ES是面向文档(document)的搜索分析引擎,文档中存储的数据结构,与面向对象的数据结构是一样的,基于这样的数据结构,ES可以提供复杂的索引,全文检索,分析聚合等功能,ES的document使用json来表达。</p><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>使用kibana的dev tools,新增的语法为:</p><blockquote><p>PUT /索引名称/类型名称/ID {数据}</p></blockquote><p><img src="http://p1vpfd8u5.bkt.clouddn.com/2018032915223340444178.png" alt="2018032915223340444178.png"></p><p>如上我们建立了一个索引放入ES中,就像对数据库的表中加入了一条记录</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询的语法相对比较简单,这里的查询是指单单查找这一条记录,而不是根据条件进行搜索。</p><blockquote><p>GET /索引名称/类型名称/ID {数据}</p></blockquote><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180329152233469761469.png" alt="20180329152233469761469.png"></p><p>可以看到索引的一些基本信息,数据信息是在source下的,同时有一个version字段,表示这条索引的修改次数，同时也可以用于并发控制</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改索引有两种方式,第一种是替换,另一种是更新</p><p>先来看替换</p><blockquote><p>PUT /索引名称/类型名称/ID {数据}</p></blockquote><p>使用这种方式,对于没有更新的数据也要带上,否则就会认为没有这个字段</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180329152233513023560.png" alt="20180329152233513023560.png"></p><p>这里我们修改一下name字段,可以看到version自增,reslut和created字段也表明了更新成功。</p><p>更新文档方式</p><blockquote><p>POST /索引名称/类型名称/ID/_update {<br>    “doc”:{“字段名”:数据}<br>}</p></blockquote><p>这种方式对于不需要修改的字段,不需要添加进去</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180329152233554191011.png" alt="20180329152233554191011.png"></p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180329152233564161234.png" alt="20180329152233564161234.png"></p><p>可以看到通过这种方式,我们就将想修改的字段单独做了修改</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>delete /索引名称/类型名称/ID</p></blockquote><p>这样在使用get方式就无法查询到这条数据啦</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统学习ElasticSearch-概念(1)</title>
      <link href="/2018/03/27/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-%E6%A6%82%E5%BF%B5-1/"/>
      <url>/2018/03/27/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ElasticSearch-%E6%A6%82%E5%BF%B5-1/</url>
      
        <content type="html"><![CDATA[<p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180328152224709191016.jpg" alt="20180328152224709191016.jpg"></p><h2 id="Lucene和ES"><a href="#Lucene和ES" class="headerlink" title="Lucene和ES"></a>Lucene和ES</h2><p>lucene是最强大最先进的搜索库,但是直接基于lucene开发,api非常复杂,不易扩展,需要深入理解原理(索引结构)。</p><p>ES直接基于lucene，隐藏复杂性，提供便利的rest API接口，强大之处在于</p><ol><li>分布式,便于扩展</li><li>既可以作为搜索引擎,也可以作为数据分析引擎</li><li>支持PB级数据</li><li>开箱即用,优秀的默认设置,完全开源</li></ol><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ol><li>NRT(近实时):从数据写入到数据可以被搜索，延迟在秒级别。基于ES的搜索和分析耗时也在秒级别。</li><li>Cluster(集群): 包含多个节点,节点属于哪个集群是通过集群名称来进行配置的,(默认elasticsearch)</li><li>Node(节点): 每个节点都有名称(默认随机分配),默认会加入elasticsearch这个集群,如果启动一堆节点,就会自动加入elasticsearch集群。</li><li>Document(文档): es中最小的数据单元,一个document可能是一条客户数据,一条订单数据,通常用json数据表示。每个index下的type，都可以存储多个document,每个document里都有多个field,一个field就是一个字段</li><li>Index(索引): 包含一堆有相似结构的文档数据,比如有一个客户索引,订单索引等,索引都有名称,index可以包含多个document</li><li>Type(类型): 每个索引里都有一个或多个type,type是index中的一个逻辑分类,一个type下的document,都有相同的field。比如一个blog,有用户数据type,博客评论type,评论数据type</li><li>shard: 单台机器无法存储大量的数据,es可以将索引中的数据切分为多个shard,分布在多台机器上存储。有了shard就可以横向扩展，提高吞吐量和性能,每个shard都是一个lucene index</li><li>replica: 任何一个服务器都有可能随时宕机,此时shard就有可能丢失,因此可以给shard创建多个replica副本,用于备份容灾</li></ol><h2 id="对比数据库"><a href="#对比数据库" class="headerlink" title="对比数据库"></a>对比数据库</h2><p>ES                数据库</p><p>Document            行</p><p>Type                表</p><p>Index               库</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-自己动手写跳表(13)</title>
      <link href="/2018/03/02/JUC-%E8%B7%B3%E8%A1%A8-12/"/>
      <url>/2018/03/02/JUC-%E8%B7%B3%E8%A1%A8-12/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a>什么是跳表</h2><p>在我们日常工作中经常接触链表。对于链表这种数据结构我们再熟悉不过，那么我们也知道链表的一个缺点就是查找速度慢，因为它只能进行顺序的查找。那么如何对链表进行优化提高它的查询速度呢?我们可以借鉴AVL或者说二分查找的思路。首先链表必须有序,然后按照某种算法提取链表中的一些元素，我们对提取出来的元素做比较，就可以知道目标元素的大概位置。理论上,我们可以将查找的时间复杂度从O(n)降低到O(lgn)。在某些状态下，跳表这种数据结构可以和红黑树相媲美。用图形来展示可以更直观的理解跳表</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1foyv6ckwv8j30zk0b8dfs.jpg" alt=""></p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>如图所示就是跳表的一个简单结构,这里画的不太标准，其实每个元素之间是双向的连接，包括上下元素之间也是双向的。最底层就是我们的原链表,通过算法抽取其中的元素再向上加层。其实很容易理解，跳表这种数据结构就是一种典型的空间换时间算法,同时我们理想中的跳表结构就是这种小山的形状，因为这样最大程度上模拟了红黑树,将时间复杂度降为logN。</p><p>java8中提供了多种跳表的数据结构,因为这种结构看起来比较容易实现，所以我们可以先自己写代码模拟一下，因为这样可以发现难点在哪里。</p><h2 id="自己写一个跳表"><a href="#自己写一个跳表" class="headerlink" title="自己写一个跳表"></a>自己写一个跳表</h2><p>首先观察跳表的整体结构,头结点、尾节点以及数据节点，我们对他们作标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private final static byte HEAD_NODE=(byte)-1;</div><div class="line">private final static byte DATA_NODE=(byte)0;</div><div class="line">private final static byte TAIL_NODE=(byte)-1;</div></pre></td></tr></table></figure><p>可以将每个节点封装为Node，每个Node节点有上下左右四个方向的相邻节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static class Node&#123;</div><div class="line">    private Integer value;</div><div class="line">    private Node up,down,left,right;</div><div class="line">    private byte bit;</div><div class="line"></div><div class="line">    public Node(Integer value,byte bit)&#123;</div><div class="line">        this.value=value;</div><div class="line">        this.bit=bit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Node(Integer value)&#123;</div><div class="line">        this(value,DATA_NODE);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>查找元素的方法,从整个跳表的最高层链表开始查起，如果ele等于目标元素,则直接降到最底层源链表的位置,如果没有找到相等的，则找到最后一个比ele元素小的元素,然后向下层链表查找，如果找到最后一层都没有相等的，则返回最后一个比ele小的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private Node find(Integer ele)&#123;</div><div class="line">    Node current = head;</div><div class="line">    for (;;)&#123;</div><div class="line">        while (current.right.bit!=TAIL_NODE&amp;&amp;current.right.value&lt;=ele)&#123;</div><div class="line">            current=current.right;</div><div class="line">        &#125;</div><div class="line">        if(current.down!=null)&#123;</div><div class="line">            current =current.down;</div><div class="line">        &#125;else</div><div class="line">        &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return current;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最复杂的就是add方法,这里因为是双向链表，所以写的时候思路一定要清晰，否则就会出现链表链接乱的情况。</p><p>首先找到插入元素的左边和右边，然后修正链接关系。</p><p>然后简单的随机判断是否提取元素，如果需要则增加层高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public void add(Integer ele)&#123;</div><div class="line">        //调整左右关系</div><div class="line">        Node near = find(ele);</div><div class="line">        Node newNode = new Node(ele);</div><div class="line">        Node rightNode = near.right;</div><div class="line">        newNode.left=near;</div><div class="line">        newNode.right=rightNode;</div><div class="line">        rightNode.left=newNode;</div><div class="line">        near.right=newNode;</div><div class="line"></div><div class="line"></div><div class="line">        //是否增加层高</div><div class="line">        int currentLevel = 0;</div><div class="line">        while (random.nextDouble()&lt;0.5d)&#123;</div><div class="line">            if(currentLevel&gt;=height)&#123;</div><div class="line">                height++;</div><div class="line">                Node highHead = new Node(null,HEAD_NODE);</div><div class="line">                Node highTail = new Node(null,TAIL_NODE);</div><div class="line">                highHead.right=highTail;</div><div class="line">                highTail.left=highHead;</div><div class="line">                highHead.down=head;</div><div class="line">                head.up=highHead;</div><div class="line">                highTail.down=tail;</div><div class="line">                tail.up=highTail;</div><div class="line">                head=highHead;</div><div class="line">                tail=highTail;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            while ((near!=null)&amp;&amp;near.up==null)&#123;</div><div class="line">                near=near.left;</div><div class="line">            &#125;</div><div class="line">            near = near.up;</div><div class="line">            Node upNode = new Node(ele);</div><div class="line">            upNode.left=near;</div><div class="line">            upNode.right=near.right;</div><div class="line">            near.right.left = upNode;</div><div class="line">            near.right=upNode;</div><div class="line">            upNode.down = newNode;</div><div class="line">            newNode.up=upNode;</div><div class="line">            currentLevel++;</div><div class="line">        &#125;</div><div class="line">        size++;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>最后自己又增加了一些简单的方法，便于观测。最终跳表的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line">public class MySkip &#123;</div><div class="line"></div><div class="line">    private final static byte HEAD_NODE=(byte)-1;</div><div class="line">    private final static byte DATA_NODE=(byte)0;</div><div class="line">    private final static byte TAIL_NODE=(byte)-1;</div><div class="line"></div><div class="line"></div><div class="line">    public static class Node&#123;</div><div class="line">        private Integer value;</div><div class="line">        private Node up,down,left,right;</div><div class="line">        private byte bit;</div><div class="line"></div><div class="line">        public Node(Integer value,byte bit)&#123;</div><div class="line">            this.value=value;</div><div class="line">            this.bit=bit;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Node(Integer value)&#123;</div><div class="line">            this(value,DATA_NODE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Node head;</div><div class="line">    private Node tail;</div><div class="line">    private int size;</div><div class="line">    private int height;</div><div class="line">    private Random random;</div><div class="line"></div><div class="line"></div><div class="line">    public MySkip()&#123;</div><div class="line">        this.head = new Node(null,HEAD_NODE);</div><div class="line">        this.tail = new Node(null,TAIL_NODE);</div><div class="line">        this.size=0;</div><div class="line">        head.right=tail;</div><div class="line">        tail.left = head;</div><div class="line">        this.random = new Random(System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean isEmpty()&#123;</div><div class="line">        return size()==0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int size()&#123;</div><div class="line">        return size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private Node find(Integer ele)&#123;</div><div class="line">        Node current = head;</div><div class="line">        for (;;)&#123;</div><div class="line">            while (current.right.bit!=TAIL_NODE&amp;&amp;current.right.value&lt;=ele)&#123;</div><div class="line">                current=current.right;</div><div class="line">            &#125;</div><div class="line">            if(current.down!=null)&#123;</div><div class="line">                current =current.down;</div><div class="line">            &#125;else</div><div class="line">            &#123;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return current;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public boolean contains(Integer ele)&#123;</div><div class="line">        Node node = this.find(ele);</div><div class="line">        if(node.value==ele)&#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Integer get(Integer ele)&#123;</div><div class="line">        Node node = this.find(ele);</div><div class="line">        return node.value==ele?node.value:null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void add(Integer ele)&#123;</div><div class="line">        //调整左右关系</div><div class="line">        Node near = find(ele);</div><div class="line">        Node newNode = new Node(ele);</div><div class="line">        Node rightNode = near.right;</div><div class="line">        newNode.left=near;</div><div class="line">        newNode.right=rightNode;</div><div class="line">        rightNode.left=newNode;</div><div class="line">        near.right=newNode;</div><div class="line"></div><div class="line"></div><div class="line">        //是否增加层高</div><div class="line">        int currentLevel = 0;</div><div class="line">        while (random.nextDouble()&lt;0.5d)&#123;</div><div class="line">            if(currentLevel&gt;=height)&#123;</div><div class="line">                height++;</div><div class="line">                Node highHead = new Node(null,HEAD_NODE);</div><div class="line">                Node highTail = new Node(null,TAIL_NODE);</div><div class="line">                highHead.right=highTail;</div><div class="line">                highTail.left=highHead;</div><div class="line">                highHead.down=head;</div><div class="line">                head.up=highHead;</div><div class="line">                highTail.down=tail;</div><div class="line">                tail.up=highTail;</div><div class="line">                head=highHead;</div><div class="line">                tail=highTail;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            while ((near!=null)&amp;&amp;near.up==null)&#123;</div><div class="line">                near=near.left;</div><div class="line">            &#125;</div><div class="line">            near = near.up;</div><div class="line">            Node upNode = new Node(ele);</div><div class="line">            upNode.left=near;</div><div class="line">            upNode.right=near.right;</div><div class="line">            near.right.left = upNode;</div><div class="line">            near.right=upNode;</div><div class="line">            upNode.down = newNode;</div><div class="line">            newNode.up=upNode;</div><div class="line">            currentLevel++;</div><div class="line">        &#125;</div><div class="line">        size++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void dumpList()&#123;</div><div class="line">        Node temp  = head;</div><div class="line">        for(int i=height;i&gt;=0;i--)&#123;</div><div class="line">            System.out.printf(&quot;total height [%d] current [%d]&quot;,height+1,i+1);</div><div class="line">            Node node = temp.right;</div><div class="line">            while (node.bit!=TAIL_NODE)&#123;</div><div class="line">                System.out.printf(&quot;-&gt;%d&quot;,node.value);</div><div class="line">                node=node.right;</div><div class="line">            &#125;</div><div class="line">            System.out.printf(&quot;\n&quot;);</div><div class="line">            temp = temp.down;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MySkip mySkip = new MySkip();</div><div class="line">        Random random = new Random();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            mySkip.add(random.nextInt(1000));</div><div class="line">        &#125;</div><div class="line">        mySkip.dumpList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>可以看到随机算法提取元素并不理想，生成的跳表有明显的偏向性。所以暂时可以得出一个结论，元素的提取算法是一个非常重要的部分，这个算法的好坏直接关系到跳表的可用性。明天继续看看JDK中是怎么解决跳表的这些问题。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1foyvz55ahyj318c04mdg1.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1foyvz2cvqxj318k05it8x.jpg" alt=""></p></the>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ElasticSearch优化总结</title>
      <link href="/2018/02/27/ElasticSearch%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2018/02/27/ElasticSearch%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="索引结构优化"><a href="#索引结构优化" class="headerlink" title="索引结构优化"></a>索引结构优化</h3><p>一份没有经过优化的索引结构如下，由于单机版,这里备份数量和分片数量要根据生产中的实际情况来设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;settings&quot;: &#123;</div><div class="line">    &quot;number_of_replicas&quot;: 0</div><div class="line">  &#125;,</div><div class="line">  &quot;mappings&quot;: &#123;</div><div class="line">    &quot;house&quot;: &#123;</div><div class="line">      &quot;dynamic&quot;: false,</div><div class="line">      &quot;properties&quot;: &#123;</div><div class="line">        &quot;houseId&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;title&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;price&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;area&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;createTime&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;date&quot;,</div><div class="line">          &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;lastUpdateTime&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;date&quot;,</div><div class="line">          &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;cityEnName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;regionEnName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;direction&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;distanceToSubWay&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;subWayLineName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;subWayStationName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;tags&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;street&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;location&quot;:&#123;</div><div class="line">        &quot;type&quot;:&quot;geo_point&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;district&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;description&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;layoutDesc&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;traffic&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;roundService&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;rentWay&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><ol><li>文件读写方式优化<br>文件的读写方式在不同的操作系统甚至不同位数的操作系统上都会有不同的实现，默认索引存储方式正是基于文件系统的存储。NIO是Java中一个高效的IO库，可以大幅度提高文件读写的吞吐量,所以我们可以指定使用nio的方式读写文件。由于JAVA NIO在windows系统会出现未修复的错误，所以不建议在windows系统中开启，但是在生产环境中，服务器一般都是linux机器，所以这时是可以打开的。</li></ol><blockquote><p>“index.store.type”:”niofs”</p></blockquote><ol><li>动态映射<br>当ES在文档中碰到一个以前没见过的字段时,它会利用动态映射来决定该字段的类型,并自动地对该字段添加映射。所以当我们的索引结构相对稳定时，可以通过设置</li></ol><blockquote><p>“dynamic”:false 或者 “dynamic”:”strict” </p></blockquote><p>来关闭es索引的动态映射,这个配置默认是true。</p><ol><li><p>禁用_all</p><p>es中的查询返回中除了_source之外还有一个_all字段，这个字段会将所有的索引字段添加空格并连接起来，有时候会利用这个字段做全文检索，但实际上性能非常差。如果使用最新的es6则不用担心这个问题，因为在es6中,_all已经被废弃了。</p></li></ol><blockquote><p>“_all”:{“enabled”:false}</p></blockquote><ol><li>默认索引字段</li></ol><p>当_all字段不可用时，最佳实践是指定默认检索字段</p><blockquote><p>“index.query.default_field”:”title”</p></blockquote><ol><li>恢复策略</li></ol><p>Elasticsearch 将自动在可用节点间进行分片均衡，包括新节点的加入和现有节点的离线。</p><p>理论上来说，这个是理想的行为，我们想要提拔副本分片来尽快恢复丢失的主分片。 我们同时也希望保证资源在整个集群的均衡，用以避免热点。</p><p>然而，在实践中，立即的再均衡所造成的问题会比其解决的更多。举例来说，考虑到以下情形：</p><p>Node（节点） 19 在网络中失联了（某个家伙踢到了电源线)<br>Master 立即注意到了这个节点的离线，它决定在集群内提拔其他拥有 Node 19 上面的主分片对应的副本分片为主分片<br>在副本被提拔为主分片以后，master 节点开始执行恢复操作来重建缺失的副本。集群中的节点之间互相拷贝分片数据，网卡压力剧增，集群状态尝试变绿。<br>由于目前集群处于非平衡状态，这个过程还有可能会触发小规模的分片移动。其他不相关的分片将在节点间迁移来达到一个最佳的平衡状态<br>与此同时，那个踢到电源线的倒霉管理员，把服务器插好电源线进行了重启，现在节点 Node 19 又重新加入到了集群。不幸的是，这个节点被告知当前的数据已经没有用了， 数据已经在其他节点上重新分配了。所以 Node 19 把本地的数据进行删除，然后重新开始恢复集群的其他分片（然后这又导致了一个新的再平衡）</p><p>如果这一切听起来是不必要的且开销极大，那就对了。是的，不过前提是你知道这个节点会很快回来。如果节点 Node 19 真的丢了，上面的流程确实正是我们想要发生的。</p><p>为了解决这种瞬时中断的问题，Elasticsearch 可以推迟分片的分配。这可以让你的集群在重新分配之前有时间去检测这个节点是否会再次重新加入。一般我们可以设置为5分钟。</p><blockquote><p>“index.unassigned.node_left.delayed_timeout”: “5min”</p></blockquote><p>经过一些简单优化之后,索引设置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;settings&quot;: &#123;</div><div class="line">    &quot;number_of_replicas&quot;: 0,</div><div class="line">    &quot;index.store.type&quot;:&quot;niofs&quot;,</div><div class="line">    &quot;index.query.default_field&quot;:&quot;title&quot;,</div><div class="line">    &quot;index.unassigned.node_left.delayed_timeout&quot;: &quot;5min&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;mappings&quot;: &#123;</div><div class="line">    &quot;house&quot;: &#123;</div><div class="line">      &quot;dynamic&quot;: false,</div><div class="line">      &quot;_all&quot;:&#123;</div><div class="line">      &quot;enabled&quot;:false</div><div class="line">      &#125;,</div><div class="line">      &quot;properties&quot;: &#123;</div><div class="line">        &quot;houseId&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;title&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;price&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;area&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;createTime&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;date&quot;,</div><div class="line">          &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;lastUpdateTime&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;date&quot;,</div><div class="line">          &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;cityEnName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;regionEnName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;direction&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;distanceToSubWay&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;subWayLineName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;subWayStationName&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;tags&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;street&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;location&quot;:&#123;</div><div class="line">        &quot;type&quot;:&quot;geo_point&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;district&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;keyword&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;description&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;layoutDesc&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;traffic&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;roundService&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;text&quot;,</div><div class="line">          &quot;index&quot;: &quot;analyzed&quot;,</div><div class="line">          &quot;analyzer&quot;: &quot;ik_smart&quot;,</div><div class="line">          &quot;search_analyzer&quot;: &quot;ik_smart&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;rentWay&quot;: &#123;</div><div class="line">          &quot;type&quot;: &quot;integer&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h3><ol><li>禁用通配符</li></ol><p>比如两条索引结构esa和esb,这时我们可以通过es*删除这两条索引。但这时很有可能造成误删，因为es的索引不可恢复，所以出于安全考虑，要禁用通配符<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fov9llidtoj30qs0hzaac.jpg" alt=""></p><p>这里的transient可以替换为persistent,区别是transient在es重启后会失效,而persistent不会。</p><ol><li>刷新时间</li></ol><p>es默认的索引刷新时间是每秒钟进行一次，如果需要更高的性能则可以降低刷新的频率,设置为30s一次。这个配置不支持动态的修改，所以要在配置文件中添加配置项后重启生效。</p><blockquote><p>index.refresh_interval:30s</p></blockquote><ol><li>集群发现超时优化</li></ol><p>集群之间需要进行通信，来确定节点是否添加或丢失，进而进行一些决策。当集群压力很大，jvm就会频繁的进行gc，某些节点就可能出现stw现象。节点之间通信失败，就会造成分片数据的重新分配。但其实这个过程是我们不想看到的。短时间内回复几十甚至几百G的消耗都是非常大的。这时我们可以调整ping的参数来避免这种现象。同样要在配置文件中修改:</p><blockquote><p>discovery.zen.fd.ping_interval:10s<br>discovery.zen.fd.ping_timeout: 120s<br>divcovery.zen.fd.ping_retries: 5</p></blockquote><p>在5.x以上的版本中，支持通过http动态修改interval,所以在5.x以上版本这样设置是会报错的。所以5.x版本可以这样设置。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fovu6clrptj30hx0600sp.jpg" alt=""></p><ol><li>各司其职</li></ol><p>在配置文件中有这样的默认配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">node.name:xxx</div><div class="line">node.master:true</div><div class="line">node.data:true</div></pre></td></tr></table></figure><p>这表明这个节点既可以成为master节点，也可以成为数据节点。但其实我们可以让节点只做一项工作，来减少性能的消耗，提高稳定性。比如配置3个节点作为master节点，只用来指挥调度不参与数据存储。更多的节点用于存储数据而不参与指挥调度。具体配置视服务器情况而定。</p><p>对于数据节点，我们可以关闭它的http功能，而只留下tcp功能做数据交互。配置如下:</p><blockquote><p>http.enable: false</p></blockquote><p>所以这时一些监控插件或者工具就只能运行在master节点上了。</p><p>另外还有一种节点叫做负载均衡节点,这种节点master为false,data也是false.主要用来查询时候做负载均衡，由于分布式的原因，我们需要在不同的节点上查询数据最终汇总到客户端，这时这个节点就会用来做汇总工作与客户端交互，但是很多时候我们并不会用es的节点来做负载均衡，因为这样做单节点的压力会非常大，常见的工具就是NGINX，因为它的性能更好。</p><ol><li>内存大小</li></ol><p>内存的大小并不是越大越好，因为es是运行在jvm上，jvm中会有默认的-Xms和-Xmx限制内存的大小，所以最终是由jvm决定。由于jvm的指针压缩技术在内存大于32G的时候是不会启用的，所以es内存的设置最大不要<br>超过32G，否则很容易就OOM了。及时你可用为64G内存，也应该设置为两个32G的内存。</p><ol><li>SSD</li></ol><p>由于es是一个基于文件系统的操作，所以使用SSD能更好的发挥性能优势。</p><h3 id="基于NGINX负载均衡"><a href="#基于NGINX负载均衡" class="headerlink" title="基于NGINX负载均衡"></a>基于NGINX负载均衡</h3><p>使用的NGINX版本为1.12,ES版本为5.6。如果使用nginx1.9及以下的版本是需要额外安装模块的。首先nginx需要开启一项配置。</p><blockquote><p>./configure –with-stream</p></blockquote><p>然后进入nginx.config文件添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stream&#123;</div><div class="line">upstream backend&#123;</div><div class="line">server 127.0.0.1:9300;</div><div class="line">&#125;</div><div class="line">server&#123;</div><div class="line">listen 9999;</div><div class="line">proxy_timeout:20s</div><div class="line">proxy_pass backend;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时我们就可以通过9999端口访问ES集群了，新增ES节点只需要在upstream中添加地址就可以了。</p><h3 id="基础运维"><a href="#基础运维" class="headerlink" title="基础运维"></a>基础运维</h3><p>当项目上线,地址都是向外暴露的，所以安全配置是非常重要的。主要是配置一下nginx和es的安全策略。 首先把上面对nginx的配置注释掉，或者使用一个新的nginx。</p><p>当我们使用es的时候,可能会启动一些图形化界面来观察es的运行情况与索引结构，这里我用了elasticsearch-head插件,如果插件的启动ip暴露，攻击者就可以看到我们的集群状况并且进行攻击。</p><p>首先打开es的配置文件: 可能已经配置了如下的文件,这种就是方便个人开发测试,线上肯定是不合适的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">network.host : 0.0.0.0</div><div class="line">network.publish_host: xx.xx.xx.xx</div></pre></td></tr></table></figure><p>对其进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">network.host:127.0.0.1</div><div class="line">#network.publish_host: xx.xx.xx.xx</div></pre></td></tr></table></figure><p>这时再使用公网ip就访问不到es了，但是这时你希望可以和其他同事合作，让某些人可以看到，这时就要用到nginx了。</p><p>修改nginx配置文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">upstream es&#123;</div><div class="line">server: 127.0.0.1:9200</div><div class="line">&#125;</div><div class="line"></div><div class="line">server&#123;</div><div class="line">listen: 8888;</div><div class="line">server_name: localhost;</div><div class="line"></div><div class="line">auth_basic &quot;Protection&quot;</div><div class="line">auth_basic_user_file /usr/local/nginx/pwd/passwords</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">proxy_pass http://es;</div><div class="line">proxy_redirect off;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>auth_basic_user_file 这里的路径配置做法是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/nginx/pwd</div><div class="line">printf &quot;sc:$(openssl passwd -crypt 123)\n&quot; &gt; passwords</div><div class="line"></div><div class="line">这时路径下会有一个passwords文件,将路径拷贝就可以了</div></pre></td></tr></table></figure><p>这时访问服务使用8888端口了，但是会发现elasticsearch-head插件还是无法连接。<br>这时访问的路径是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xx.xx.xx.xx:9100/?auth_user=sc&amp;auth_password=123&amp;base_uri=http://xx.xx.xx.xx:8888</div></pre></td></tr></table></figure><p>打开调试可以发现是因为跨域访问的问题，所以如果需要跨域访问可以继续添加配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">listen: 8888;</div><div class="line">server_name: localhost;</div><div class="line"></div><div class="line">auth_basic &quot;Protection&quot;</div><div class="line">auth_basic_user_file /usr/local/nginx/pwd/passwords</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">proxy_pass http://es;</div><div class="line">proxy_redirect off;</div><div class="line">if(request_method=&apos;OPTIONS&apos;)&#123;</div><div class="line">add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</div><div class="line">add_header &apos;Access_Control-Allow-Methods &apos;GET ,POST,PUT,OPTIONS&apos;</div><div class="line">add_header &apos;Access-Control-Allow-Header&apos; &apos;Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&apos;;</div><div class="line">add_header &apos;Access-Control-Max-Age&apos; &apos;172800&apos;;</div><div class="line">add_header &apos;Content-Type&apos; &apos;text/plain;charset=utf-8&apos;;</div><div class="line">add_header &apos;Content-Length&apos; 0;</div><div class="line">return 204;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>重启nginx之后,head插件应该就可以使用了，服务也走了安全的代理。同时这里禁止掉了Delete操作，也就是说只有本机才能进行delete操作，通过nginx传过来的请求则不允许删除。</p><p>通过以上的配置，就完成对es的安全访问。你可以通过head插件访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xx.xx.xx.xx:9100/?auth_user=sc&amp;auth_password=123&amp;base_uri=http://xx.xx.xx.xx:8888</div></pre></td></tr></table></figure><p>也可以通过</p><blockquote><p>xx.xx.xx.xx:8888输入用户名密码访问</p></blockquote><p>但此时可能发现,有时候我们进行一些get等一些无害的查看操作还是需要验证，比如上面的head插件的url，还是相当于暴露了服务地址，并没有起到作用，对于head插件中查看的一些操作，我们不想进行权限拦截，那么我们可以继续配置nginx，添加location。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">location @general &#123;</div><div class="line">proxy_pass http://es;</div><div class="line">proxy_redirect off;</div><div class="line">&#125;</div><div class="line"></div><div class="line">location @need_protection&#123;</div><div class="line">proxy_pass http://es;</div><div class="line">proxy_redirect off;</div><div class="line">auth_basic &quot;Protection&quot;</div><div class="line">auth_basic_user_file /usr/local/nginx/pwd/passwords</div><div class="line">&#125;</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">if(request_method=&apos;OPTIONS&apos;)&#123;</div><div class="line">add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</div><div class="line">add_header &apos;Access_Control-Allow-Methods &apos;GET ,POST,PUT,OPTIONS&apos;</div><div class="line">add_header &apos;Access-Control-Allow-Header&apos; &apos;Authorization,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&apos;;</div><div class="line">add_header &apos;Access-Control-Max-Age&apos; &apos;172800&apos;;</div><div class="line">add_header &apos;Content-Type&apos; &apos;text/plain;charset=utf-8&apos;;</div><div class="line">add_header &apos;Content-Length&apos; 0;</div><div class="line">return 204;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//状态码设置随意 一般是一些用不到的</div><div class="line">error_page 598 @general;</div><div class="line">error_page 599 @need_protection;</div><div class="line"></div><div class="line">if($request_uri ~ ^/(_cat|_cluster)/.*$)&#123;</div><div class="line">return 598;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return 599;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过上面的设置就对用户进行了简单的分组，当访问_cat路径和_cluster下的接口不需要身份验证，其它路径则需要身份验证。这样暴露这些接口可以方便我们自己写代码对es集群的健康状况进行监控.</p></the>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-CompletableFuture使用(12)</title>
      <link href="/2018/02/16/JUC-CompletableFuture%E4%BD%BF%E7%94%A8-12/"/>
      <url>/2018/02/16/JUC-CompletableFuture%E4%BD%BF%E7%94%A8-12/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CompletableFuture是java8中新加入的一个API，主要的目的是解决future的使用痛点:调用get()方法会陷入阻塞。CompletableFuture的思想就是你不需要来问我任务有没有完成而是当我任务完成了主动返回给你。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="Stage-1"><a href="#Stage-1" class="headerlink" title="Stage 1"></a>Stage 1</h4><p>因为CompletableFuture的参数大部分都是lambda表达式的形式，所以需要有一些lambda表达式的基础，本篇使用了大量java8的新特性。</p><blockquote><p>这是一个CompletableFuture的简单使用，首先通过工厂方法supplyAsync提交一个任务。这里也可以使用new关键字创建一个CompletableFuture对象，然后再来调用方法，只是这样做太多余。supplyAsync提交的任务必须要有返回值，因为没有返回值也就没必要用CompletableFuture来做了，提交的任务简单sleep 2s，main方法中打印一句话验证是否阻塞。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class cf1 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        CompletableFuture.supplyAsync(cf1::getSomeThing).whenComplete((v,t)-&gt;&#123;</div><div class="line">            Optional.ofNullable(v).ifPresent(System.out::println);</div><div class="line">            Optional.ofNullable(t).ifPresent(System.out::println);</div><div class="line">        &#125;);</div><div class="line">        System.out.println(&quot; i am not blocked&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public static String getSomeThing()&#123;</div><div class="line">        try &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(2);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return &quot;success&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>结果: i am not blocked</p></blockquote><p>可以发现主线程输出之后直接结束了，这显然不是我们想要的效果，为什么会直接退出呢。</p><p>通过看源码可以得到原因: CompletableFuture内部使用了一个ForkJoinPool，ForkJoinPool将内部的线程设置为了守护线程，所以在主线程退出后，异步任务也就退出了。一个解决方法就是在main方法内join()，这样就可以看到CompletableFuture的返回值，但是这样做的缺点是没有中断信号，程序永远不会退出。这个问题可能在实际项目中不太会遇到，因为实际项目是一直跑在服务器的，不会出现提前退出。</p><p>实际上我们可以通过Executors框架来使用CompletableFuture，因为Executors工厂类提供的工厂方法将线程都设置为非守护线程,这样看起来就优雅了很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class cf1 &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        ExecutorService pool = Executors.newFixedThreadPool(4);</div><div class="line">        CompletableFuture.supplyAsync(cf1::getSomeThing,pool).whenComplete((v,t)-&gt;&#123;</div><div class="line">            Optional.ofNullable(v).ifPresent(System.out::println);</div><div class="line">            Optional.ofNullable(t).ifPresent(System.out::println);</div><div class="line">        &#125;);</div><div class="line">        System.out.println(&quot; i am not blocked&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    public static String getSomeThing()&#123;</div><div class="line">        try &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(2);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return &quot;success&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Stage-2"><a href="#Stage-2" class="headerlink" title="Stage 2"></a>Stage 2</h4><p>现在我们成功打印出了success,那么如果我想在上面的任务完成以后对success进行一下处理呢，比如说在success之后添加几个字符。</p><p>首先添加一个简单的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static String addCharacter(String stage1)&#123;</div><div class="line">    try &#123;</div><div class="line">        TimeUnit.SECONDS.sleep(1);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return stage1+&quot;  success2&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">                .supplyAsync(cf1::getSomeThing,pool)</div><div class="line">                .thenApply(cf1::addCharacter)</div><div class="line">                .whenComplete((v,t)-&gt;&#123;</div><div class="line">            Optional.ofNullable(v).ifPresent(System.out::println);</div><div class="line">            Optional.ofNullable(t).ifPresent(System.out::println);</div><div class="line">        &#125;);</div></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> i am not blocked</div><div class="line">success  success2</div></pre></td></tr></table></figure><h4 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h4><p>调用了CompletableFuture几个最基本的Api，模拟一个实际场景并使用可以很好的记住它。现在假设有个商店，我要对5个商品，根据id取出商品，并对商品的价格*10。对于上面的方法，我们可以对一个商品进行这样的操作，那么5个商品该如何操作呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class cf1 &#123;</div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        ExecutorService pool = Executors.newFixedThreadPool(4);</div><div class="line">        List&lt;Integer&gt; ids = Arrays.asList(1, 2, 3, 4, 5);</div><div class="line">        List&lt;Double&gt; res = ids.stream()</div><div class="line">                .map(i -&gt; CompletableFuture.supplyAsync(() -&gt; queryProduct(i), pool))</div><div class="line">                .map(future -&gt; future.thenApply(cf1::multiply))</div><div class="line">                .map(CompletableFuture::join)</div><div class="line">                .collect(toList());</div><div class="line">        System.out.println(res);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Double multiply(Double price)&#123;</div><div class="line">        System.out.println(price);</div><div class="line">        return price*10;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static double queryProduct(int id)&#123;</div><div class="line">        try &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(1);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return new Random(System.currentTimeMillis()).nextInt(20);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">13.0</div><div class="line">13.0</div><div class="line">17.0</div><div class="line">1.0</div><div class="line">4.0</div><div class="line">[130.0, 130.0, 170.0, 10.0, 40.0]</div></pre></td></tr></table></figure><p>这里使用java8中的stream语法，当然也可以拆开来做，效果是相同的。</p><h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><p>CompletableFuture还有大量的API，但是有很多功能都是相似的。这里挑选几个功能比较典型的来感受一下。</p><h4 id="whenComplete-amp-whenCompleteAsync"><a href="#whenComplete-amp-whenCompleteAsync" class="headerlink" title="whenComplete&amp; whenCompleteAsync"></a>whenComplete&amp; whenCompleteAsync</h4><p>首先还是上面提到的api，简单的调用一下，最后打印11。whenComplete的调用方式是同步的，whenCompleteAsync则是异步的调用，如果你对结果需要进行耗时的处理，那么可以使用异步的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">              .supplyAsync(()-&gt;1)</div><div class="line">              .thenApply(i-&gt;Integer.sum(i,10))</div><div class="line">              .whenComplete((v,t)-&gt; System.out.println(v));</div><div class="line">      TimeUnit.SECONDS.sleep(3);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">        .supplyAsync(()-&gt;1)</div><div class="line">        .thenApply(i-&gt;Integer.sum(i,10))</div><div class="line">        .whenCompleteAsync((v,t)-&gt; System.out.println(v));</div><div class="line">TimeUnit.SECONDS.sleep(3);</div></pre></td></tr></table></figure><h4 id="handle-amp-amp-handleAsync"><a href="#handle-amp-amp-handleAsync" class="headerlink" title="handle&amp;&amp;handleAsync"></a>handle&amp;&amp;handleAsync</h4><p>对于上面的方法，可以使用handle来替换。可以看到hanle方法替换了thenApply，区别就是在这一步handle方法考虑到了出现异常，如果有可能出现异常，那么可以使用handle方法。方法handleAsync<br>就是异步的执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">              .supplyAsync(()-&gt;1)</div><div class="line">              .handle((v,t)-&gt;&#123;</div><div class="line">                  if(t!=null)&#123;</div><div class="line">                      t.printStackTrace();</div><div class="line">                  &#125;</div><div class="line">                  return Integer.sum(v,10);</div><div class="line">              &#125;)</div><div class="line">              .whenCompleteAsync((v,t)-&gt; System.out.println(v));</div><div class="line">      TimeUnit.SECONDS.sleep(3);</div></pre></td></tr></table></figure><h4 id="thenRun-amp-amp-thenRunAsync"><a href="#thenRun-amp-amp-thenRunAsync" class="headerlink" title="thenRun&amp;&amp;thenRunAsync"></a>thenRun&amp;&amp;thenRunAsync</h4><p>thenRun方法接受的参数是一个runable,这里简单的调用一下这个方法，效果就是多打印一个空行。那么thenRun和thenRunAsync方法的区别是什么呢，thenRun接受runnable之后则开启一个线程执行，而thenRunAsync则是将runnable交给CompletableFuture的线程池来执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">        .supplyAsync(()-&gt;1)</div><div class="line">        .handle((v,t)-&gt;&#123;</div><div class="line">            if(t!=null)&#123;</div><div class="line">                t.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            return Integer.sum(v,10);</div><div class="line">        &#125;)</div><div class="line">        .whenCompleteAsync((v,t)-&gt; System.out.println(v))</div><div class="line">        .thenRun(System.out::println);</div><div class="line">TimeUnit.SECONDS.sleep(3);</div></pre></td></tr></table></figure><h4 id="thenAccept-amp-amp-thenAcceptAsync"><a href="#thenAccept-amp-amp-thenAcceptAsync" class="headerlink" title="thenAccept&amp;&amp;thenAcceptAsync"></a>thenAccept&amp;&amp;thenAcceptAsync</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">        .supplyAsync(()-&gt;1)</div><div class="line">        .thenAccept(System.out::println);</div></pre></td></tr></table></figure><p>thenAccept方法接收的参数是一个consumer，也就是说它只会进行消费，没有返回值。当然这个方法在上面的练习中可以替换whenComplete方法</p><h4 id="thenCompose-amp-amp-thenComposeAsync"><a href="#thenCompose-amp-amp-thenComposeAsync" class="headerlink" title="thenCompose&amp;&amp;thenComposeAsync"></a>thenCompose&amp;&amp;thenComposeAsync</h4><p>thenCompose可以用来组合CompletableFuture，也就是一个forkJoinPool调用了另一个ForkJoinPool去执行任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">        .supplyAsync(()-&gt;1)</div><div class="line">        .thenCompose(i-&gt;CompletableFuture.supplyAsync(()-&gt;Integer.sum(i,10)))</div><div class="line">        .thenAccept(System.out::println);</div><div class="line">TimeUnit.SECONDS.sleep(3);</div></pre></td></tr></table></figure><h4 id="thenCombine-amp-amp-thenCombineAsync"><a href="#thenCombine-amp-amp-thenCombineAsync" class="headerlink" title="thenCombine&amp;&amp;thenCombineAsync"></a>thenCombine&amp;&amp;thenCombineAsync</h4><p>thenCombine方法用于处理两个CompletableFuture的返回值,这里简单的将两个返回值做了乘法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CompletableFuture</div><div class="line">        .supplyAsync(()-&gt;1)</div><div class="line">        .thenCombine(CompletableFuture.supplyAsync(()-&gt;10),(c1,c2)-&gt;c1*c2)</div><div class="line">        .thenAccept(System.out::println);</div></pre></td></tr></table></figure><h4 id="thenAcceptBoth-amp-amp-thenAcceptBothAsync"><a href="#thenAcceptBoth-amp-amp-thenAcceptBothAsync" class="headerlink" title="thenAcceptBoth&amp;&amp;thenAcceptBothAsync"></a>thenAcceptBoth&amp;&amp;thenAcceptBothAsync</h4><p>thenAcceptBoth方法的使用和thenCombine方法相同，区别在于thenAcceptBoth没有返回值，也就是无法将操作值继续传递下去。</p><h4 id="runAfterBoth-amp-amp-runAfterBothAsync"><a href="#runAfterBoth-amp-amp-runAfterBothAsync" class="headerlink" title="runAfterBoth&amp;&amp;runAfterBothAsync"></a>runAfterBoth&amp;&amp;runAfterBothAsync</h4><p>runAfterBoth需要传入两个参数，第一个参数是一个completableFuture，第二个参数是一个runnable。在两个completableFuture任务完成后，会调用runnable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        CompletableFuture.supplyAsync(()-&gt; &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;done&quot;);</div><div class="line">            return 1;</div><div class="line">        &#125;)</div><div class="line">                .runAfterBoth(CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName()+&quot;done&quot;);</div><div class="line">                    return 1;</div><div class="line">                &#125;),()-&gt; System.out.println(&quot;ALL DONE&quot;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">ForkJoinPool.commonPool-worker-1done</div><div class="line">ForkJoinPool.commonPool-worker-1done</div><div class="line">ALL DONE</div></pre></td></tr></table></figure><h4 id="applyToEither-amp-amp-applyToEitherAsync"><a href="#applyToEither-amp-amp-applyToEitherAsync" class="headerlink" title="applyToEither&amp;&amp; applyToEitherAsync"></a>applyToEither&amp;&amp; applyToEitherAsync</h4><p>用法与runAfterBoth相同，却别是applyToEither是等两个completableFuture都完成才可以执行runnable,而applyToEither是任何一个完成就会调用runnable。但是要注意的是，一个任务完成以后，另一个任务不会被杀死，会继续计算，所以一定要注意这种游离线程的回收，否则时间久了可能对服务器造成影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    CompletableFuture.supplyAsync(()-&gt; &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;done&quot;);</div><div class="line">        return 1;</div><div class="line">    &#125;).applyToEither(CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">        System.out.println(&quot;stage2&quot;);</div><div class="line">        return 2;</div><div class="line">    &#125;),i-&gt;i*10).thenAccept(System.out::println);</div><div class="line"></div><div class="line">    Thread.currentThread().join();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外这里我们可以发现一个规律，带apply关键字的都是有返回值的，accept则没有返回值。</p><h4 id="acceptEither-amp-amp-acceptEitherAsync"><a href="#acceptEither-amp-amp-acceptEitherAsync" class="headerlink" title="acceptEither&amp;&amp; acceptEitherAsync"></a>acceptEither&amp;&amp; acceptEitherAsync</h4><p>和上面的函数参数相同，区别就在于第二个参数是一个consumer，只能消耗计算结果，不产生返回值。</p><h4 id="runAfterEither-amp-amp-runAfterEitherAsync"><a href="#runAfterEither-amp-amp-runAfterEitherAsync" class="headerlink" title="runAfterEither&amp;&amp;runAfterEitherAsync"></a>runAfterEither&amp;&amp;runAfterEitherAsync</h4><p>和上面的函数参数相同，区别就在于第二个参数是一个runnable，不接收参数，可以用来做一些通知的动作。</p><h4 id="allof"><a href="#allof" class="headerlink" title="allof"></a>allof</h4><p>allof函数接收一个CompletableFuture的数组，等待数组中所有任务完成之后会执行后续的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">    List&lt;CompletableFuture&lt;Object&gt;&gt; list = Arrays.asList(1, 2, 3, 4, 5)</div><div class="line">            .stream()</div><div class="line">            .map(i -&gt; CompletableFuture.supplyAsync(cf3::doSomething))</div><div class="line">            .collect(toList());</div><div class="line">    CompletableFuture.allOf(list.toArray(new CompletableFuture[list.size()]))</div><div class="line">                   .thenRun(()-&gt; System.out.println(&quot;done&quot;));</div><div class="line">    Thread.currentThread().join();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里在allof之后调用了thenRun方法，打印一行通知。</p><h4 id="anyof"><a href="#anyof" class="headerlink" title="anyof"></a>anyof</h4><p>anyof的使用和allof相同，区别在于allof等待所有任务完成，anyof等待任意一个任务完成之后便继续执行。同样剩余的任务也会继续执行，不会被回收，所以调用any类型的方法时应该注意游离线程的回收。</p></the>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-阻塞队列(11)</title>
      <link href="/2018/02/13/JUC-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-11/"/>
      <url>/2018/02/13/JUC-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-11/</url>
      
        <content type="html"><![CDATA[<p>在第十节Executor框架中，看到了阻塞队列这种结构。之前没有仔细看过，今天看看源码，大概都有哪些实现方式。</p><p>BlockingQueue的出现，简化了生产者-消费者场景的复杂性。BlockingQueue的特性就是当队列中不存在元素的时候，取出元素方法陷入阻塞。当队列满的时候，插入元素方法陷入阻塞。</p><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h3><p>阻塞队列的顶级接口BlockingQueue中的方法如图，其中remove(o)移除元素o，drainTo()将当前队列中的元素复制到集合c并清空队列。</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180213151849839927459.png" alt="20180213151849839927459.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;</div><div class="line"></div><div class="line">    //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</div><div class="line">    //在成功时返回 true，如果此队列已满，则抛IllegalStateException。</div><div class="line">    boolean add(E e);</div><div class="line"></div><div class="line">    //将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量）</div><div class="line">    // 将指定的元素插入此队列的尾部，如果该队列已满，</div><div class="line">    //则在到达指定的等待时间之前等待可用的空间,该方法可中断</div><div class="line">    boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;</div><div class="line"></div><div class="line">    //将指定的元素插入此队列的尾部，如果该队列已满，则一直等到（阻塞）。</div><div class="line">    void put(E e) throws InterruptedException;</div><div class="line"></div><div class="line">    //获取并移除此队列的头部，如果没有元素则等待（阻塞），</div><div class="line">    //直到有元素将唤醒等待线程执行该操作</div><div class="line">    E take() throws InterruptedException;</div><div class="line"></div><div class="line">    //获取并移除此队列的头部，在指定的等待时间前一直等到获取元素， //超过时间方法将结束</div><div class="line">    E poll(long timeout, TimeUnit unit) throws InterruptedException;</div><div class="line"></div><div class="line">    //从此队列中移除指定元素的单个实例（如果存在）。</div><div class="line">    boolean remove(Object o);</div><div class="line"></div><div class="line"></div><div class="line">    //除了上述方法还有继承自Queue接口的方法</div><div class="line">    //获取但不移除此队列的头元素,没有则跑异常NoSuchElementException</div><div class="line">    E element();</div><div class="line"></div><div class="line">    //获取但不移除此队列的头；如果此队列为空，则返回 null。</div><div class="line">    E peek();</div><div class="line"></div><div class="line">    //获取并移除此队列的头，如果此队列为空，则返回 null。</div><div class="line">    E poll();</div></pre></td></tr></table></figure><p>java8提供了以下七种BlockingQueue的实现，blockingQueue的实现都保证是线程安全的。</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180213151849962127017.png" alt="20180213151849962127017.png"></p><pre><code>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。DelayQueue：一个使用优先级队列实现的无界阻塞队列。SynchronousQueue：一个不存储元素的阻塞队列。LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</code></pre><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</div><div class="line">    if (capacity &lt;= 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    this.items = new Object[capacity];</div><div class="line">    lock = new ReentrantLock(fair);</div><div class="line">    notEmpty = lock.newCondition();</div><div class="line">    notFull =  lock.newCondition();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从构造函数可以看出ArrayBlockingQueue是支持公平或非公平的访问，同时队列对非空和非满的情况分别加锁，内部存储的数据结构是Object[]类型。</p><blockquote><p>添加元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();</div><div class="line">    try &#123;</div><div class="line">        if (count == items.length)</div><div class="line">            return false;</div><div class="line">        else &#123;</div><div class="line">            enqueue(e);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>逻辑很简单，首先判断添加的元素必须非空，然后加锁，判断长度是否越界，如果没有则入队，否则返回false，最后释放锁。</p><blockquote><p>取出元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public E poll() &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();</div><div class="line">    try &#123;</div><div class="line">        return (count == 0) ? null : dequeue();</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先加锁，判断队列是否为空，若不为空则出队一个元素，否则返回null。最后释放锁。</p><p>ArrayBlockingQueue的整体实现都比较简单，除了核心的入队出队方法，还提供了一些监控队列的方法。比较简单的一种阻塞队列实现，不作过多分析。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue在内部将每个添加进来的元素封装为一个Node节点，并记录前驱节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;E&gt; &#123;</div><div class="line">    E item;</div><div class="line"></div><div class="line">    Node&lt;E&gt; next;</div><div class="line"></div><div class="line">    Node(E x) &#123; item = x; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LinkedBlockingQueue按照先进先出排序(FIFO),新的元素插入到tail，每次取出head元素。队列的最大容量是Integer.MAX_VALUE，这里需要注意，如果不手动设置大小，并且生产者生产速度大于消费速度，那么很有可能造成内存泄漏(OOM)。LinkedBlockingQueue内部分别使用了takeLock 和 putLock 对并发进行控制，也就是说，添加和删除操作并不是互斥操作，可以同时进行，这样也就可以大大提高吞吐量。</p><blockquote><p>添加元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">     //添加元素为null直接抛出异常</div><div class="line">     if (e == null) throw new NullPointerException();</div><div class="line">      //获取队列的个数</div><div class="line">      final AtomicInteger count = this.count;</div><div class="line">      //判断队列是否已满</div><div class="line">      if (count.get() == capacity)</div><div class="line">          return false;</div><div class="line">      int c = -1;</div><div class="line">      //构建节点</div><div class="line">      Node&lt;E&gt; node = new Node&lt;E&gt;(e);</div><div class="line">      final ReentrantLock putLock = this.putLock;</div><div class="line">      putLock.lock();</div><div class="line">      try &#123;</div><div class="line">          //再次判断队列是否已满，考虑并发情况</div><div class="line">          if (count.get() &lt; capacity) &#123;</div><div class="line">              enqueue(node);//添加元素</div><div class="line">              c = count.getAndIncrement();//拿到当前未添加新元素时的队列长度</div><div class="line">              //如果容量还没满</div><div class="line">              if (c + 1 &lt; capacity)</div><div class="line">                  notFull.signal();//唤醒下一个添加线程，执行添加操作</div><div class="line">          &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">          putLock.unlock();</div><div class="line">      &#125;</div><div class="line">      // 由于存在添加锁和消费锁，而消费锁和添加锁都会持续唤醒等到线程，因此count肯定会变化。</div><div class="line">      //因为初始化c=-1,这里的if条件表示如果队列中还有1条数据</div><div class="line">      if (c == 0)</div><div class="line">        signalNotEmpty();//如果还存在数据那么就唤醒消费锁</div><div class="line">    return c &gt;= 0; // 添加成功返回true，否则返回false</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>这里的一个技巧就是对c值的处理，初看起来让人感觉摸不着头脑。首要要明确的是</p><p>c = count.getAndIncrement()实际上获取的是元素未入队之前的长度，如果c=0,那么实际上队列中有一个等待被消费的元素。因为消费线程一旦被唤醒是一直在消费的（前提是有数据），所以判断c&gt;0其实没有任何特殊意义。只有当c=0的时候，说明之前队列中没有元素，消费者陷入阻塞，那么这时添加元素之后对其进行唤醒才有意义。(这里还是比较绕的)</p><blockquote><p>取出元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    E x;</div><div class="line">    int c = -1;</div><div class="line">    final AtomicInteger count = this.count;</div><div class="line">    final ReentrantLock takeLock = this.takeLock;</div><div class="line">    takeLock.lockInterruptibly();</div><div class="line">    try &#123;</div><div class="line">        while (count.get() == 0) &#123;</div><div class="line">            notEmpty.await();</div><div class="line">        &#125;</div><div class="line">        x = dequeue();</div><div class="line">        c = count.getAndDecrement();</div><div class="line">        if (c &gt; 1)</div><div class="line">            notEmpty.signal();</div><div class="line">    &#125; finally &#123;</div><div class="line">        takeLock.unlock();</div><div class="line">    &#125;</div><div class="line">    if (c == capacity)</div><div class="line">        signalNotFull();</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与添加元素的逻辑正好相反，理解一个另一个就很好理解，不作过多解释。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public PriorityBlockingQueue(int initialCapacity,</div><div class="line">                             Comparator&lt;? super E&gt; comparator) &#123;</div><div class="line">    if (initialCapacity &lt; 1)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    this.lock = new ReentrantLock();</div><div class="line">    this.notEmpty = lock.newCondition();</div><div class="line">    this.comparator = comparator;</div><div class="line">    this.queue = new Object[initialCapacity];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据构造函数可知，可以控制的参数是容量和比较规则，capacity默认大小为11，默认的比较器为null表示自然排序。可以根据需求控制PriorityBlockingQueue优先级从高到低还是从低到高。与ArrayBlockingQueue类似，队列中的元素都封装为object[]。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final Condition notEmpty;</div></pre></td></tr></table></figure><p>可以看到的是PriorityBlockingQueue并不会阻塞数据生产者，而只是在没有可消费的数据时阻塞数据的消费者，因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。</p><p>PriorityBlockingQueue的方法都比较简单，没有什么特别坑的地方。</p><p>###DelayQueue</p><p>DelayQueue的关键元素BlockingQueue、PriorityQueue、Delayed。可以这么说，DelayQueue是一个使用优先队列（PriorityQueue）实现的BlockingQueue，优先队列的比较基准值是时间。</p><p>入队的方法比较简单，这里看一下出队的方法</p><blockquote><p>取出元素</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    try &#123;</div><div class="line">    //可以看出 take方法实际上是一个阻塞式的方法。</div><div class="line">        for (;;) &#123;</div><div class="line">            E first = q.peek();</div><div class="line">            if (first == null) &#123;</div><div class="line">    //队列中没有元素 就一直等待</div><div class="line">                available.await();</div><div class="line">            &#125; else &#123;</div><div class="line">                long delay =  first.getDelay(TimeUnit.NANOSECONDS);</div><div class="line">                if (delay &gt; 0) &#123;</div><div class="line">    //还没到时间，继续等待</div><div class="line">                    long tl = available.awaitNanos(delay);</div><div class="line">                &#125; else &#123;</div><div class="line">    //取出元素执行</div><div class="line">                    E x = q.poll();</div><div class="line">                    assert x != null;</div><div class="line">                    if (q.size() != 0)</div><div class="line">                        available.signalAll(); // wake up other takers</div><div class="line">                    return x;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>Executors.newCachedThreadPool()就使用了SynchronousQueue。这个Queue比较有意思:isEmpty()方法永远返回true，remainingCapacity()方法永远返回0，remove()和removeAll() 方法永远返回false，iterator()方法永远返回null，peek()方法永远返回null，故我们不能通过调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，同样遍历这个队列的操作也是不允许的。</p><p>并且要注意的是A线程将数据放入队列中，直到有线程将数据取走，A线程都处于阻塞状态。可以理解为一种线程之间一对一传值的模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public SynchronousQueue(boolean fair) &#123;</div><div class="line">    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据构造函数，可以发现SynchronousQueue支持公平与非公平的队列。公平队列的实现是TransferQueue，非公平队列的实现是TransferStack。TransferStack与TransferQueue都继承自内部类Transfer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">abstract static class Transferer&lt;E&gt; &#123;</div><div class="line">    abstract E transfer(E e, boolean timed, long nanos);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Transfer只提供了一个transfer抽象方法，子类提供具体实现。</p><p>SynchronousQueue的插入和删除元素方法都是调用transfer方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    if (e == null) throw new NullPointerException();</div><div class="line">    return transferer.transfer(e, true, 0) != null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public E take() throws InterruptedException &#123;</div><div class="line">    E e = transferer.transfer(null, false, 0);</div><div class="line">    if (e != null)</div><div class="line">        return e;</div><div class="line">    Thread.interrupted();</div><div class="line">    throw new InterruptedException();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以研究这个阻塞队列，关键的就是研究两个实现类的transfer方法。</p><h4 id="TransferQueue"><a href="#TransferQueue" class="headerlink" title="TransferQueue"></a>TransferQueue</h4><p>代码看起来很复杂。。。但是可以先梳理一下思路，既然是公平队列，而且名字以Queue结尾，那么应该是FIFO的方式，关键在于看他怎么处理头结点和尾节点的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div></pre></td><td class="code"><pre><div class="line">static final class TransferQueue extends Transferer &#123;</div><div class="line"></div><div class="line"> 本算法实现拓展了Scherer-Scott双队列算法，不同的是用节点模式，</div><div class="line"> 而不是标记指针来区分节点操作类型。这个算法比栈算法的实现简单，</div><div class="line"> 因为fulfillers需要明确指定节点，同时匹配节点用CAS操作QNode的</div><div class="line"> 元素field即可，put操作从非null到null，反则亦然，take从null到非null。</div><div class="line"></div><div class="line"></div><div class="line">       /** Node class for TransferQueue. */</div><div class="line">       static final class QNode &#123;</div><div class="line">           volatile QNode next;          // next node in queue 后继</div><div class="line">           volatile Object item;         // CAS&apos;ed to or from null 节点元素</div><div class="line">           volatile Thread waiter;       // to control park/unpark 等待线程</div><div class="line">           final boolean isData; //是否为DATA模式</div><div class="line">           //设置元素和模式</div><div class="line">           QNode(Object item, boolean isData) &#123;</div><div class="line">               this.item = item;</div><div class="line">               this.isData = isData;</div><div class="line">           &#125;</div><div class="line">           //设置节点的后继</div><div class="line">           boolean casNext(QNode cmp, QNode val) &#123;</div><div class="line">               return next == cmp &amp;&amp;</div><div class="line">                   UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</div><div class="line">           &#125;</div><div class="line">    //设置节点的元素</div><div class="line">           boolean casItem(Object cmp, Object val) &#123;</div><div class="line">               return item == cmp &amp;&amp;</div><div class="line">                   UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /**</div><div class="line">            * Tries to cancel by CAS&apos;ing ref to this as item.</div><div class="line">     取消节点等待，元素指向自己</div><div class="line">            */</div><div class="line">           void tryCancel(Object cmp) &#123;</div><div class="line">               UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);</div><div class="line">           &#125;</div><div class="line">           //是否取消等待</div><div class="line">           boolean isCancelled() &#123;</div><div class="line">               return item == this;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /**</div><div class="line">            * Returns true if this node is known to be off the queue</div><div class="line">            * because its next pointer has been forgotten due to</div><div class="line">            * an advanceHead operation.</div><div class="line">     是否出队列</div><div class="line">            */</div><div class="line">           boolean isOffList() &#123;</div><div class="line">               return next == this;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // Unsafe mechanics</div><div class="line">           private static final sun.misc.Unsafe UNSAFE;</div><div class="line">           private static final long itemOffset;</div><div class="line">           private static final long nextOffset;</div><div class="line"></div><div class="line">           static &#123;</div><div class="line">               try &#123;</div><div class="line">                   UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class="line">                   Class k = QNode.class;</div><div class="line">                   itemOffset = UNSAFE.objectFieldOffset</div><div class="line">                       (k.getDeclaredField(&quot;item&quot;));</div><div class="line">                   nextOffset = UNSAFE.objectFieldOffset</div><div class="line">                       (k.getDeclaredField(&quot;next&quot;));</div><div class="line">               &#125; catch (Exception e) &#123;</div><div class="line">                   throw new Error(e);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /** Head of queue  队列头节点*/</div><div class="line">       transient volatile QNode head;</div><div class="line">       /** Tail of queue 队列尾节点*/</div><div class="line">       transient volatile QNode tail;</div><div class="line">       /**</div><div class="line">        * Reference to a cancelled node that might not yet have been</div><div class="line">        * unlinked from queue because it was the last inserted node</div><div class="line">        * when it cancelled.</div><div class="line"> 刚入队列的节点，取消等待，但还没有出队列的节点，</div><div class="line">        */</div><div class="line">       transient volatile QNode cleanMe;</div><div class="line"></div><div class="line">       TransferQueue() &#123;</div><div class="line">    //构造队列</div><div class="line">           QNode h = new QNode(null, false); // initialize to dummy node.</div><div class="line">           head = h;</div><div class="line">           tail = h;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Tries to cas nh as new head; if successful, unlink</div><div class="line">        * old head&apos;s next node to avoid garbage retention.</div><div class="line"> 尝试设置新的队头节点为nh，并比较旧头节点，成功则，解除旧队列头节点的next链接，及指向自己</div><div class="line">        */</div><div class="line">       void advanceHead(QNode h, QNode nh) &#123;</div><div class="line">           if (h == head &amp;&amp;</div><div class="line">               UNSAFE.compareAndSwapObject(this, headOffset, h, nh))</div><div class="line">               h.next = h; // forget old next</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Tries to cas nt as new tail.</div><div class="line"> 尝试设置队尾</div><div class="line">        */</div><div class="line">       void advanceTail(QNode t, QNode nt) &#123;</div><div class="line">           if (tail == t)</div><div class="line">               UNSAFE.compareAndSwapObject(this, tailOffset, t, nt);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Tries to CAS cleanMe slot.</div><div class="line"> 尝试设置取消等待节点为val。并比较旧的等待节点是否为cmp</div><div class="line">        */</div><div class="line">       boolean casCleanMe(QNode cmp, QNode val) &#123;</div><div class="line">           return cleanMe == cmp &amp;&amp;</div><div class="line">               UNSAFE.compareAndSwapObject(this, cleanMeOffset, cmp, val);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Puts or takes an item.</div><div class="line"> 生产或消费一个元素</div><div class="line">        */</div><div class="line">       Object transfer(Object e, boolean timed, long nanos) &#123;</div><div class="line">           /* Basic algorithm is to loop trying to take either of</div><div class="line">            * two actions:</div><div class="line">            *</div><div class="line">     基本算法是循环尝试，执行下面两个步中的，其中一个：</div><div class="line">            * 1. If queue apparently empty or holding same-mode nodes,</div><div class="line">            *    try to add node to queue of waiters, wait to be</div><div class="line">            *    fulfilled (or cancelled) and return matching item.</div><div class="line">            *</div><div class="line">     1.如果队列为空，或队列中为相同模式的节点，尝试节点入队列等待，</div><div class="line">     直到fulfilled，返回匹配元素，或者由于中断，超时取消等待。</div><div class="line">            * 2. If queue apparently contains waiting items, and this</div><div class="line">            *    call is of complementary mode, try to fulfill by CAS&apos;ing</div><div class="line">            *    item field of waiting node and dequeuing it, and then</div><div class="line">            *    returning matching item.</div><div class="line">            *</div><div class="line">     2.如果队列中包含节点，transfer方法被一个协同模式的节点调用，</div><div class="line">     则尝试补给或填充等待线程节点的元素，并出队列，返回匹配元素。</div><div class="line">            * In each case, along the way, check for and try to help</div><div class="line">            * advance head and tail on behalf of other stalled/slow</div><div class="line">            * threads.</div><div class="line">            *</div><div class="line">     在每一种情况，执行的过程中，检查和尝试帮助其他stalled/slow线程移动队列头和尾节点</div><div class="line">            * The loop starts off with a null check guarding against</div><div class="line">            * seeing uninitialized head or tail values. This never</div><div class="line">            * happens in current SynchronousQueue, but could if</div><div class="line">            * callers held non-volatile/final ref to the</div><div class="line">            * transferer. The check is here anyway because it places</div><div class="line">            * null checks at top of loop, which is usually faster</div><div class="line">            * than having them implicitly interspersed.</div><div class="line">     循环开始，首先进行null检查，防止为初始队列头和尾节点。当然这种情况，</div><div class="line">     在当前同步队列中，不可能发生，如果调用持有transferer的non-volatile/final引用，</div><div class="line">     可能出现这种情况。一般在循环的开始，都要进行null检查，检查过程非常快，不用过多担心</div><div class="line">     性能问题。</div><div class="line">            */</div><div class="line"></div><div class="line">           QNode s = null; // constructed/reused as needed</div><div class="line">    //如果元素e不为null，则为DATA模式，否则为REQUEST模式</div><div class="line">           boolean isData = (e != null);</div><div class="line"></div><div class="line">           for (;;) &#123;</div><div class="line">               QNode t = tail;</div><div class="line">               QNode h = head;</div><div class="line">    //如果队列头或尾节点没有初始化，则跳出本次自旋</div><div class="line">               if (t == null || h == null)         // saw uninitialized value</div><div class="line">                   continue;                       // spin</div><div class="line"></div><div class="line">               if (h == t || t.isData == isData) &#123; // empty or same-mode</div><div class="line">        //如果队列为空，或当前节点与队尾模式相同</div><div class="line">                   QNode tn = t.next;</div><div class="line">                   if (t != tail)                  // inconsistent read</div><div class="line">            //如果t不是队尾，非一致性读取，跳出本次自旋</div><div class="line">                       continue;</div><div class="line">                   if (tn != null) &#123;               // lagging tail</div><div class="line">            //如果t的next不为null，设置新的队尾，跳出本次自旋</div><div class="line">                       advanceTail(t, tn);</div><div class="line">                       continue;</div><div class="line">                   &#125;</div><div class="line">                   if (timed &amp;&amp; nanos &lt;= 0)        // can&apos;t wait</div><div class="line">            //如果超时，且超时时间小于0，则返回null</div><div class="line">                       return null;</div><div class="line">                   if (s == null)</div><div class="line">            //根据元素和模式构造节点</div><div class="line">                       s = new QNode(e, isData);</div><div class="line">                   if (!t.casNext(null, s))        // failed to link in</div><div class="line">            //新节点入队列</div><div class="line">                       continue;</div><div class="line">                   //设置队尾为当前节点</div><div class="line">                   advanceTail(t, s);              // swing tail and wait</div><div class="line">        //自旋或阻塞直到节点被fulfilled</div><div class="line">                   Object x = awaitFulfill(s, e, timed, nanos);</div><div class="line">                   if (x == s) &#123;                   // wait was cancelled</div><div class="line">            //如果s指向自己，s出队列，并清除队列中取消等待的线程节点</div><div class="line">                       clean(t, s);</div><div class="line">                       return null;</div><div class="line">                   &#125;</div><div class="line"></div><div class="line">                   if (!s.isOffList()) &#123;           // not already unlinked</div><div class="line">            //如果s节点已经不再队列中，移除</div><div class="line">                       advanceHead(t, s);          // unlink if head</div><div class="line">                       if (x != null)              // and forget fields</div><div class="line">                           s.item = s;</div><div class="line">                       s.waiter = null;</div><div class="line">                   &#125;</div><div class="line">        //如果自旋等待匹配的节点元素不为null，则返回x，否则返回e</div><div class="line">                   return (x != null) ? x : e;</div><div class="line"></div><div class="line">               &#125; else &#123;                            // complementary-mode</div><div class="line">        //如果队列不为空，且与队头的模式不同，及匹配成功</div><div class="line">                   QNode m = h.next;               // node to fulfill</div><div class="line">                   if (t != tail || m == null || h != head)</div><div class="line">            //如果h不为当前队头，则返回，即读取不一致</div><div class="line">                       continue;                   // inconsistent read</div><div class="line">                   Object x = m.item;</div><div class="line">                   if (isData == (x != null) ||    // m already fulfilled</div><div class="line">                       x == m ||                   // m cancelled</div><div class="line">                       !m.casItem(x, e)) &#123;         // lost CAS</div><div class="line">        //如果队头后继，取消等待，则出队列</div><div class="line">                       advanceHead(h, m);          // dequeue and retry</div><div class="line">                       continue;</div><div class="line">                   &#125;</div><div class="line">        //否则匹配成功</div><div class="line">                   advanceHead(h, m);              // successfully fulfilled</div><div class="line">        //unpark等待线程</div><div class="line">                   LockSupport.unpark(m.waiter);</div><div class="line">        //如果匹配节点元素不为null，则返回x，否则返回e，即take操作，返回等待put线程节点元素，</div><div class="line">        //put操作，返回put元素</div><div class="line">                   return (x != null) ? x : e;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Spins/blocks until node s is fulfilled.</div><div class="line">        *</div><div class="line"> 自旋或阻塞直到节点被fulfilled</div><div class="line">        * @param s the waiting node，等待节点</div><div class="line">        * @param e the comparison value for checking match，检查匹配的比较元素</div><div class="line">        * @param timed true if timed wait 是否超时等待</div><div class="line">        * @param nanos timeout value 超时等待时间</div><div class="line">        * @return matched item, or s if cancelled 成功返回匹配元素，取消返回等待元素</div><div class="line">        */</div><div class="line">       Object awaitFulfill(QNode s, Object e, boolean timed, long nanos) &#123;</div><div class="line">           /* Same idea as TransferStack.awaitFulfill 这里与栈中的实现思路是一样的*/</div><div class="line">    //获取超时的当前时间，当前线程，自旋数</div><div class="line">           long lastTime = timed ? System.nanoTime() : 0;</div><div class="line">           Thread w = Thread.currentThread();</div><div class="line">           int spins = ((head.next == s) ?</div><div class="line">                        (timed ? maxTimedSpins : maxUntimedSpins) : 0);</div><div class="line">           for (;;) &#123;</div><div class="line">               if (w.isInterrupted())</div><div class="line">        //如果中断，则取消等待</div><div class="line">                   s.tryCancel(e);</div><div class="line">               Object x = s.item;</div><div class="line">               if (x != e)</div><div class="line">                   return x;//如果s的节点的元素不相等，则返回x,即s节点指向自身，等待clean</div><div class="line">               if (timed) &#123;</div><div class="line">                   long now = System.nanoTime();</div><div class="line">                   nanos -= now - lastTime;</div><div class="line">                   lastTime = now;</div><div class="line">                   if (nanos &lt;= 0) &#123;</div><div class="line">            //如果超时，则取消等待</div><div class="line">                       s.tryCancel(e);</div><div class="line">                       continue;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               if (spins &gt; 0)</div><div class="line">        //自旋数减一</div><div class="line">                   --spins;</div><div class="line">               else if (s.waiter == null)</div><div class="line">         //如果是节点的等待线程为空，则设置为当前线程</div><div class="line">                   s.waiter = w;</div><div class="line">               else if (!timed)</div><div class="line">        //非超时，则park</div><div class="line">                   LockSupport.park(this);</div><div class="line">               else if (nanos &gt; spinForTimeoutThreshold)</div><div class="line">        //超时时间大于自旋时间，则超时park</div><div class="line">                   LockSupport.parkNanos(this, nanos);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Gets rid of cancelled node s with original predecessor pred.</div><div class="line"> 移除队列中取消等待的线程节点</div><div class="line">        */</div><div class="line">       void clean(QNode pred, QNode s) &#123;</div><div class="line">           s.waiter = null; // forget thread</div><div class="line"></div><div class="line">     在任何时候，最后一个节点入队列时，队列中都有可能存在取消等待，但没有删除的节点。</div><div class="line">     为了将这些节点删除，如果我们不能删除最后入队列的节点，我们可以用cleanMe记录它的前驱，</div><div class="line">     删除cleanMe后继节点。s节点和cleanMe后继节点至少一个删除，则停止。</div><div class="line"></div><div class="line">           while (pred.next == s) &#123; // Return early if already unlinked</div><div class="line">        //如果s为队尾节点，且前驱为旧队尾</div><div class="line">               QNode h = head;</div><div class="line">               QNode hn = h.next;   // Absorb cancelled first node as head</div><div class="line">               if (hn != null &amp;&amp; hn.isCancelled()) &#123;</div><div class="line">        //如果队头不为空，且取消等待，设置后继为新的队头元素</div><div class="line">                   advanceHead(h, hn);</div><div class="line">                   continue;</div><div class="line">               &#125;</div><div class="line">               QNode t = tail;      // Ensure consistent read for tail</div><div class="line">               if (t == h)</div><div class="line">        //空队列，则返回</div><div class="line">                   return;</div><div class="line">               QNode tn = t.next;</div><div class="line">               if (t != tail)</div><div class="line">        //如果队尾有变化，跳出循环</div><div class="line">                   continue;</div><div class="line">               if (tn != null) &#123;</div><div class="line">        //如果队尾后继不为null，则设置新的队尾</div><div class="line">                   advanceTail(t, tn);</div><div class="line">                   continue;</div><div class="line">               &#125;</div><div class="line">               if (s != t) &#123;        // If not tail, try to unsplice</div><div class="line">                   QNode sn = s.next;</div><div class="line">                   if (sn == s || pred.casNext(s, sn))</div><div class="line">            //s节点指向自己，则返回</div><div class="line">                       return;</div><div class="line">               &#125;</div><div class="line">               QNode dp = cleanMe;</div><div class="line">               if (dp != null) &#123;    // Try unlinking previous cancelled node</div><div class="line">        //移除前一个取消等待的节点</div><div class="line">                   QNode d = dp.next;</div><div class="line">                   QNode dn;</div><div class="line">                   if (d == null ||               // d is gone or</div><div class="line">                       d == dp ||                 // d is off list or</div><div class="line">                       !d.isCancelled() ||        // d not cancelled or</div><div class="line">                       (d != t &amp;&amp;                 // d not tail and</div><div class="line">                        (dn = d.next) != null &amp;&amp;  //   has successor</div><div class="line">                        dn != d &amp;&amp;                //   that is on list</div><div class="line">                        dp.casNext(d, dn)))       // d unspliced</div><div class="line">                       casCleanMe(dp, null);</div><div class="line">                   if (dp == pred)</div><div class="line">                       return;      // s is already saved node</div><div class="line">               &#125; else if (casCleanMe(null, pred))</div><div class="line">        //先前取消等待的节点为null，则将cleanMe设为刚取消等待节点的前驱</div><div class="line">                   return;          // Postpone cleaning s</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       private static final sun.misc.Unsafe UNSAFE;</div><div class="line">       private static final long headOffset;</div><div class="line">       private static final long tailOffset;</div><div class="line">       private static final long cleanMeOffset;</div><div class="line">       static &#123;</div><div class="line">           try &#123;</div><div class="line">               UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class="line">               Class k = TransferQueue.class;</div><div class="line">               headOffset = UNSAFE.objectFieldOffset</div><div class="line">                   (k.getDeclaredField(&quot;head&quot;));</div><div class="line">               tailOffset = UNSAFE.objectFieldOffset</div><div class="line">                   (k.getDeclaredField(&quot;tail&quot;));</div><div class="line">               cleanMeOffset = UNSAFE.objectFieldOffset</div><div class="line">                   (k.getDeclaredField(&quot;cleanMe&quot;));</div><div class="line">           &#125; catch (Exception e) &#123;</div><div class="line">               throw new Error(e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h4 id="TransferStack"><a href="#TransferStack" class="headerlink" title="TransferStack"></a>TransferStack</h4><p>这么复杂算法，感觉有些大材小用啊。- - !</p><p>TransferStack用于非公平队列的实现，根据栈的特性，应该是先进后出的一种形式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div></pre></td><td class="code"><pre><div class="line">static final class TransferStack extends Transferer &#123;</div><div class="line"></div><div class="line"> 本stack实现的是算法是拓展了Scherer-Scott双栈的算法，所不同的时，用</div><div class="line">covering节点，而不是bit-marked指针：在bit集填充模式下，填充操作将会为</div><div class="line">匹配一个等待节点保留资源，生产一个标记节点。</div><div class="line">        */</div><div class="line"></div><div class="line">       /* Modes for SNodes, ORed together in node fields */</div><div class="line">       /** Node represents an unfulfilled consumer  REQUEST节点表示一个未填充的消费者*/</div><div class="line">       static final int REQUEST    = 0;</div><div class="line">       /** Node represents an unfulfilled producer  DATA节点表示一个未填充的生产者*/</div><div class="line">       static final int DATA       = 1;</div><div class="line">       /** Node is fulfilling another unfulfilled DATA or REQUEST</div><div class="line">FULFILLING节点表示生产者正在给等待资源的消费者补给资源，或生产者在等待消费者消费资源/</div><div class="line">       static final int FULFILLING = 2;</div><div class="line"></div><div class="line">       /** Return true if m has fulfilling bit set</div><div class="line">如果m是一个填充为单元，则返回true*/</div><div class="line">       static boolean isFulfilling(int m) &#123; return (m &amp; FULFILLING) != 0; &#125;</div><div class="line"></div><div class="line">       /** Node class for TransferStacks. 栈节点 */</div><div class="line">       static final class SNode &#123;</div><div class="line">           volatile SNode next;        // next node in stack 节点的后继</div><div class="line">           volatile SNode match;       // the node matched to this 匹配节点</div><div class="line">           volatile Thread waiter;     // to control park/unpark  等待者线程</div><div class="line">           Object item;                // data; or null for REQUESTs 数据，消费者消费的资源</div><div class="line">           int mode;//节点模式</div><div class="line">           // Note: item and mode fields don&apos;t need to be volatile</div><div class="line">           // since they are always written before, and read after,</div><div class="line">           // other volatile/atomic operations.</div><div class="line">           //元素item和mode需要要可见，由于他们总是在其他可见/原子操作写之前，读之后</div><div class="line">           SNode(Object item) &#123;</div><div class="line">               this.item = item;</div><div class="line">           &#125;</div><div class="line">           //设置节点后继</div><div class="line">           boolean casNext(SNode cmp, SNode val) &#123;</div><div class="line">               return cmp == next &amp;&amp;</div><div class="line">                   UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /**</div><div class="line">            * Tries to match node s to this node, if so, waking up thread.</div><div class="line">            * Fulfillers call tryMatch to identify their waiters.</div><div class="line">            * Waiters block until they have been matched.</div><div class="line">            *</div><div class="line">     尝试匹配目标节点与本节点，如果匹配，可以唤醒线程。补给者调用tryMatch方法</div><div class="line">     确定它们的等待线程。等待线程阻塞到它们自己被匹配。如果匹配返回true。</div><div class="line">            * @param s the node to match</div><div class="line">            * @return true if successfully matched to s</div><div class="line">            */</div><div class="line">           boolean tryMatch(SNode s) &#123;</div><div class="line">               if (match == null &amp;&amp;</div><div class="line">                   UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123;</div><div class="line">                   Thread w = waiter;</div><div class="line">        //如果等待者不为null，则unpark等待线程</div><div class="line">                   if (w != null) &#123;    // waiters need at most one unpark</div><div class="line">                       waiter = null;</div><div class="line">                       LockSupport.unpark(w);</div><div class="line">                   &#125;</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">               return match == s;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           /**</div><div class="line">            * Tries to cancel a wait by matching node to itself.节点尝试取消等待</div><div class="line">            */</div><div class="line">           void tryCancel() &#123;</div><div class="line">               UNSAFE.compareAndSwapObject(this, matchOffset, null, this);</div><div class="line">           &#125;</div><div class="line">           //match指向自己，则取消等待</div><div class="line">           boolean isCancelled() &#123;</div><div class="line">               return match == this;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           // Unsafe mechanics</div><div class="line">           private static final sun.misc.Unsafe UNSAFE;</div><div class="line">           private static final long matchOffset;</div><div class="line">           private static final long nextOffset;</div><div class="line"></div><div class="line">           static &#123;</div><div class="line">               try &#123;</div><div class="line">                   UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class="line">                   Class k = SNode.class;</div><div class="line">                   matchOffset = UNSAFE.objectFieldOffset</div><div class="line">                       (k.getDeclaredField(&quot;match&quot;));</div><div class="line">                   nextOffset = UNSAFE.objectFieldOffset</div><div class="line">                       (k.getDeclaredField(&quot;next&quot;));</div><div class="line">               &#125; catch (Exception e) &#123;</div><div class="line">                   throw new Error(e);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /** The head (top) of the stack 栈头节点*/</div><div class="line">       volatile SNode head;</div><div class="line">       //CAS操作nh为当前head，并比较head旧值是否为h</div><div class="line">       boolean casHead(SNode h, SNode nh) &#123;</div><div class="line">           return h == head &amp;&amp;</div><div class="line">               UNSAFE.compareAndSwapObject(this, headOffset, h, nh);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Creates or resets fields of a node. Called only from transfer</div><div class="line">        * where the node to push on stack is lazily created and</div><div class="line">        * reused when possible to help reduce intervals between reads</div><div class="line">        * and CASes of head and to avoid surges of garbage when CASes</div><div class="line">        * to push nodes fail due to contention.</div><div class="line"> 创建或重新设置节点的fields。在节点入栈懒创建，在当可能需要保证减少intervals（间隔）</div><div class="line"> 读和head的CAS操或避免由于竞争CAS操作节点入栈引起的垃圾时，此方法会被transfer调用</div><div class="line">        */</div><div class="line">       static SNode snode(SNode s, Object e, SNode next, int mode) &#123;</div><div class="line">           if (s == null) s = new SNode(e);</div><div class="line">           s.mode = mode;</div><div class="line">           s.next = next;</div><div class="line">           return s;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Puts or takes an item.</div><div class="line"> put或take一个元素</div><div class="line">        */</div><div class="line">       Object transfer(Object e, boolean timed, long nanos) &#123;</div><div class="line">           /*</div><div class="line">            * Basic algorithm is to loop trying one of three actions:</div><div class="line">            *</div><div class="line">     算法的基本步骤是，循环尝试一下3步</div><div class="line">            * 1. If apparently empty or already containing nodes of same</div><div class="line">            *    mode, try to push node on stack and wait for a match,</div><div class="line">            *    returning it, or null if cancelled.</div><div class="line">            *</div><div class="line">     1.如果队列为空或已经包含相同模式的节点，则尝试节点入栈，等待匹配，</div><div class="line">     返回，如果取消返回null。</div><div class="line">            * 2. If apparently containing node of complementary mode,</div><div class="line">            *    try to push a fulfilling node on to stack, match</div><div class="line">            *    with corresponding waiting node, pop both from</div><div class="line">            *    stack, and return matched item. The matching or</div><div class="line">            *    unlinking might not actually be necessary because of</div><div class="line">            *    other threads performing action 3:</div><div class="line">            *</div><div class="line">     2.如果包含一个互补模式的节点（take(REQUEST)-&gt;put(DATA)；put(DATA)-&gt;take(REQUEST)），</div><div class="line">     则尝试一个FULFILLING节点入栈，同时匹配等待的协同节点，两个节点同时出栈，返回匹配的元素。</div><div class="line">     由于其他线程执行步骤3，实际匹配和解除链接指针动作不会发生。</div><div class="line"></div><div class="line">            * 3. If top of stack already holds another fulfilling node,</div><div class="line">            *    help it out by doing its match and/or pop</div><div class="line">            *    operations, and then continue. The code for helping</div><div class="line">            *    is essentially the same as for fulfilling, except</div><div class="line">            *    that it doesn&apos;t return the item.</div><div class="line">     3.如果栈顶存在另外一个FULFILLING的节点，则匹配节点，并出栈。这段的代码</div><div class="line">     与fulfilling相同，除非没有元素返回</div><div class="line">            */</div><div class="line"></div><div class="line">           SNode s = null; // constructed/reused as needed</div><div class="line">    //根据元素判断节点模式，元素不为null，则为DATA，否则为REQUEST</div><div class="line">           int mode = (e == null) ? REQUEST : DATA;</div><div class="line"></div><div class="line">           for (;;) &#123;</div><div class="line">               SNode h = head;</div><div class="line">               if (h == null || h.mode == mode) &#123;  // empty or same-mode</div><div class="line">        //如果是空队列，或栈头节点的模式与要放入的节点模式相同</div><div class="line">                   if (timed &amp;&amp; nanos &lt;= 0) &#123;  // can&apos;t wait</div><div class="line">            //如果超时，则取消等待，出栈，设置栈头为其后继</div><div class="line">                       if (h != null &amp;&amp; h.isCancelled())</div><div class="line">                           casHead(h, h.next);     // pop cancelled node</div><div class="line">                       else</div><div class="line">            //否则返回null</div><div class="line">                           return null;</div><div class="line">                   &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123;</div><div class="line">            //如果非超时，则将创建的新节点入栈成功，即放在栈头，自旋等待匹配节点（timed决定超时，不超时）</div><div class="line">                       SNode m = awaitFulfill(s, timed, nanos);</div><div class="line">                       if (m == s) &#123;               // wait was cancelled</div><div class="line">            //如果返回的是自己，节点取消等待，从栈中移除，并遍历栈移除取消等待的节点</div><div class="line">                           clean(s);</div><div class="line">                           return null;</div><div class="line">                       &#125;</div><div class="line">                       if ((h = head) != null &amp;&amp; h.next == s)</div><div class="line">            //s节点匹配成功，则设置栈头为s的后继</div><div class="line">                           casHead(h, s.next);     // help s&apos;s fulfiller</div><div class="line">        //匹配成功，REQUEST模式返回，匹配到的节点元素（DATA），DATA模式返回当前节点元素</div><div class="line">                       return (mode == REQUEST) ? m.item : s.item;</div><div class="line">                   &#125;</div><div class="line">               &#125; else if (!isFulfilling(h.mode)) &#123; // try to fulfill</div><div class="line">        //如果栈头节点模式不为Fulfilling，判断是否取消等待，是则出栈</div><div class="line">                   if (h.isCancelled())            // already cancelled</div><div class="line">                       casHead(h, h.next);         // pop and retry</div><div class="line">        //非取消等待，则是节点入栈</div><div class="line">                   else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</div><div class="line">                       for (;;) &#123; // loop until matched or waiters disappear</div><div class="line">                           SNode m = s.next;       // m is s&apos;s match</div><div class="line">            //后继节点为null，则出栈</div><div class="line">                           if (m == null) &#123;        // all waiters are gone</div><div class="line">                               casHead(s, null);   // pop fulfill node</div><div class="line">                               s = null;           // use new node next time</div><div class="line">                               break;              // restart main loop</div><div class="line">                           &#125;</div><div class="line">                           SNode mn = m.next;</div><div class="line">            //尝试匹配是s节点</div><div class="line">                           if (m.tryMatch(s)) &#123;</div><div class="line">                //匹配成功两个节点则出栈，</div><div class="line">                               casHead(s, mn);     // pop both s and m</div><div class="line">                               return (mode == REQUEST) ? m.item : s.item;</div><div class="line">                           &#125; else                  // lost match</div><div class="line">                //否则，跳过s的后继节点</div><div class="line">                               s.casNext(m, mn);   // help unlink</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125; else &#123;                            // help a fulfiller</div><div class="line">        //如果栈头节点模式为Fulfilling,找出栈头的匹配节点</div><div class="line">                   SNode m = h.next;               // m is h&apos;s match</div><div class="line">                   if (m == null)                  // waiter is gone</div><div class="line">            //如果无后继等待节点，则栈头出栈</div><div class="line">                       casHead(h, null);           // pop fulfilling node</div><div class="line">                   else &#123;</div><div class="line">           //尝试匹配，如果匹配成功，栈头和匹配节点出栈，否则跳过后继节点</div><div class="line">                       SNode mn = m.next;</div><div class="line">                       if (m.tryMatch(h))          // help match</div><div class="line">                           casHead(h, mn);         // pop both h and m</div><div class="line">                       else                        // lost match</div><div class="line">                           h.casNext(m, mn);       // help unlink</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Spins/blocks until node s is matched by a fulfill operation.</div><div class="line">自旋或阻塞，直到节点被一个fulfill操作匹配</div><div class="line">        *</div><div class="line">        * @param s the waiting node  等待被匹配的节点</div><div class="line">        * @param timed true if timed wait 是否超时等待</div><div class="line">        * @param nanos timeout value 时间值</div><div class="line">        * @return matched node, or s if cancelled 如果匹配返回节点，否则取消等待</div><div class="line">        */</div><div class="line">       SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123;</div><div class="line">           /*</div><div class="line">            * When a node/thread is about to block, it sets its waiter</div><div class="line">            * field and then rechecks state at least one more time</div><div class="line">            * before actually parking, thus covering race vs</div><div class="line">            * fulfiller noticing that waiter is non-null so should be</div><div class="line">            * woken.</div><div class="line">            *</div><div class="line">     当一个节点线程将要阻塞时，在实际park之前，设置等待线程的field，重新至少检查</div><div class="line">     自身状态一次，这样可以避免在fulfiller注意到有等待线程非null，可以操作时，掩盖了竞争。</div><div class="line">            * When invoked by nodes that appear at the point of call</div><div class="line">            * to be at the head of the stack, calls to park are</div><div class="line">            * preceded by spins to avoid blocking when producers and</div><div class="line">            * consumers are arriving very close in time.  This can</div><div class="line">            * happen enough to bother only on multiprocessors.</div><div class="line">            *</div><div class="line">     当awaitFulfill被栈头节点调用时，通过自旋park一段时间，以免在刚要阻塞的时刻，</div><div class="line">     有生产者或消费者到达。这在多处理机上将会发生。</div><div class="line">            * The order of checks for returning out of main loop</div><div class="line">            * reflects fact that interrupts have precedence over</div><div class="line">            * normal returns, which have precedence over</div><div class="line">            * timeouts. (So, on timeout, one last check for match is</div><div class="line">            * done before giving up.) Except that calls from untimed</div><div class="line">            * SynchronousQueue.&#123;poll/offer&#125; don&apos;t check interrupts</div><div class="line">            * and don&apos;t wait at all, so are trapped in transfer</div><div class="line">            * method rather than calling awaitFulfill.</div><div class="line">     主循环检查返回的顺序将会反应，在正常返回时，中断是否处理，还是超时处理。</div><div class="line">     （在放弃匹配之前，及最后一次检查，正好超时），除非调用SynchronousQueue的</div><div class="line">     非超时poll/offer操作，不会检查中断，不等待，那么将调用transfer方法中的其他部分逻辑，</div><div class="line">     而不是调用awaitFulfill。</div><div class="line">            */</div><div class="line">           long lastTime = timed ? System.nanoTime() : 0;</div><div class="line">           Thread w = Thread.currentThread();</div><div class="line">           SNode h = head;</div><div class="line">    //获取自旋的次数</div><div class="line">           int spins = (shouldSpin(s) ?</div><div class="line">                        (timed ? maxTimedSpins : maxUntimedSpins) : 0);</div><div class="line">           for (;;) &#123;</div><div class="line">               if (w.isInterrupted())</div><div class="line">        //如果线程被中断，则取消等待</div><div class="line">                   s.tryCancel();</div><div class="line">               SNode m = s.match;</div><div class="line">               if (m != null)</div><div class="line">        //如果节点的匹配节点不为null，则返回匹配节点</div><div class="line">                   return m;</div><div class="line">               if (timed) &#123;</div><div class="line">                   long now = System.nanoTime();</div><div class="line">                   nanos -= now - lastTime;</div><div class="line">                   lastTime = now;</div><div class="line">                   if (nanos &lt;= 0) &#123;</div><div class="line">            //如果超时，则取消等待</div><div class="line">                       s.tryCancel();</div><div class="line">                       continue;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               if (spins &gt; 0)</div><div class="line">        //如果自旋次数大于零，且可以自旋，则自旋次数减1</div><div class="line">                   spins = shouldSpin(s) ? (spins-1) : 0;</div><div class="line">               else if (s.waiter == null)</div><div class="line">        //如果节点S的等待线程为空，则设置当前节点为S节点的等待线程，以便可以park后继节点。</div><div class="line">                   s.waiter = w; // establish waiter so can park next iter</div><div class="line">               else if (!timed)</div><div class="line">        //非超时等在者，park当前线程</div><div class="line">                   LockSupport.park(this);</div><div class="line">               else if (nanos &gt; spinForTimeoutThreshold)</div><div class="line">        //如果超时时间大于，最大自旋阈值，则超时park当前线程</div><div class="line">                   LockSupport.parkNanos(this, nanos);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Returns true if node s is at head or there is an active</div><div class="line">        * fulfiller.</div><div class="line"> 如果节点在栈头或栈头为FULFILLING的节点，则返回true</div><div class="line">        */</div><div class="line">       boolean shouldSpin(SNode s) &#123;</div><div class="line">           SNode h = head;</div><div class="line">           return (h == s || h == null || isFulfilling(h.mode));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       /**</div><div class="line">        * Unlinks s from the stack.</div><div class="line">        */</div><div class="line">       void clean(SNode s) &#123;</div><div class="line">           s.item = null;   // forget item</div><div class="line">           s.waiter = null; // forget thread</div><div class="line"></div><div class="line"></div><div class="line">     最糟糕的情况是我们需要遍历整个栈，unlink节点s。如果有多个线程同时访问</div><div class="line">     clean方法，由于其他线程可能移除s节点，我们也许看不到s节点。但是我们可以停止</div><div class="line">     操作，当发现一个节点的后继为s。我们可以用s节点的后继，除非s节点取消，否则，</div><div class="line">     我们可越过s节点。我们不会进一步地检查，因为我们不想仅仅为了发现s节点，遍历两次。</div><div class="line">            */</div><div class="line"></div><div class="line">           SNode past = s.next;</div><div class="line">           if (past != null &amp;&amp; past.isCancelled())</div><div class="line">               past = past.next;</div><div class="line"></div><div class="line">           // Absorb cancelled nodes at head</div><div class="line">           SNode p;</div><div class="line">           while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled())</div><div class="line">        //设置栈头节点的后继为第一个非取消等待的节点</div><div class="line">               casHead(p, p.next);</div><div class="line"></div><div class="line">           // Unsplice embedded nodes，遍历栈，移除取消等待的节点</div><div class="line">           while (p != null &amp;&amp; p != past) &#123;</div><div class="line">               SNode n = p.next;</div><div class="line">               if (n != null &amp;&amp; n.isCancelled())</div><div class="line">                   p.casNext(n, n.next);</div><div class="line">               else</div><div class="line">                   p = n;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       // Unsafe mechanics</div><div class="line">       private static final sun.misc.Unsafe UNSAFE;</div><div class="line">       private static final long headOffset;</div><div class="line">       static &#123;</div><div class="line">           try &#123;</div><div class="line">               UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class="line">               Class k = TransferStack.class;</div><div class="line">               headOffset = UNSAFE.objectFieldOffset</div><div class="line">                   (k.getDeclaredField(&quot;head&quot;));</div><div class="line">           &#125; catch (Exception e) &#123;</div><div class="line">               throw new Error(e);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>从TransferStack中Snode节点可以看出：节点关联一个等待线程waiter，后继next，匹配节点match，节点元素item和模式mode；模式由三种，REQUEST节点表示消费者等待消费资源，DATA表示生产者等待生产资源。FULFILLING节点表示生产者正在给等待资源的消费者补给资源，或生产者在等待消费者消费资源。当有线程take/put操作时，查看栈头，如果是空队列，或栈头节点的模式与要放入的节点模式相同；如果是超时等待，判断时间是否小于0，小于0则取消节点等待；如果非超时，则将创建的新节点入栈成功，即放在栈头，自旋等待匹配节点（timed决定超时，不超时）；如果匹配返回的是自己，节点取消等待，从栈中移除，并遍历栈移除取消等待的节点；匹配成功，两个节点同时出栈，REQUEST模式返回，匹配到的节点元素（DATA），DATA模式返回返回当前节点元素）。如果与栈头节点的模式不同且不为FULFILLING，匹配节点，成功者，两个节点同时出栈，REQUEST模式返回，匹配到的节点元素（DATA），DATA（put）模式返回返回当前节点元素。如果栈头为FULFILLING，找出栈头的匹配节点，栈头与匹配到的节点同时出栈。从分析非公平模式下的TransferStack，可以看出一个REQUEST操作必须同时伴随着一个DATA操作，一个DATA操作必须同时伴随着一个REQUEST操作，这也是同步队列的命名中含Synchronous原因。</p><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>由一个链表结构组成的双向阻塞队列。所谓双向队列指的是你可以从队列的两端插入和移出元素，双端队列因多了一个操作入口，在多线程同时入队时减少了一半的竞争。在初始化LinkedBlockingDeque时，可以设置容量，防止其过渡膨胀，相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素；以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素；插入方法add等同于addLast，移除方法remove等同于removeFirst。</p><p>这个数据结构的方法还是比较简单易懂的。</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue实现了TransferQueue接口的方法。实现了这个接口就意味着它的特性就是消费者与生产者的分离，生产者或消费者都不在乎有没有资源，阻塞都由服务员transfer统一调度。</p><p>它的成员变量与之前的SynchronousQueue的结构很相似，并且内部同样使用的是cas算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">final boolean isData;   // false if this is a request node</div><div class="line">volatile Object item;   // initially non-null if isData; CASed to match</div><div class="line">volatile Node next;</div><div class="line">volatile Thread waiter; // null until waiting</div></pre></td></tr></table></figure><p>LinkedTransferQueue添加和删除元素都指向了同一个方法xfer()，这之前要了解xfer方法参数how的几个可选值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private static final int NOW   = 0; // for untimed poll, tryTransfer</div><div class="line">private static final int ASYNC = 1; // for offer, put, add</div><div class="line">private static final int SYNC  = 2; // for transfer, take</div><div class="line">private static final int TIMED = 3; // for timed poll, tryTransfer</div></pre></td></tr></table></figure><p>NOW就是立刻返回不追加元素到末尾，ASYNC就是同步需要添加元素到队列尾，TIMED用于有时间限制的操作，SYNC用于无时间限制无限等待的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">private E xfer(E e, boolean haveData, int how, long nanos) &#123;</div><div class="line">        if (haveData &amp;&amp; (e == null))</div><div class="line">            throw new NullPointerException();</div><div class="line">        Node s = null;                        // the node to append, if needed</div><div class="line"></div><div class="line">        retry:</div><div class="line">        for (;;) &#123;                            // restart on append race</div><div class="line"></div><div class="line">            for (Node h = head, p = h; p != null;) &#123; // find &amp; match first node</div><div class="line">                boolean isData = p.isData;</div><div class="line">                Object item = p.item;</div><div class="line">                if (item != p &amp;&amp; (item != null) == isData) &#123; // unmatched</div><div class="line">                    if (isData == haveData)   // can&apos;t match</div><div class="line">                        break;</div><div class="line">                    if (p.casItem(item, e)) &#123; // match</div><div class="line">                        for (Node q = p; q != h;) &#123;</div><div class="line">                            Node n = q.next;  // update by 2 unless singleton</div><div class="line">                            if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123;</div><div class="line">                                h.forgetNext();</div><div class="line">                                break;</div><div class="line">                            &#125;                 // advance and retry</div><div class="line">                            if ((h = head)   == null ||</div><div class="line">                                (q = h.next) == null || !q.isMatched())</div><div class="line">                                break;        // unless slack &lt; 2</div><div class="line">                        &#125;</div><div class="line">                        LockSupport.unpark(p.waiter);</div><div class="line">                        return LinkedTransferQueue.&lt;E&gt;cast(item);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                Node n = p.next;</div><div class="line">                p = (p != n) ? n : (h = head); // Use head if p offlist</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (how != NOW) &#123;                 // No matches available</div><div class="line">                if (s == null)</div><div class="line">                    s = new Node(e, haveData);</div><div class="line">                Node pred = tryAppend(s, haveData);</div><div class="line">                if (pred == null)</div><div class="line">                    continue retry;           // lost race vs opposite mode</div><div class="line">                if (how != ASYNC)</div><div class="line">                    return awaitMatch(s, pred, e, (how == TIMED), nanos);</div><div class="line">            &#125;</div><div class="line">            return e; // not waiting</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>不允许放入的数据为空，放入操作的模式是ASYNC。从头指针处开始死循环，当前结点p没有被匹配，数据节点不能匹配直接跳出循环，不进行匹配，后面会进入how!=NOW的判断，创建新节点，尝试追加到队列尾。如果可以匹配就替换P节点的值，失败意味着被其它线程抢先了，继续循环，成功了意味着这两个匹配成功，可能需要更新头结点。q=p且p!=h的循环意味着已经跳过了一个元素，n又取了q.next，p又是当前被匹配了的结点，这就意味着前面有2个match的结点：head和p。达到slack为2的条件，更新头结点，并遗弃之前的head。不需要更新头结点的时候直接跳出循环。匹配完成之后就是唤醒p结点的waiter（如果p是请求节点的话）返回item。</p><blockquote><p>参考链接</p><p><a href="http://blog.csdn.net/javazejian/article/details/77410889?locationNum=1&amp;fps=1" target="_blank" rel="external">http://blog.csdn.net/javazejian/article/details/77410889?locationNum=1&amp;fps=1</a></p><p><a href="http://www.importnew.com/17537.html" target="_blank" rel="external">http://www.importnew.com/17537.html</a></p><p><a href="http://donald-draper.iteye.com/blog/2364842" target="_blank" rel="external">http://donald-draper.iteye.com/blog/2364842</a></p><p><a href="https://www.cnblogs.com/lighten/p/7505355.html" target="_blank" rel="external">https://www.cnblogs.com/lighten/p/7505355.html</a></p></blockquote></the>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-Executor框架(10)</title>
      <link href="/2018/02/11/JUC-Executor%E6%A1%86%E6%9E%B6-10/"/>
      <url>/2018/02/11/JUC-Executor%E6%A1%86%E6%9E%B6-10/</url>
      
        <content type="html"><![CDATA[<p>我们日常工作中使用Executor框架最常见的就是创建一个线程池，然后将任务交给线程池去执行，实现提交与执行任务之间解耦</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>这里主要研究一下Executor框架的主干部分，对于ScheduledService工作中应该主要使用的是quartz框架，对于CompletionService，个人觉得java8中的CompletableFuture使用效果更好，所以在这里就不研究了。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1focjozc5g1j30j40ah756.jpg" alt=""></p><p><excerpt in="" index="" |="" 首页摘要=""><br> <a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="从日常使用看起"><a href="#从日常使用看起" class="headerlink" title="从日常使用看起"></a>从日常使用看起</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ExecutorService service = Executors.newFixedThreadPool(3);</div></pre></td></tr></table></figure><p>这个方法应该是使用频率很高的，它创建了一个拥有三个固定线程的线程池。那么点进源码里看看都做了哪些事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  0L, TimeUnit.MILLISECONDS,</div><div class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实是Executor在内部new了一个ThreadPoolExecutor。其实Executors就是一个静态工厂方法，封装了一些常用的线程池类型。</p><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>ThreadPoolExecutor其实是Executor框架的一个核心类，通过设置不同的参数，可以构造出各种效果的线程池。继续深入到ThreadPoolExecutor类中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue) &#123;</div><div class="line">    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">         Executors.defaultThreadFactory(), defaultHandler);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ThreadPoolExecutor(int corePoolSize,</div><div class="line">                          int maximumPoolSize,</div><div class="line">                          long keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    if (corePoolSize &lt; 0 ||</div><div class="line">        maximumPoolSize &lt;= 0 ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; 0)</div><div class="line">        throw new IllegalArgumentException();</div><div class="line">    if (workQueue == null || threadFactory == null || handler == null)</div><div class="line">        throw new NullPointerException();</div><div class="line">    this.acc = System.getSecurityManager() == null ?</div><div class="line">            null :</div><div class="line">            AccessController.getContext();</div><div class="line">    this.corePoolSize = corePoolSize;</div><div class="line">    this.maximumPoolSize = maximumPoolSize;</div><div class="line">    this.workQueue = workQueue;</div><div class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    this.threadFactory = threadFactory;</div><div class="line">    this.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ThreadPoolExecutor的构造函数如图所示，有七个参数:</p><ol><li>corePoolSize表示线程池核心线程数量</li><li>maximumPoolSize表示线程池最大容量</li><li>keepAliveTime表示线程池中大于coresize的空闲线程最大的存活时间。</li><li>timeunit 时间单位</li><li>blockingQueue:暂存任务的工作队列</li><li>ThreadFactory: 用于创建一个新的线程</li><li>handler:用于配置线程池饱和后的拒绝策略</li></ol><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1focm15e2qyj30gw0c8t9h.jpg" alt=""></p><p>当通过主线程提交一个任务后，如果当前任务的数量小于coresize那么直接执行步骤1</p><p>如果任务数量大于coresize并且blockingQueue没满，则加入blockingQueue，如步骤3</p><p>当blockingQueue已满，线程池扩容到maxpoolsize情况下运行</p><p>当线程池处于maxpoolsize数量下满载工作，并且blockingQueue满，则执行步骤4，拒绝任务</p><p>这个处理策略可以再<strong><em><em>execute</em></em></strong>方法中清楚的看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public void execute(Runnable command) &#123;</div><div class="line">        if (command == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        int c = ctl.get();</div><div class="line">        if (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">            if (addWorker(command, true))</div><div class="line">                return;</div><div class="line">            c = ctl.get();</div><div class="line">        &#125;</div><div class="line">        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">            int recheck = ctl.get();</div><div class="line">            if (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">                reject(command);</div><div class="line">            else if (workerCountOf(recheck) == 0)</div><div class="line">                addWorker(null, false);</div><div class="line">        &#125;</div><div class="line">        else if (!addWorker(command, false))</div><div class="line">            reject(command);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>上面再提交任务的时候，会出现开辟新的线程来执行，也就是调用addWorker()方法。</p><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><blockquote><p>addWorker</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</div><div class="line">        retry:</div><div class="line">        for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);</div><div class="line"></div><div class="line">            // Check if queue empty only if necessary.</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">                ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">                   firstTask == null &amp;&amp;</div><div class="line">                   ! workQueue.isEmpty()))</div><div class="line">                return false;</div><div class="line"></div><div class="line">            for (;;) &#123;</div><div class="line">                int wc = workerCountOf(c);</div><div class="line">                if (wc &gt;= CAPACITY ||</div><div class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                    return false;</div><div class="line">                if (compareAndIncrementWorkerCount(c))</div><div class="line">                    break retry;</div><div class="line">                c = ctl.get();  // Re-read ctl</div><div class="line">                if (runStateOf(c) != rs)</div><div class="line">                    continue retry;</div><div class="line">                // else CAS failed due to workerCount change; retry inner loop</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">上面的部分是两层无限循环，尝试增加线程数量到ctl变量。</div><div class="line">如果超过线程池设定的数量或者线程池状态不符，则返回false，增加worker失败。</div><div class="line"></div><div class="line"></div><div class="line">        boolean workerStarted = false;</div><div class="line">        boolean workerAdded = false;</div><div class="line">        Worker w = null;</div><div class="line">        try &#123;</div><div class="line">            w = new Worker(firstTask);</div><div class="line">            final Thread t = w.thread;</div><div class="line">            if (t != null) &#123;</div><div class="line">                final ReentrantLock mainLock = this.mainLock;</div><div class="line">                mainLock.lock();</div><div class="line">                try &#123;</div><div class="line">                    // Recheck while holding lock.</div><div class="line">                    // Back out on ThreadFactory failure or if</div><div class="line">                    // shut down before lock acquired.</div><div class="line">                    int rs = runStateOf(ctl.get());</div><div class="line"></div><div class="line">                    if (rs &lt; SHUTDOWN ||</div><div class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</div><div class="line">                        if (t.isAlive()) // precheck that t is startable</div><div class="line">                            throw new IllegalThreadStateException();</div><div class="line">                        workers.add(w);</div><div class="line">                        int s = workers.size();</div><div class="line">                        if (s &gt; largestPoolSize)</div><div class="line">                            largestPoolSize = s;</div><div class="line">                        workerAdded = true;</div><div class="line">                    &#125;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    mainLock.unlock();</div><div class="line">                &#125;</div><div class="line">                if (workerAdded) &#123;</div><div class="line">                    t.start();</div><div class="line">                    workerStarted = true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (! workerStarted)</div><div class="line">                addWorkerFailed(w);</div><div class="line">        &#125;</div><div class="line">        return workerStarted;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">上面的部分把firstTask这个Runnable对象传递给worker构造方法，给worker的task属性赋值。</div><div class="line">worker将自身封装为一个Thread。</div><div class="line">锁住整个线程池，将worker添加到workers的hashSet中。</div><div class="line">增加线程后调用start()方法，真正开始执行任务。</div><div class="line">实际上是运行的worker的run()方法，worker的run()方法调用了ThreadPoolExecutor的runWorker()方法。</div></pre></td></tr></table></figure><blockquote><p>Worker内部类</p></blockquote><p>Worker是ThreadPoolExecutor的内部类，它继承了AQS,实现了Runnable接口。封装了三个属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/** Thread this worker is running in.  Null if factory fails. */</div><div class="line">final Thread thread;</div><div class="line">/** Initial task to run.  Possibly null. */</div><div class="line">Runnable firstTask;</div><div class="line">/** Per-thread task counter */</div><div class="line">volatile long completedTasks;</div></pre></td></tr></table></figure><p>内部实现了一些资源共享的方法。</p><blockquote><p>runWorker()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">final void runWorker(Worker w) &#123;</div><div class="line">    Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask;</div><div class="line">    w.firstTask = null;</div><div class="line">    w.unlock(); // allow interrupts</div><div class="line">    boolean completedAbruptly = true;</div><div class="line">    try &#123;</div><div class="line">        while (task != null || (task = getTask()) != null) &#123;</div><div class="line">            w.lock();</div><div class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            try &#123;</div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = null;</div><div class="line">                try &#123;</div><div class="line">                    task.run();</div><div class="line">                &#125; catch (RuntimeException x) &#123;</div><div class="line">                    thrown = x; throw x;</div><div class="line">                &#125; catch (Error x) &#123;</div><div class="line">                    thrown = x; throw x;</div><div class="line">                &#125; catch (Throwable x) &#123;</div><div class="line">                    thrown = x; throw new Error(x);</div><div class="line">                &#125; finally &#123;</div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">                task = null;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = false;</div><div class="line">    &#125; finally &#123;</div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先对worker进行加锁，任务开始之前执行beforeExecute，任务执行结束之后执行afterExecute，任务完成后记录当前线程完成的任务数。如果调用了getTask()方法，阻塞方法的退出，继续执行当前方法。</p><blockquote><p>getTask()</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private Runnable getTask() &#123;</div><div class="line">        boolean timedOut = false; // Did the last poll() time out?</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            int c = ctl.get();</div><div class="line">            int rs = runStateOf(c);</div><div class="line"></div><div class="line">            // Check if queue empty only if necessary.</div><div class="line">            if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">                decrementWorkerCount();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            int wc = workerCountOf(c);</div><div class="line"></div><div class="line">            // Are workers subject to culling?</div><div class="line">            boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</div><div class="line">                if (compareAndDecrementWorkerCount(c))</div><div class="line">                    return null;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                Runnable r = timed ?</div><div class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                    workQueue.take();</div><div class="line">                if (r != null)</div><div class="line">                    return r;</div><div class="line">                timedOut = true;</div><div class="line">            &#125; catch (InterruptedException retry) &#123;</div><div class="line">                timedOut = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>该方法从workQueue中取一个任务。该队列是一个blockingQueue，当没有任务的时候会陷入阻塞。如果获取到的任务是有时间限制的则调用poll方法，设置过期时间。否则调用take方法执行任务。当getWorker()方法返回null的时候，addworker()方法执行processWorkerExit，退出线程。</p><blockquote><p>processWorkerExit</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</div><div class="line">        if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</div><div class="line">            decrementWorkerCount();</div><div class="line"></div><div class="line">        final ReentrantLock mainLock = this.mainLock;</div><div class="line">        mainLock.lock();</div><div class="line">        try &#123;</div><div class="line">            completedTaskCount += w.completedTasks;</div><div class="line">            workers.remove(w);</div><div class="line">        &#125; finally &#123;</div><div class="line">            mainLock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        tryTerminate();</div><div class="line"></div><div class="line">        int c = ctl.get();</div><div class="line">        if (runStateLessThan(c, STOP)) &#123;</div><div class="line">            if (!completedAbruptly) &#123;</div><div class="line">                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</div><div class="line">                if (min == 0 &amp;&amp; ! workQueue.isEmpty())</div><div class="line">                    min = 1;</div><div class="line">                if (workerCountOf(c) &gt;= min)</div><div class="line">                    return; // replacement not needed</div><div class="line">            &#125;</div><div class="line">            addWorker(null, false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>主要的逻辑就是从works的HashSet中remove一个线程。如果在方法执行过程中出现了异常completedAbruptly=true，线程直接退出，线程数量减一。正常退出则加锁统计任务总数并remove线程。</p><p>tryTerminate()将线程池尝试设置为终止状态</p><p>最后比较当前线程数是不是低于coreSize，如果是则添加空的worker到线程池待命。</p><blockquote><p>拒绝策略</p></blockquote><p>ThreadPoolExecutor提供了四个拒绝策略</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fodktwvbejj305r02ddfx.jpg" alt=""></p><ol><li>AbortPolicy: 不处理，直接抛出RejectedExecutionException异常。</li><li>CallerRunsPolicy: 任务可以被执行，但是线程池不会开辟新的线程。而是由提交任务的线程来执行。</li><li>DiscardOldestPolicy: 丢弃一个最早进入队列的任务</li><li>DiscardPolicy: 直接丢弃提交的任务。</li></ol><p>到此，一个线程在线程池中的生命周期大概就走完了。</p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>在上面的介绍中，主要是ThreadPoolExecutor类的方法。ThreadPoolExecutor继承自AbstractExecutorService，AbstractExecutorService实现了ExecutorService接口，ExecutorService接口继承Executor接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface Executor &#123;</div><div class="line">    void execute(Runnable command);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Executor接口只有一个execute方法，通过命名可以看出这是一个命令模式的实现。ExecutorService则是提供了线程池生命周期相关的方法与任务提交的方法。</p><h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><h4 id="newFixedThreadPool-固定容量线程池"><a href="#newFixedThreadPool-固定容量线程池" class="headerlink" title="newFixedThreadPool 固定容量线程池"></a>newFixedThreadPool 固定容量线程池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</div><div class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  0L, TimeUnit.MILLISECONDS,</div><div class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过传入一个int值来指定线程池的大小，coreSize=maxSize。也就是说该线程池不具有伸缩性，线程不会有销毁的开销，所以keepAliveTime=0。超过coreSize的数量的任务会直接放入等待队列中。</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>可缓存的线程池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</div><div class="line">                                  60L, TimeUnit.SECONDS,</div><div class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>coreSize=0,maxSize=最大整数。创建任务时有空闲线程则使用，没有则创建新的线程，每60s销毁一次空闲线程。SynchronousQueue 它是一个对于元素来说空了才能存入，存在才能取出的队列，只保留一个元素在queue里。由于cachedPool本身容量足够大，所以阻塞队列无需保存很多的任务，而SynchronousQueue足够轻量，所以在这里使用最合适不过。</p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static ExecutorService newSingleThreadExecutor() &#123;</div><div class="line">    return new FinalizableDelegatedExecutorService</div><div class="line">        (new ThreadPoolExecutor(1, 1,</div><div class="line">                                0L, TimeUnit.MILLISECONDS,</div><div class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>单线程的线程池，coreSize=MaxSize=1，可以保证任务的FIFO执行。</p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</div><div class="line">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</div><div class="line">          new DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>定时线程池，用来执行大量的定时任务。可以指定coreSize，最大为Integer.MAX，空闲线程立即销毁。超过数量的任务加入到DelayedWorkQueue，DelayedWorkQueue可以控制任务的延迟执行。</p></the>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-等等我,一起走(9)</title>
      <link href="/2018/02/02/JUC-%E7%AD%89%E7%AD%89%E6%88%91-%E4%B8%80%E8%B5%B7%E8%B5%B0-9/"/>
      <url>/2018/02/02/JUC-%E7%AD%89%E7%AD%89%E6%88%91-%E4%B8%80%E8%B5%B7%E8%B5%B0-9/</url>
      
        <content type="html"><![CDATA[<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h4 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h4><p>日常使用的最多的一个工具，初始化时需要指定一个int值，可以理解为要执行任务的线程的数量，每次调用countDown()会使int值减一。当int值&lt;=0时，调用await()方法的地方会放行所有线程。一个简单的demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class CountDownLatchTest &#123;</div><div class="line">    public static CountDownLatch countDownLatch = new CountDownLatch(3);</div><div class="line"></div><div class="line">    static class MyRun implements Runnable&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+&quot;working&quot;);</div><div class="line">            try &#123;</div><div class="line">                TimeUnit.SECONDS.sleep(1);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            countDownLatch.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        new Thread(new MyRun()).start();</div><div class="line">        new Thread(new MyRun()).start();</div><div class="line">        new Thread(new MyRun()).start();</div><div class="line"></div><div class="line">        countDownLatch.await();</div><div class="line">        System.out.println(&quot;all finish&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><p>当三个线程都执行过countDown方法之后，计数器减为0。await()方法放行，输出all finish语句。如果有线程出现错误造成计数器无法减到0就会一直阻塞，解决方法有两种。第一种就是给await方法设定等待时间，超过等待时间就放行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">countDownLatch.await(2,TimeUnit.SECONDS);</div></pre></td></tr></table></figure><p>第二种就是使用try/finally代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    try &#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+&quot;working&quot;);</div><div class="line">        TimeUnit.SECONDS.sleep(1);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;finally &#123;</div><div class="line">        countDownLatch.countDown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可能平时不注意就会忘了考虑线程出异常而造成的阻塞这种情况，所以还是建议使用try/finally这种处理，因为可以再finally代码块中记录日志，做一些结束操作。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>可以看出CountDownLatch算是JUC里比较简单的了，可供调用的方法非常简单，从字面意思就可以看懂怎么用。内部的实现是AQS，那么核心就是看一下它是怎样使用AQS了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fo0x4b9jn5j308l084js1.jpg" alt=""></p><p>初始化时调用了内部AQS的初始化，将计数器赋值给state(同步器状态)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public CountDownLatch(int count) &#123;</div><div class="line">    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);</div><div class="line">    this.sync = new Sync(count);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>countDown和await方法的内部实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//await时候执行，只查看当前需要countDown数量减为0了，如果为0，说明可以继续执行，否则需要park住，等待countDown次数足够，并且unpark所有等待线程</div><div class="line">public int tryAcquireShared(int acquires) &#123;</div><div class="line">     return getState() == 0? 1 : -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//countDown 时候执行，如果当前countDown数量为0，说明没有线程await，直接返回false而不需要唤醒park住线程，如果不为0，得到剩下需要 countDown的数量并且compareAndSet,最终返回剩下的countDown数量是否为0,供AQS判定是否释放所有await线程。</div><div class="line">public boolean tryReleaseShared(int releases) &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">         int c = getState();</div><div class="line">         if (c == 0)</div><div class="line">             return false;</div><div class="line">         int nextc = c-1;</div><div class="line">         if (compareAndSetState(c, nextc))</div><div class="line">             return nextc == 0;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="CylicBarriar"><a href="#CylicBarriar" class="headerlink" title="CylicBarriar"></a>CylicBarriar</h3><h4 id="coding-1"><a href="#coding-1" class="headerlink" title="coding"></a>coding</h4><p>CyclicBarrier与CountDownLatch的使用有些相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class CyclicBarrierTest &#123;</div><div class="line">    public static CyclicBarrier cyclicBarrier = new CyclicBarrier(4);</div><div class="line">    public static Random random = new Random();</div><div class="line">    static class MyRun implements Runnable&#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()+&quot;is working&quot;);</div><div class="line">                TimeUnit.SECONDS.sleep(random.nextInt(5));</div><div class="line">                cyclicBarrier.await();</div><div class="line">                System.out.println(Thread.currentThread().getName()+&quot;after wait&quot;);</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;</div><div class="line">        new Thread(new MyRun()).start();</div><div class="line">        new Thread(new MyRun()).start();</div><div class="line">        new Thread(new MyRun()).start();</div><div class="line">        cyclicBarrier.await();</div><div class="line">        TimeUnit.SECONDS.sleep(1);</div><div class="line">        System.out.println(&quot;all finished&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先对于同样启动3个线程，CountDownLath初始化个数为3，而CyclicBarrier则是4。所以CountDownLath初始化值的意思是要执行任务的线程的个数，而CyclicBarrier初始化值的意思是要等待的线程的个数。因为总要多出一个主线程进入阻塞等待，否则可能导致程序提前退出。</p><p>从上面的demo可以看出，只要有线程还没有到达await方法，其他线程都阻塞在cyclicBarrier.await()这个方法之前，当所有的方法执行到这个屏障的时候，屏障才会打开，所有线程继续抢占cpu执行。</p><p>对于这个工具，我们只使用了一个方法就完成了目标，看一下它的实现代码。</p><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fo0y3rqjphj309q0b2q3t.jpg" alt=""></p><p>虽然没有使用AQS，但是代码好像复杂很多，多出了一个Generation(分代)的概念，还使用了自旋锁。</p><p>首先CyclicBarrier提供了两个构造函数,第一个构造函数就是传入等待线程的数量，另一个还需要传入一个Runnable。作用就是当所有线程到达同步点时,先执行构造函数中的Runnable,这个Runnable拥有最高的优先级。如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static CyclicBarrier cyclicBarrier = new CyclicBarrier(4, new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;所有线程都到达同步点啦，准备冲啊&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Thread-1is working</div><div class="line">Thread-2is working</div><div class="line">Thread-0is working</div><div class="line">所有线程都到达同步点啦，准备冲啊</div><div class="line">Thread-1after wait</div><div class="line">Thread-2after wait</div><div class="line">Thread-0after wait</div><div class="line">all finished</div></pre></td></tr></table></figure><p>对于await方法，同样提供了带超时和不带超时的功能,核心方法是doawait:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public int await() throws InterruptedException, BrokenBarrierException &#123;</div><div class="line">        try &#123;</div><div class="line">            return dowait(false, 0L);</div><div class="line">        &#125; catch (TimeoutException toe) &#123;</div><div class="line">            throw new Error(toe); // cannot happen</div><div class="line">        &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">public int await(long timeout, TimeUnit unit)</div><div class="line">        throws InterruptedException,</div><div class="line">               BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        return dowait(true, unit.toNanos(timeout));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>doWait方法：</p><ol><li>首先每个线程进入方法之后会加一个自旋锁，初始化一个Generation，这个内部类只有一个默认为false的broken属性，然后进行一些异常检测。</li><li>index=–count,将等待线程的数量减一，表示已经到了等待处。</li><li>如果index!=0,循环等待，并进行超时判断。</li><li>如果index==0,判断构造函数有没有传入Runnable，如果有就优先执行。否则执行nextGeneration()，并在最后检查一些异常，解锁退出。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">private int dowait(boolean timed, long nanos)</div><div class="line">        throws InterruptedException, BrokenBarrierException,</div><div class="line">               TimeoutException &#123;</div><div class="line">        final ReentrantLock lock = this.lock;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            final Generation g = generation;</div><div class="line"></div><div class="line">            if (g.broken)</div><div class="line">                throw new BrokenBarrierException();</div><div class="line"></div><div class="line">            if (Thread.interrupted()) &#123;</div><div class="line">                breakBarrier();</div><div class="line">                throw new InterruptedException();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            int index = --count;</div><div class="line">            if (index == 0) &#123;  // tripped</div><div class="line">                boolean ranAction = false;</div><div class="line">                try &#123;</div><div class="line">                    final Runnable command = barrierCommand;</div><div class="line">                    if (command != null)</div><div class="line">                        command.run();</div><div class="line">                    ranAction = true;</div><div class="line">                    nextGeneration();</div><div class="line">                    return 0;</div><div class="line">                &#125; finally &#123;</div><div class="line">                    if (!ranAction)</div><div class="line">                        breakBarrier();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // loop until tripped, broken, interrupted, or timed out</div><div class="line">            for (;;) &#123;</div><div class="line">                try &#123;</div><div class="line">                    if (!timed)</div><div class="line">                        trip.await();</div><div class="line">                    else if (nanos &gt; 0L)</div><div class="line">                        nanos = trip.awaitNanos(nanos);</div><div class="line">                &#125; catch (InterruptedException ie) &#123;</div><div class="line">                    if (g == generation &amp;&amp; ! g.broken) &#123;</div><div class="line">                        breakBarrier();</div><div class="line">                        throw ie;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // We&apos;re about to finish waiting even if we had not</div><div class="line">                        // been interrupted, so this interrupt is deemed to</div><div class="line">                        // &quot;belong&quot; to subsequent execution.</div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (g.broken)</div><div class="line">                    throw new BrokenBarrierException();</div><div class="line"></div><div class="line">                if (g != generation)</div><div class="line">                    return index;</div><div class="line"></div><div class="line">                if (timed &amp;&amp; nanos &lt;= 0L) &#123;</div><div class="line">                    breakBarrier();</div><div class="line">                    throw new TimeoutException();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>那么我们继续来看看nextGeneration这个方法做了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void nextGeneration() &#123;</div><div class="line">    // signal completion of last generation</div><div class="line">    trip.signalAll();</div><div class="line">    // set up next generation</div><div class="line">    count = parties;</div><div class="line">    generation = new Generation();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先将broken设置为了true。我们可以把刚刚执行过的线程想象成第一代线程，当第一代线程没有全部执行完时，broken=false。执行完之后broken为true，根据上面的doawait源码，我们就可以理解为对当前cyclicBarrier进行一次flush操作，踢出所有线程将CyclicBarrier恢复原样，等待下一批线程的使用。同时我们可以发现，如果出现异常，调用的breakBarrier方法也是同样的逻辑，将所有等待线程都踢出去，刷新CyclicBarrier，所以本质上它是可以复用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private void breakBarrier() &#123;</div><div class="line">    generation.broken = true;</div><div class="line">    count = parties;</div><div class="line">    trip.signalAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以在执行完之后可以在主函数中打印一下CyclicBarrier的count值,可以发现并没有减为0，而是初始值4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(cyclicBarrier.getParties());</div></pre></td></tr></table></figure><h4 id="CountDownLatch-vs-CyclicBarrier"><a href="#CountDownLatch-vs-CyclicBarrier" class="headerlink" title="CountDownLatch vs CyclicBarrier"></a>CountDownLatch vs CyclicBarrier</h4><ol><li>构造函数赋值的意义不同，一个是执行任务的线程数量，一个是等待线程的数量</li><li>CyclicBarrier可以重复使用，CountDownLatch使用后会变为0</li></ol><h3 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h3><p>与CountDownLatch和CyclicBarrier功能类似，都可以对任务进行不同粒度的划分，但是Phaser支持动态的增加和减少初始化构造器parties的个数,在功能上完全可以替代前面两个。</p><h4 id="coding-2"><a href="#coding-2" class="headerlink" title="coding"></a>coding</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class PhaserTest &#123;</div><div class="line">    public static Random random = new Random(System.currentTimeMillis());</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Phaser phaser = new Phaser(5);</div><div class="line">        for (int i = 1; i &lt; 6; i++) &#123;</div><div class="line">            new Athletes(i,phaser).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Athletes extends Thread&#123;</div><div class="line">        private final int no;</div><div class="line">        private final Phaser phaser;</div><div class="line"></div><div class="line">        public Athletes(int no, Phaser phaser) &#123;</div><div class="line">            this.no = no;</div><div class="line">            this.phaser = phaser;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                System.out.println(&quot;运动员&quot;+no+&quot;开始跑步了&quot;);</div><div class="line">                TimeUnit.SECONDS.sleep(random.nextInt(5));</div><div class="line">                System.out.println(&quot;运动员&quot;+no+&quot;跑完了&quot;);</div><div class="line">                phaser.arriveAndAwaitAdvance();</div><div class="line">                System.out.println(phaser.getPhase());</div><div class="line">                System.out.println(&quot;运动员&quot;+no+&quot;开始骑车了&quot;);</div><div class="line">                TimeUnit.SECONDS.sleep(random.nextInt(5));</div><div class="line">                System.out.println(&quot;运动员&quot;+no+&quot;骑完了&quot;);</div><div class="line">                phaser.arriveAndAwaitAdvance();</div><div class="line">                System.out.println(phaser.getPhase());</div><div class="line">                System.out.println(&quot;运动员&quot;+no+&quot;开始跳远了&quot;);</div><div class="line">                TimeUnit.SECONDS.sleep(random.nextInt(5));</div><div class="line">                System.out.println(&quot;运动员&quot;+no+&quot;完成跳远了&quot;);</div><div class="line">                phaser.arriveAndAwaitAdvance();</div><div class="line">                System.out.println(phaser.getPhase());</div><div class="line"></div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">运动员1开始跑步了</div><div class="line">运动员3开始跑步了</div><div class="line">运动员2开始跑步了</div><div class="line">运动员5开始跑步了</div><div class="line">运动员4开始跑步了</div><div class="line">运动员5跑完了</div><div class="line">运动员3跑完了</div><div class="line">运动员1跑完了</div><div class="line">运动员2跑完了</div><div class="line">运动员4跑完了</div><div class="line">运动员4开始骑车了</div><div class="line">运动员5开始骑车了</div><div class="line">运动员1开始骑车了</div><div class="line">运动3开始骑车了</div><div class="line">运动员2开始骑车了</div><div class="line">运动员2骑完了</div><div class="line">运动员5骑完了</div><div class="line">运动员4骑完了</div><div class="line">运动员1骑完了</div><div class="line">运动员3骑完了</div><div class="line">运动员2开始跳远了</div><div class="line">运动员4开始跳远了</div><div class="line">运动员5开始跳远了</div><div class="line">运动员3开始跳远了</div><div class="line">运动员1开始跳远了</div><div class="line">运动员5完成跳远了</div><div class="line">运动员4完成跳远了</div><div class="line">运动员2完成跳远了</div><div class="line">运动员3完成跳远了</div><div class="line">运动员1完成跳远了</div></pre></td></tr></table></figure><p>可以看到Phaser可以做到CyclicBarrier和CountDownLatch相同的功能，但是考虑这样的场景，加入有一个运动员骑车之后受伤了，不能参加第三阶段的比赛那该怎么办呢,模拟一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public class PhaserTest &#123;</div><div class="line">    public static Random random = new Random(System.currentTimeMillis());</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Phaser phaser = new Phaser(5);</div><div class="line">        for (int i = 1; i &lt; 5; i++) &#123;</div><div class="line">            new Athletes(i,phaser).start();</div><div class="line">        &#125;</div><div class="line">        new Injured(6,phaser).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Athletes extends Thread&#123;</div><div class="line">        private final int no;</div><div class="line">        private final Phaser phaser;</div><div class="line"></div><div class="line">        public Athletes(int no, Phaser phaser) &#123;</div><div class="line">            this.no = no;</div><div class="line">            this.phaser = phaser;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                sport(phaser,&quot;运动员&quot;+no+&quot;开始跑步了&quot;,&quot;运动员&quot;+no+&quot;跑完了&quot;);</div><div class="line">                sport(phaser,&quot;运动员&quot;+no+&quot;开始骑车了&quot;,&quot;运动员&quot;+no+&quot;骑完了&quot;);</div><div class="line">                sport(phaser,&quot;运动员&quot;+no+&quot;开始跳远了&quot;,&quot;运动员&quot;+no+&quot;完成跳远了&quot;);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    static class Injured extends Thread&#123;</div><div class="line">        private final int no;</div><div class="line">        private final Phaser phaser;</div><div class="line"></div><div class="line">        public Injured(int no, Phaser phaser) &#123;</div><div class="line">            this.no = no;</div><div class="line">            this.phaser = phaser;</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            try &#123;</div><div class="line">                sport(phaser,&quot;运动员&quot;+no+&quot;开始跑步了&quot;,&quot;运动员&quot;+no+&quot;跑完了&quot;);</div><div class="line">                sport(phaser,&quot;运动员&quot;+no+&quot;开始骑车了&quot;,&quot;运动员&quot;+no+&quot;骑完了&quot;);</div><div class="line">                System.out.println(&quot;我受伤了&quot;);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void sport(Phaser phaser,String s1,String s2) throws InterruptedException &#123;</div><div class="line">        System.out.println(s1);</div><div class="line">        TimeUnit.SECONDS.sleep(random.nextInt(5));</div><div class="line">        System.out.println(s2);</div><div class="line">        phaser.arriveAndAwaitAdvance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">....</div><div class="line">运动员4开始跳远了</div><div class="line">运动员2开始跳远了</div><div class="line">运动员1开始跳远了</div><div class="line">运动员3开始跳远了</div><div class="line">我受伤了</div><div class="line">运动员3完成跳远了</div><div class="line">运动员2完成跳远了</div><div class="line">运动员4完成跳远了</div><div class="line">运动员1完成跳远了</div></pre></td></tr></table></figure><p>可以看到结果可以输出，但是程序并不会停止，因为第三阶段的线程没有达到预定的数目，全部都进入无限等待中。<br>那么按照正常的逻辑，一个运动员受伤后应该离开赛场，不应该影响其他运动员的比赛。而我们写的程序确是将运动员留在赛场上，所以为了程序正常退出，应该这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sport(phaser,&quot;运动员&quot;+no+&quot;开始跑步了&quot;,&quot;运动员&quot;+no+&quot;跑完了&quot;);</div><div class="line">sport(phaser,&quot;运动员&quot;+no+&quot;开始骑车了&quot;,&quot;运动员&quot;+no+&quot;骑完了&quot;);</div><div class="line">System.out.println(&quot;我受伤了&quot;);</div><div class="line">phaser.arriveAndDeregister();</div></pre></td></tr></table></figure><p>通过这个方法，线程与phaser动态解绑，程序正常退出。</p><p>考虑4x100接力赛的场景，从相同的起点出发，每个赛道的选手只需要和下一位队友接棒就可以，并不需要等待其他对手到达再跑。那么我们可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">phaser.arrive();</div></pre></td></tr></table></figure><p>它的作用就是在每个阶段的终点大喊一声”我到啦”,然后继续执行，并不会等待其他线程到齐。</p><p>另一个phaser常用的方法就是awaitAdvace()，这个方法接受一个int值，当且劲当int值==phaser.getPhase()时，程序阻塞，填入其他任意值将不会阻塞。</p><p>还有很多方法就不作介绍了，主要是一些中断方法以及观察phaser状态的方法。日常的使用都是灵活组合arriveXXX()方法和awaitXXX()方法。</p><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><blockquote><p><a href="https://www.cnblogs.com/lytwajue/p/7258278.html" target="_blank" rel="external">https://www.cnblogs.com/lytwajue/p/7258278.html</a></p></blockquote><p>源码自己看了很久都没看懂，尤其是phaser的堆叠部分。看了这篇文章才有点理解，能力有限，这里就不解释了。</p></the>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMq入门-MessageConverter(6)</title>
      <link href="/2018/02/01/RabbitMq%E5%85%A5%E9%97%A8-MessageConverter-6/"/>
      <url>/2018/02/01/RabbitMq%E5%85%A5%E9%97%A8-MessageConverter-6/</url>
      
        <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>AmqpTemplate还定义了几种发送和接收消息的方法，这些方法将委托给一个MessageConverter。 MessageConverter本身非常简单。它为每个方向提供一个方法：一个用于将消息转换为Message实体，另一个用于将Message转换为Object。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface MessageConverter &#123;</div><div class="line"></div><div class="line">    Message toMessage(Object object, MessageProperties messageProperties)</div><div class="line">            throws MessageConversionException;</div><div class="line"></div><div class="line">    Object fromMessage(Message message) throws MessageConversionException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>下面列出了AmqpTemplate上的相关消息发送方法。它们比我们先前讨论的方法简单，因为它们不需要Message实例。相反，MessageConverter可以将要发送的消息转换为字节数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void convertAndSend(Object message) throws AmqpException;</div><div class="line"></div><div class="line">void convertAndSend(String routingKey, Object message) throws AmqpException;</div><div class="line"></div><div class="line">void convertAndSend(String exchange, String routingKey, Object message)</div><div class="line">    throws AmqpException;</div><div class="line"></div><div class="line">void convertAndSend(Object message, MessagePostProcessor messagePostProcessor)</div><div class="line">    throws AmqpException;</div><div class="line"></div><div class="line">void convertAndSend(String routingKey, Object message,</div><div class="line">    MessagePostProcessor messagePostProcessor) throws AmqpException;</div><div class="line"></div><div class="line">void convertAndSend(String exchange, String routingKey, Object message,</div><div class="line">    MessagePostProcessor messagePostProcessor) throws AmqpException;</div></pre></td></tr></table></figure><p>在接收端只有两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object receiveAndConvert() throws AmqpException;</div><div class="line"></div><div class="line">Object receiveAndConvert(String queueName) throws AmqpException;</div></pre></td></tr></table></figure><h4 id="SimpleMessageConverter"><a href="#SimpleMessageConverter" class="headerlink" title="SimpleMessageConverter"></a>SimpleMessageConverter</h4><p>MessageConverter的默认实现为SimpleMessageConverter。如果你没有明确地配置MessageConverter，这个转换器将被RabbitTemplate的使用。它处理基于文本的内容，序列化的Java对象和简单的字节数组。</p><h5 id="Message转换为对象"><a href="#Message转换为对象" class="headerlink" title="Message转换为对象"></a>Message转换为对象</h5><p>如果输入消息的内容类型以“text”开始(例如“text/plain”),MessageConverter还会检查content-encoding属性，用来确定将Message的body转换为java的String类型所需要的字符集。如果没有设置这个属性，默认是UTF-8.如果需要设置，可以配置SimpleMessageConverter，设置defaultCharset属性，然后注入到RabbitTemplate中。</p><p>如果content-type设置为application/x-java-serialized-object，SimpleMessageConverter将尝试将字节数组反序列化为java对象。但是并不建议这么做，因为这样做会导致消费者和生产者产生紧耦合。</p><p>对于所有其他内容类型，SimpleMessageConverter将直接以字节数组形式返回消息正文内容。</p><h5 id="转换为Message"><a href="#转换为Message" class="headerlink" title="转换为Message"></a>转换为Message</h5><p>当任意的java对象转换为Message时，SimpleMessageConverter会将对象转换为字节数组，并且设置相应的content-type属性。</p><h4 id="Jackson2JsonMessageConverter"><a href="#Jackson2JsonMessageConverter" class="headerlink" title="Jackson2JsonMessageConverter"></a>Jackson2JsonMessageConverter</h4><p>#####转换为Message</p><p>通常我们不提倡直接使用序列化或反序列化的消息转换器，所以Json就是一个比较好的替代方案，它在不同平台上更加灵活也有更好的可移植性。Jackson2JsonMessageConverter可以在任何RabbitTemplate实例上配置，以覆盖其对SimpleMessageConverter默认值的使用。 Jackson2JsonMessageConverter使用com.fasterxml.jackson 2.x库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.amqp.rabbit.core.RabbitTemplate&quot;&gt;</div><div class="line">    &lt;property name=&quot;connectionFactory&quot; ref=&quot;rabbitConnectionFactory&quot;/&gt;</div><div class="line">    &lt;property name=&quot;messageConverter&quot;&gt;</div><div class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;&gt;</div><div class="line">            &lt;!-- if necessary, override the DefaultClassMapper --&gt;</div><div class="line">            &lt;property name=&quot;classMapper&quot; ref=&quot;customClassMapper&quot;/&gt;</div><div class="line">        &lt;/bean&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>可以根据自己的需要，添加MessageConverter的映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;jsonConverterWithDefaultType&quot;</div><div class="line">      class=&quot;o.s.amqp.support.converter.Jackson2JsonMessageConverter&quot;&gt;</div><div class="line">    &lt;property name=&quot;classMapper&quot;&gt;</div><div class="line">        &lt;bean class=&quot;org.springframework.amqp.support.converter.DefaultClassMapper&quot;&gt;</div><div class="line">            &lt;property name=&quot;defaultType&quot; value=&quot;foo.PurchaseOrder&quot;/&gt;</div><div class="line">        &lt;/bean&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>对于springboot可以这样配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Jackson2JsonMessageConverter jsonMessageConverter() &#123;</div><div class="line">    Jackson2JsonMessageConverter jsonConverter = new Jackson2JsonMessageConverter();</div><div class="line">    jsonConverter.setClassMapper(classMapper());</div><div class="line">    return jsonConverter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public DefaultClassMapper classMapper() &#123;</div><div class="line">    DefaultClassMapper classMapper = new DefaultClassMapper();</div><div class="line">    Map&lt;String, Class&lt;?&gt;&gt; idClassMapping = new HashMap&lt;&gt;();</div><div class="line">    idClassMapping.put(&quot;foo&quot;, Foo.class);</div><div class="line">    idClassMapping.put(&quot;bar&quot;, Bar.class);</div><div class="line">    classMapper.setIdClassMapping(idClassMapping);</div><div class="line">    return classMapper;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="Message转换为对象-1"><a href="#Message转换为对象-1" class="headerlink" title="Message转换为对象"></a>Message转换为对象</h5><p>根据发送方加在消息头中的类型信息，可以将message转换为对象。在1.6之前的版本中，如果类型信息不存在，转换将失败。从版本1.6开始，如果缺少类型信息，转换器将使用Jackson默认值（通常是map）转换JSON。在1.6之后的版本，如果使用@Rabbitlistener注解，可以配置MessageProperties加入类型信息。</p><p>在默认情况下，推断的类型信息会覆盖发送方发送消息的<strong>TypeId</strong>和头信息。消息的接收方可以自动将其转换为不同的域对象。但这种配置只适用于参数类型是实体类或者来自java.util包下的情况。抽象类和接口则不适用。假设有一个<br>RabbitListener，它接受一个Foo参数，但是这个消息包含一个Bar，它是Foo的子类。这时类型推断将产生错误，无法解析。要处理这种情况，请将Jackson2JsonMessageConverter上的TypePrecedence属性设置为TYPE_ID而不是默认的INFERRED。该属性实际上是在转换器的DefaultJackson2JavaTypeMapper中，但是为了方便，在转换器上提供了一个setter。如果注入自定义类型映射器，则应该在映射器上设置该属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@RabbitListener</div><div class="line">public void foo(Foo foo) &#123;...&#125;</div><div class="line"></div><div class="line">@RabbitListener</div><div class="line">public void foo(@Payload Foo foo, @Header(&quot;amqp_consumerQueue&quot;) String queue) &#123;...&#125;</div><div class="line"></div><div class="line">@RabbitListener</div><div class="line">public void foo(Foo foo, o.s.amqp.core.Message message) &#123;...&#125;</div><div class="line"></div><div class="line">@RabbitListener</div><div class="line">public void foo(Foo foo, o.s.messaging.Message&lt;Foo&gt; message) &#123;...&#125;</div><div class="line"></div><div class="line">@RabbitListener</div><div class="line">public void foo(Foo foo, String bar) &#123;...&#125;</div><div class="line"></div><div class="line">@RabbitListener</div><div class="line">public void foo(Foo foo, o.s.messaging.Message&lt;?&gt; message) &#123;...&#125;</div></pre></td></tr></table></figure><p>在上面的四个例子中，转换器将尝试转换为Foo类型。第五个例子是无效的，因为我们不能确定哪个参数应该接收消息payload。在第六个示例中，由于泛型类型，所以Jackson会使用默认配置。</p><p>然而，可以创建自定义转换器并使用targetMethod消息属性来决定将JSON转换为哪种类型。</p><p>只有在方法级别声明<br>RabbitListener注释时才能实现此类型推断。使用类级别<br>RabbitListener时，转换后的类型用于选择要调用哪个<br>RabbitHandler方法。为此，基础结构提供了targetObject消息属性，可以由自定义转换器使用它来确定类型。</p><h4 id="RabbitTemplate消息转换"><a href="#RabbitTemplate消息转换" class="headerlink" title="RabbitTemplate消息转换"></a>RabbitTemplate消息转换</h4><p>正如上面提到的，类型信息在消息头中传送，帮助转换器转换消息。这在大多数条件下有用，但是当使用泛型时，它只能转换简单的对象和部分容器对象(list,array,map)。从2.0版本开始，Jackson2JsonMessageConverter实现了SmartMessageConverter接口，允许rabbitTemplate使用ParameterizedTypeReference，这个对象可以用来包装复杂的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Foo&lt;Bar&lt;Baz, Qux&gt;&gt; foo =</div><div class="line">    rabbitTemplate.receiveAndConvert(new ParameterizedTypeReference&lt;Foo&lt;Bar&lt;Baz, Qux&gt;&gt;&gt;() &#123; &#125;);</div></pre></td></tr></table></figure><h5 id="ContentTypeDelegatingMessageConverter"><a href="#ContentTypeDelegatingMessageConverter" class="headerlink" title="ContentTypeDelegatingMessageConverter"></a>ContentTypeDelegatingMessageConverter</h5><p>该类在1.4.2版本中引入，并允许根据MessageProperties中的内容类型属性委派特定的MessageConverter。默认情况下，如果没有contentType属性或者不匹配配置转换器的值，它将委托给SimpleMessageConverter。看起来这个MessageConverter是比较好用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;contentTypeConverter&quot; class=&quot;ContentTypeDelegatingMessageConverter&quot;&gt;</div><div class="line">    &lt;property name=&quot;delegates&quot;&gt;</div><div class="line">        &lt;map&gt;</div><div class="line">            &lt;entry key=&quot;application/json&quot; value-ref=&quot;jsonMessageConverter&quot; /&gt;</div><div class="line">            &lt;entry key=&quot;application/xml&quot; value-ref=&quot;xmlMessageConverter&quot; /&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMq入门-消息发送与接收(5)</title>
      <link href="/2018/01/31/RabbitMq%E5%85%A5%E9%97%A8-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6-5/"/>
      <url>/2018/01/31/RabbitMq%E5%85%A5%E9%97%A8-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SpringBoot1.5.9   <a href="https://projects.spring.io/spring-amqp/" target="_blank" rel="external">https://projects.spring.io/spring-amqp/</a></p><pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;     &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;     &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;</code></pre></blockquote><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>如果你使用AmqpTemplate，发送消息时，可以使用以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void send(Message message) throws AmqpException;</div><div class="line"></div><div class="line">void send(String routingKey, Message message) throws AmqpException;</div><div class="line"></div><div class="line">void send(String exchange, String routingKey, Message message) throws AmqpException;</div></pre></td></tr></table></figure><p>如果没有设置exchange的属性，那么它默认会是空。也就会发送到rabbitmq默认的exchange中。因为AMQP规范将“默认Exchange”定义为没有名称。</p><p>如果你使用AmqpTemplate的一个实现RabbitTemplate，那么会多一个方法的重载，接受一个额外的correlationData对象，当publisher启用了ack机制，这个对象会在回调中返回。这将允许发送者将ack与发送的消息相关联。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">send(final String exchange, final String routingKey, final Message message, final CorrelationData correlationData) throws AmqpException</div></pre></td></tr></table></figure><h4 id="MessageBuilder-API"><a href="#MessageBuilder-API" class="headerlink" title="MessageBuilder API"></a>MessageBuilder API</h4><p>可以通过MessageBuilder构造Message对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</div><div class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</div><div class="line">    .setMessageId(&quot;123&quot;)</div><div class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</div><div class="line">    .build();</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</div><div class="line">    .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</div><div class="line">    .setMessageId(&quot;123&quot;)</div><div class="line">    .setHeader(&quot;bar&quot;, &quot;baz&quot;)</div><div class="line">    .build();</div><div class="line">Message message = MessageBuilder.withBody(&quot;foo&quot;.getBytes())</div><div class="line">    .andProperties(props)</div><div class="line">    .build();</div></pre></td></tr></table></figure><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p>从版本1.4.2开始，引入了BatchingRabbitTemplate。这是RabbitTemplate的一个子类，它有一个重写的发送方法，它根据BatchingStrategy对消息进行批处理;只有当批处理完成时才会发送消息给RabbitMQ。BatchingStrategy是一个接口，有一个实现类SimpleBatchingStrategy，它支持将消息发送到单个的交换器或者routingKey。需要注意的是，这个方法需要将correlationData设置为null并且拒绝来自批次的任何消息将导致整个批次被拒绝。</p><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>信息的接收要比发送复杂。有两种方式可以接受信息，一种是轮询单个消息，更复杂更常见的是注册一个异步事件监听器，看一下两种方式的demo</p><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>AmqpTemplate本身可用于轮询消息接收。默认情况下，如果没有消息可用，则立即返回null,没有阻塞。从1.5版本开始，你可以设置receiveTimeout，它将阻塞式的等待一个消息直至时间结束，如果设置为负数，则表示永远等待。template提供了大量receive方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Message receive() throws AmqpException;</div><div class="line"></div><div class="line">Message receive(String queueName) throws AmqpException;</div><div class="line"></div><div class="line">Message receive(long timeoutMillis) throws AmqpException;</div><div class="line"></div><div class="line">Message receive(String queueName, long timeoutMillis) throws AmqpException;</div></pre></td></tr></table></figure><p>带convert关键字的表示会经过默认的utf-8转码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object receiveAndConvert() throws AmqpException;</div><div class="line"></div><div class="line">Object receiveAndConvert(String queueName) throws AmqpException;</div><div class="line"></div><div class="line">Message receiveAndConvert(long timeoutMillis) throws AmqpException;</div><div class="line"></div><div class="line">Message receiveAndConvert(String queueName, long timeoutMillis) throws AmqpException;</div></pre></td></tr></table></figure><p>####异步方式</p><p>spring AMQP提供了一种通过注解注册listener的方式，即:@RabbitListener。需要注意，开启这种注解需要在一个@Configuration类上加入@EnableRabbit注解</p><p>在方法上添加一个@RabbitHandler注解表示对接收到消息的处理，传入的参数即接收到的消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(queues = &#123;&quot;Queue1&quot;,&quot;Queue2&quot;&#125;)</div><div class="line">@Component</div><div class="line">public class RabbitTest &#123;</div><div class="line"></div><div class="line">    @RabbitHandler</div><div class="line">    public void handle(String msg)&#123;</div><div class="line">        System.out.println(&quot;接收到消息&quot;+msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另一种方法是在方法上添加@RabbitListener注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">  @RabbitListener(bindings = @QueueBinding(</div><div class="line">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</div><div class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;, ignoreDeclarationExceptions = &quot;true&quot;),</div><div class="line">        key = &quot;orderRoutingKey&quot;)</div><div class="line">  )</div><div class="line">  public void processOrder(Order order) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @RabbitListener(bindings = @QueueBinding(</div><div class="line">        value = @Queue,</div><div class="line">        exchange = @Exchange(value = &quot;auto.exch&quot;),</div><div class="line">        key = &quot;invoiceRoutingKey&quot;)</div><div class="line">  )</div><div class="line">  public void processInvoice(Invoice invoice) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @RabbitListener(queuesToDeclare = @Queue(name = &quot;$&#123;my.queue&#125;&quot;, durable = &quot;true&quot;))</div><div class="line">  public String handleWithSimpleDeclare(String data) &#123;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果使用了Header模式，参数的配置需要写在arguments里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(bindings = @QueueBinding(</div><div class="line">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</div><div class="line">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</div><div class="line">                                                type = &quot;java.lang.Integer&quot;)),</div><div class="line">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</div><div class="line">        arguments = &#123;</div><div class="line">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</div><div class="line">                @Argument(name = &quot;foo&quot;, value = &quot;bar&quot;),</div><div class="line">                @Argument(name = &quot;baz&quot;)</div><div class="line">        &#125;)</div><div class="line">)</div><div class="line">public String handleWithHeadersExchange(String foo) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是一个生命周期的管理组件，它提供了启动和停止的方法。在配置容器时，可以显式的对队列和监听器进行绑定。最常使用的是SimpleMessageListenerContainer,官方给出的配置是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public SimpleMessageListenerContainer messageListenerContainer() &#123;</div><div class="line">    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</div><div class="line">    container.setConnectionFactory(rabbitConnectionFactory());</div><div class="line">    container.setQueueName(&quot;some.queue&quot;);</div><div class="line">    container.setMessageListener(exampleListener());</div><div class="line">    return container;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public MessageListener exampleListener() &#123;</div><div class="line">    return new MessageListener() &#123;</div><div class="line">        public void onMessage(Message message) &#123;</div><div class="line">            System.out.println(&quot;received: &quot; + message);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到这里绑定的监听器功能比较单一，如果我们希望能够在接收到信息进行处理并手动ack的话可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">container.setMessageListener(new ChannelAwareMessageListener() &#123;</div><div class="line"></div><div class="line">        public void onMessage(Message message, com.rabbitmq.client.Channel channel) throws Exception &#123;</div><div class="line">            byte[] body = message.getBody();</div><div class="line">            logger.info(&quot;消费端接收到消息 : &quot; + new String(body));</div><div class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">同时在template要加入一项配置  rabbitConfirmCallBack是注入进来的</div><div class="line">template.setConfirmCallback(rabbitConfirmCallBack);</div><div class="line"></div><div class="line"></div><div class="line">@Component</div><div class="line">public class RabbitConfirmCallBack implements RabbitTemplate.ConfirmCallback&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</div><div class="line">        if(ack)&#123;</div><div class="line">            System.out.println(correlationData);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(cause);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">在这里就可以把之前的东西串起来了</div></pre></td></tr></table></figure><h4 id="MessageConverter-消息转换"><a href="#MessageConverter-消息转换" class="headerlink" title="MessageConverter 消息转换"></a>MessageConverter 消息转换</h4><p>在唤醒一个listener之前，其实有两个步骤。是使用MessageConverter将Spring AMQP Message转换成spring-messaging Message。</p><p>第一步默认的MessageConverter是Spring AMQP SimpleMessageConverter，它处理String和java.io.Serializable对象的转换，其他对象则是byte[]的形式。我们称这个处理器为消息转换器。</p><p>第二步的默认转换器是GenericMessageConverter，它委托给DefaultFormattingConversionService进行转换，我们称之为方法参数转换器。</p><p>如果我们要修改MessageConverter可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() &#123;</div><div class="line">    SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();</div><div class="line">    ...</div><div class="line">    factory.setMessageConverter(new Jackson2JsonMessageConverter());</div><div class="line">    ...</div><div class="line">    return factory;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用了一个jackson2的转换器，但是你需要显式的指定头信息才会起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setContentType(&quot;application/json;utf-8&quot;)</div></pre></td></tr></table></figure><p>如果你想指定方法参数转换器，可以这么做</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@EnableRabbit</div><div class="line">public class AppConfig implements RabbitListenerConfigurer &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</div><div class="line">        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();</div><div class="line">        factory.setMessageConverter(new GenericMessageConverter(myConversionService()));</div><div class="line">        return factory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public ConversionService myConversionService() &#123;</div><div class="line">        DefaultConversionService conv = new DefaultConversionService();</div><div class="line">        conv.addConverter(mySpecialConverter());</div><div class="line">        return conv;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) &#123;</div><div class="line">        registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="消息回复"><a href="#消息回复" class="headerlink" title="消息回复"></a>消息回复</h4><p>MessageListenerAdapter现在已经支持方法具有非void的返回类型。在这种情况下，调用的结果被封装在原始消息的ReplyToAddress头中指定的地址或者在listener上配置的默认地址中发送的消息中。现在可以使用@SendTo注释来设置该默认地址。</p><p>假设我们的processOrder方法现在应该返回一个OrderStatus，那么可以把它写成如下来自动发送一个回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(destination = &quot;myQueue&quot;)</div><div class="line">@SendTo(&quot;status&quot;)</div><div class="line">public OrderStatus processOrder(Order order) &#123;</div><div class="line">    // order processing</div><div class="line">    return status;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果你需要配置一些额外的头信息，可以返回一个Message实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(destination = &quot;myQueue&quot;)</div><div class="line">@SendTo(&quot;status&quot;)</div><div class="line">public Message&lt;OrderStatus&gt; processOrder(Order order) &#123;</div><div class="line">    // order processing</div><div class="line">    return MessageBuilder</div><div class="line">        .withPayload(status)</div><div class="line">        .setHeader(&quot;code&quot;, 1234)</div><div class="line">        .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@SendTo的值也可以使用 Exchange/routingKey的组合</p><ul><li>foo/bar         返回给foo交换器，routingKey为bar</li><li>foor/           返回给交换器，routingKey默认为空</li><li>bar 或者 /bar     指定routingKey使用默认交换器</li><li>/                默认交换器 默认routingKey</li></ul><p>1.5版本之后，@SendTo支持SpEL表达式。表达式必须返回一个String类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(queues = &quot;test.sendTo.spel&quot;)</div><div class="line">@SendTo(&quot;#&#123;spelReplyTo&#125;&quot;)</div><div class="line">public String capitalizeWithSendToSpel(String foo) &#123;</div><div class="line">    return foo.toUpperCase();</div><div class="line">&#125;</div><div class="line">...</div><div class="line">@Bean</div><div class="line">public String spelReplyTo() &#123;</div><div class="line">    return &quot;test.sendTo.reply.spel&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="多方法的listener"><a href="#多方法的listener" class="headerlink" title="多方法的listener"></a>多方法的listener</h4><p>从1.5版本开始，支持类级别的@RabbitListener注解，通过@RabbitHandler方法级别的注解，允许单个listener根据传入消息的payload调用不同的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@RabbitListener(id=&quot;multi&quot;, queues = &quot;someQueue&quot;)</div><div class="line">public class MultiListenerBean &#123;</div><div class="line"></div><div class="line">    @RabbitHandler</div><div class="line">    @SendTo(&quot;my.reply.queue&quot;)</div><div class="line">    public String bar(Bar bar) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @RabbitHandler</div><div class="line">    public String baz(Baz baz) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @RabbitHandler</div><div class="line">    public String qux(@Header(&quot;amqp_receivedRoutingKey&quot;) String rk, @Payload Qux qux) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单来说，系统会根据Handler所在方法接受的参数选择由哪个Handler来执行。如果方法有多个参数，那么可以通过注解来指定payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RabbitHandler</div><div class="line">public String qux(@Header(&quot;amqp_receivedRoutingKey&quot;) String rk, @Payload Qux qux) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>从版本2.0开始,RabbitListener注释具有两个新属性：errorHandler和returnExceptions。<br>listener可以监听异常，包装在一个ListenerExecutionFailedException中。错误处理程序可以返回一些结果给发送者，也可以直接抛出异常，取决于returnException的设置。</p><p>当returnException为true时，会返回消息给发送者。异常被包装在RemoteInvocationResult对象中。在发送方需要配置一个RemoteInvocationAwareMessageConverterAdapter在template中，它将异常包装在AmqpRemoteException中并重新抛出一个服务器的异常，通过异常堆栈就可以定位错误。</p><p>但是这种机制只能在SimpleMessageConverter配置下工作，也就是默认的配置。如果你指定了jackson转换器，由于异常消息通常不是json，所以并不支持这种序列化。如果一定要使用jackson converter，那么应该把错误处理转换为可以序列化为json的对象。</p><p>####多线程与异步消费者</p><p>异步消费者的使用涉及到一系列不同的线程。</p><p>当一个新的消息到达RabbitMq客户端时，会从SimpleMessageListenerContainer中配置的TaskExecutor线程池中获取线程并唤醒MessageListener。如果没有配置，则会使用SimpleAsyncTaskExecutor。如果使用的是DirectMessageListenerContainer，MessageListener则会由RabbitMq客户端来唤醒，这种情况下，TaskExecutor用于监视消费者任务的执行。</p><p>使用默认的SimpleAsyncTaskExecutor时，被listener调用的线程，它的threadNamePrefix属性会被设置为listener容器的beanName，这对于日志的分析非常有用。</p><h4 id="容器选择"><a href="#容器选择" class="headerlink" title="容器选择"></a>容器选择</h4><p>在2.0版本中加入了DirectMessageListenerContainer(DMLC),在此之前只有SimpleMessageListenerContainer(SMLC)。SMLC使用了一个内部队列，每个消费者都有一个独有的线程为它服务。如果一个container配置为监听多个队列，则使用相同的consumer线程处理所有的队列。并发由concurrentConsumers和一些其他属性来控制。当消息到达rabbitmq客户端，客户端线程将它们加入队列再传递给消费者。</p><p>DMLC直接通过rabbitmq客户端线程唤醒listener，因此它的结构比SMLC更简单。但是它们有各自的优势:</p><p>SMLC独有特点:</p><ul><li>txSize 可以通过这个属性控制事务中传递的Message的数量，并且增加或减少ack的数量，但是这样做可能会导致消息发送失败后重复发送的次数增加。</li><li>maxConcurrentConsumers DMLC中不支持自动缩放，只能够已编码的方式修改consumersPerQueue的属性</li></ul><p>DMLC优势：</p><ul><li>相比于SMLC，DMLC更方便的可以再运行时动态的添加或者删除队列</li><li>避免了rabbitmq客户端线程和消费者线程之间的上下文切换</li><li>消费者之间共享线程，而SMLC则是为每个消费者提供专用线程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA继承机制与多态</title>
      <link href="/2018/01/30/JAVA%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>/2018/01/30/JAVA%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>java的继承机制无论在工作中还是面试中，都是一个让人非常迷惑的地方。今天被一个朋友的问题难住了，所以查阅了一下相关的资料，在此整理一下</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>java不支持多继承但支持实现多个接口</li><li>在多态情况下,重写方法会调用派生类的方法。非多态情况下会调用本类的方法</li><li>对于不同的访问修饰符，成员变量的覆盖情况不同</li></ol><p>下面举几个例子加深理解，题目来源于网络</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="对于方法"><a href="#对于方法" class="headerlink" title="对于方法"></a>对于方法</h3><blockquote><p>1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Base</div><div class="line">&#123;</div><div class="line">    private String baseName = &quot;base&quot;;</div><div class="line">    public Base()</div><div class="line">    &#123;</div><div class="line">        callName();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void callName()</div><div class="line">    &#123;</div><div class="line">        System. out. println(baseName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class Sub extends Base</div><div class="line">    &#123;</div><div class="line">        private String baseName = &quot;sub&quot;;</div><div class="line">        public void callName()</div><div class="line">        &#123;</div><div class="line">            System. out. println (baseName) ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        Base b = new Sub();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>答案是null</p></blockquote><p>在创造派生类的过程中首先创建基类对象，然后才能创建派生类。<br>创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName()方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null。</p><p>1.首先，需要明白类的加载顺序。</p><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p><p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p><p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p><p>(4) 父类构造函数</p><p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p><p>(6) 子类构造函数</p><p>其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)</p><p>2.其次，需要理解子类覆盖父类方法的问题，也就是方法重写实现多态问题。<br>Base b = new Sub();它为多态的一种表现形式，声明是Base,实现是Sub类， 理解为 b 编译时表现为Base类特性，运行时表现为Sub类特性。<br>当子类覆盖了父类的方法后，意思是父类的方法已经被重写，题中 父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。<br>由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。</p><p>在内存机制中，父类和子类是占用同一块内存的，只不过子类在父类的基础上增加了自己的部分(包括数据成员和属性)。子类是依附于父类的，先有父类再有子类。所以说一个子类对象的产生，必须先调用父类的构造函数产生一个父类实例，然后在这个实例基础上添加自己的部分。而实际的运行机制，也正是这样的。</p><h3 id="对于成员变量"><a href="#对于成员变量" class="headerlink" title="对于成员变量"></a>对于成员变量</h3><blockquote><p>观察这样一个demo</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class Father &#123;</div><div class="line">    int x = 1;</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;father static&quot;);</div><div class="line">    &#125;</div><div class="line">    public Father()&#123;</div><div class="line">        System.out.println(&quot;father&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Son extends Father&#123;</div><div class="line">    int x = 2;</div><div class="line">    static&#123;</div><div class="line">        System.out.println(&quot;son static&quot;);</div><div class="line">    &#125;</div><div class="line">    public Son()&#123;</div><div class="line">        System.out.println(&quot;son&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    Father father = new Son();</div><div class="line">    System.out.println(father.x);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>答案是1,派生类并没有覆盖父类的同名属性,为什么重写的方法会覆盖，同名的属性却不会呢,继续做一下扩展在得出结论</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public class Father &#123;</div><div class="line">    private String privateField = &quot;父类变量--private&quot;;</div><div class="line"></div><div class="line">    String friendlyField = &quot;父类变量--friendly&quot;;</div><div class="line"></div><div class="line">    protected String protectedField = &quot;父类变量--protected&quot;;</div><div class="line"></div><div class="line">    public String publicField = &quot;父类变量--public&quot;;</div><div class="line"></div><div class="line">    // private的变量无法直接访问，因此我们给他增加了一个访问方法</div><div class="line">    public String getPrivateFieldValue() &#123;</div><div class="line">        return privateField;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Son extends Father&#123;</div><div class="line">    private String privateField = &quot;子类变量--private&quot;;</div><div class="line"></div><div class="line">    String friendlyField = &quot;子类变量--friendly&quot;;</div><div class="line"></div><div class="line">    protected String protectedField = &quot;子类变量--protected&quot;;</div><div class="line"></div><div class="line">    public String publicField = &quot;子类变量--public&quot;;</div><div class="line"></div><div class="line">    // private的变量无法直接访问，因此我们给他增加了一个访问方法</div><div class="line">    public String getPrivateFieldValue() &#123;</div><div class="line">        return privateField;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">        //非多态</div><div class="line">        Father father = new Father();</div><div class="line">        System.out.println(father.friendlyField);</div><div class="line">        System.out.println(father.protectedField);</div><div class="line">        System.out.println(father.publicField);</div><div class="line">        System.out.println(father.getPrivateFieldValue());</div><div class="line">        System.out.println(&quot;=======================&quot;);</div><div class="line">        //多态</div><div class="line">        Father father1 = new Son();</div><div class="line">        System.out.println(father1.friendlyField);</div><div class="line">        System.out.println(father1.protectedField);</div><div class="line">        System.out.println(father1.publicField);</div><div class="line">        System.out.println(father1.getPrivateFieldValue());</div><div class="line">        System.out.println(&quot;========================&quot;);</div><div class="line">        //非多态</div><div class="line">        Son son = new Son();</div><div class="line">        System.out.println(son.friendlyField);</div><div class="line">        System.out.println(son.protectedField);</div><div class="line">        System.out.println(son.publicField);</div><div class="line">        System.out.println(son.getPrivateFieldValue());</div><div class="line">    &#125;</div></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">父类变量--friendly</div><div class="line">父类变量--protected</div><div class="line">父类变量--public</div><div class="line">父类变量--private</div><div class="line">=======================</div><div class="line">父类变量--friendly</div><div class="line">父类变量--protected</div><div class="line">父类变量--public</div><div class="line">子类变量--private</div><div class="line">========================</div><div class="line">子类变量--friendly</div><div class="line">子类变量--protected</div><div class="line">子类变量--public</div><div class="line">子类变量--private</div></pre></td></tr></table></figure><p>对于两种非多态的情况，输出的结果很好理解。对于多态的情况，子类只覆盖了private修饰的属性。</p><p>暂时可以得到的结论是属性的覆盖与修饰属性的访问权限有关。那么访问权限之间有没有优先级呢？继续做一些测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Father &#123;</div><div class="line">    String friendlyField = &quot;父类变量--friendly&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Son extends Father&#123;</div><div class="line">    public String friendlyField = &quot;子类变量&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Father father1 = new Son();</div><div class="line">        System.out.println(father1.friendlyField);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">父类变量--friendly</div><div class="line"></div><div class="line">.....省略n种排列组合测试，结果都不会覆盖</div></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>实际上，即使子类声明了与父类完全一样的成员变量，也不会覆盖掉父类的成员变量。而是在子类实例化时，会同时定义两个成员变量，子类也可以同时访问到这两个成员变量，但父类不能访问到子类的成员变量（父类不知道子类的存在）。而具体在方法中使用成员变量时，究竟使用的是父类还是子类的成员变量，则由方法所在的类决定；即，方法在父类中定义和执行，则使用父类的成员变量，方法在子类中定义（包括覆盖父类方法）和执行，则使用子类的成员变量。方法在多态情况下，除了private都会显示为父类的属性。那如果我们就是想要得到子类的属性，该怎么办呢。我们可以利用继承的重写方法的特点，子类、父类声明get/set方法,那么我们调用方法就可以得到子类的属性啦。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-StampedLock(8)</title>
      <link href="/2018/01/30/JUC-StampedLock-8/"/>
      <url>/2018/01/30/JUC-StampedLock-8/</url>
      
        <content type="html"><![CDATA[<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock字面上理解就是带有时间戳的lock，这个锁是在java8中加入的。为什么要加入这样一个锁呢，原因就要从ReentrantLock和ReadWriteLock给我们带来的便利和问题说起。</p><h4 id="ReentrantLock-vs-synchronized"><a href="#ReentrantLock-vs-synchronized" class="headerlink" title="ReentrantLock vs synchronized"></a>ReentrantLock vs synchronized</h4><ol><li>lock的api更加灵活，显式的释放获取锁</li><li>lock可以进行扩展，synchronized不可以</li><li>lock的效率目前略高于synchronized，以为在java每个版本升级中，都会对synchronized关    键字进行优化</li></ol><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h4 id="ReentrantReadWriteLock-vs-ReentrantLock"><a href="#ReentrantReadWriteLock-vs-ReentrantLock" class="headerlink" title="ReentrantReadWriteLock vs ReentrantLock"></a>ReentrantReadWriteLock vs ReentrantLock</h4><ol><li>解决在并发读的过程中不需要加锁</li></ol><h4 id="StampedLock-使用场景"><a href="#StampedLock-使用场景" class="headerlink" title="StampedLock 使用场景"></a>StampedLock 使用场景</h4><p>假设现在有100个线程想要请求资源A，其中99个是读请求，1个是写请求。如果是读请求先获取到资源，那么就可能造成写的饥饿，如果写请求先获取到资源，那么久可能造成读请求的长时间等待。StampedLock的作用就是替换ReentrantLock和ReentrantReadWriteLock,因为StampedLock有这两者的API。ReadWriteLock虽然做到了读写分离，但是它实现的读锁是一个悲观锁，而StampedLock实现了一个乐观的读锁。也就是说在读的同时可以做到写，通过代码看看是怎么做到的。</p><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><p>使用StampedLock分别使用悲观读锁和乐观读锁，7个读线程和1个写线程，观察效果</p><p>使用悲观读锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">public class StampedLockTest &#123;</div><div class="line">    private static StampedLock lock = new StampedLock();</div><div class="line">    private static  List&lt;Long&gt; data = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(30);</div><div class="line">        Runnable runnable = ()-&gt;&#123;</div><div class="line">          while (true)&#123;</div><div class="line">              read();</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        Runnable runnable1 = ()-&gt;&#123;</div><div class="line">            while (true)&#123;</div><div class="line">                write();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable1);</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void read()&#123;</div><div class="line">        long stamped = -1;</div><div class="line">        try &#123;</div><div class="line">            stamped = lock.readLock();</div><div class="line">            //假设任务是读出data中的数据</div><div class="line">            Optional.of(data.stream().map(String::valueOf)</div><div class="line">                    .collect(Collectors.joining(&quot;#&quot;,&quot;R&quot;,&quot;&quot;)))</div><div class="line">                    .ifPresent(System.out::println);</div><div class="line">            TimeUnit.SECONDS.sleep(1);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock(stamped);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    private static void write()&#123;</div><div class="line">        long stamp = -1;</div><div class="line">        try&#123;</div><div class="line">            stamp=lock.writeLock();</div><div class="line">            data.add(System.currentTimeMillis());</div><div class="line">            TimeUnit.SECONDS.sleep(1);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally&#123;</div><div class="line">            lock.unlock(stamp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用乐观读锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public class StampedLockTest1 &#123;</div><div class="line">    private static StampedLock lock = new StampedLock();</div><div class="line">    private static  List&lt;Long&gt; data = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(30);</div><div class="line">        Runnable runnable = ()-&gt;&#123;</div><div class="line">          while (true)&#123;</div><div class="line">              read();</div><div class="line">          &#125;</div><div class="line">        &#125;;</div><div class="line">        Runnable runnable1 = ()-&gt;&#123;</div><div class="line">            while (true)&#123;</div><div class="line">                write();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable);</div><div class="line">        executorService.submit(runnable1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void read()&#123;</div><div class="line">        long stamped =lock.tryOptimisticRead();</div><div class="line">        //检查乐观锁是否被修改，如果有就拿不到锁</div><div class="line">        if(!lock.validate(stamped))&#123;</div><div class="line">            try&#123;</div><div class="line">                stamped=lock.readLock();</div><div class="line">                //假设任务是读出data中的数据</div><div class="line">                Optional.of(data.stream().map(String::valueOf)</div><div class="line">                        .collect(Collectors.joining(&quot;#&quot;,&quot;R&quot;,&quot;&quot;)))</div><div class="line">                        .ifPresent(System.out::println);</div><div class="line">                TimeUnit.SECONDS.sleep(1);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; finally &#123;</div><div class="line">                lock.unlock(stamped);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    private static void write()&#123;</div><div class="line">        long  stamp = -1;</div><div class="line">        try&#123;</div><div class="line">            stamp=lock.writeLock();</div><div class="line">            data.add(System.currentTimeMillis());</div><div class="line">            TimeUnit.SECONDS.sleep(1);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally&#123;</div><div class="line">            lock.unlock(stamp);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>7个读+1个写 乐观锁明显优于悲观锁。程序开始读线程便可写入数据，而悲观锁则需要等待很久</p><p>推荐一篇很好的性能比较的文章</p><blockquote><p><a href="https://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="external">https://blog.takipi.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMq入门-AmqpTemplate(4)</title>
      <link href="/2018/01/29/RabbitMq%E5%85%A5%E9%97%A8-AmqpTemplate-4/"/>
      <url>/2018/01/29/RabbitMq%E5%85%A5%E9%97%A8-AmqpTemplate-4/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>与Spring Framework及其相关项目提供的许多其他高级抽象一样，Spring AMQP提供了一个扮演主角的“template”。定义主要操作的接口称为AmqpTemplate。这些操作涵盖发送和接收消息的一般行为。换句话说，它们不是唯一的实现，因此名称中有“AMQP”。另一方面，这个接口的实现与AMQP协议的实现有关。与JMS（接口级API本身）不同，AMQP是一个有线协议。该协议的实现提供了自己的客户端库，因此AmqpTemplate接口的每个实现都将依赖于特定的客户端库。目前，只有一个实现：RabbitTemplate。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="增加重试机制"><a href="#增加重试机制" class="headerlink" title="增加重试机制"></a>增加重试机制</h3><p>从版本1.3开始，可以将RabbitTemplate配置为使用RetryTemplate来解决borker连接问题。以下仅是一个使用指数退避策略的示例，以及默认的SimpleRetryPolicy，它会在向调用方抛出异常之前进行三次尝试。</p><p>XML方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; retry-template=&quot;retryTemplate&quot;/&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;retryTemplate&quot; class=&quot;org.springframework.retry.support.RetryTemplate&quot;&gt;</div><div class="line">    &lt;property name=&quot;backOffPolicy&quot;&gt;</div><div class="line">        &lt;bean class=&quot;org.springframework.retry.backoff.ExponentialBackOffPolicy&quot;&gt;</div><div class="line">            &lt;property name=&quot;initialInterval&quot; value=&quot;500&quot; /&gt;</div><div class="line">            &lt;property name=&quot;multiplier&quot; value=&quot;10.0&quot; /&gt;</div><div class="line">            &lt;property name=&quot;maxInterval&quot; value=&quot;10000&quot; /&gt;</div><div class="line">        &lt;/bean&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>@Configuration方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public AmqpTemplate rabbitTemplate();</div><div class="line">    RabbitTemplate template = new RabbitTemplate(connectionFactory());</div><div class="line">    RetryTemplate retryTemplate = new RetryTemplate();</div><div class="line">    ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();</div><div class="line">    backOffPolicy.setInitialInterval(500);</div><div class="line">    backOffPolicy.setMultiplier(10.0);</div><div class="line">    backOffPolicy.setMaxInterval(10000);</div><div class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</div><div class="line">    template.setRetryTemplate(retryTemplate);</div><div class="line">    return template;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###异步发布，如何检测成功还是失败</p><p>发布消息在默认情况下是一种异步机制，RabbitMQ简单地丢弃无法路由的消息。如果成功发布，可以收到一个异步确认信息，我们来考虑两个失败情况：</p><ol><li>发布到exchange，但是没有相匹配的目的队列</li><li>发布到一个不存在exchange</li></ol><p>第一种只需要一个发布确认机制即可。对于第二种情况，会直接丢弃信息而不会产生返回值，底层的channel会因为异常而关闭。默认情况下，这个异常会被记录，你也可以注册一个ConnectionListener获取通知。<br>(在这里官方文档有明显的错误,。本人使用的是1.5.9,函数已经被修改，没有提供异常检测的方法)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">this.connectionFactory.addConnectionListener(new ConnectionListener() &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onCreate(Connection connection) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onShutDown(ShutdownSignalException signal) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="发布确认和返回"><a href="#发布确认和返回" class="headerlink" title="发布确认和返回"></a>发布确认和返回</h3><p>AmqpTemplate的RabbitTemplate实现支持Publisher确认和返回。</p><h4 id="消息返回"><a href="#消息返回" class="headerlink" title="消息返回"></a>消息返回</h4><p>对于返回的消息，必须将模板的mandatory属性设置为true，或者对于特定的消息，必须将mandatory-expression设置为true。此功能需要将其publisherReturns属性设置为true的CachingConnectionFactory。返回通过调用setReturnCallback（ReturnCallback回调）注册一个RabbitTemplate.ReturnCallback发送到客户端。回调必须实现这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class RabbitCallBack implements RabbitTemplate.ReturnCallback &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void returnedMessage(Message message, int replyCode, String replyText,</div><div class="line">                                String exchange, String routingKey) &#123;</div><div class="line">        System.out.println(&quot;收到消息&quot;+message.getBody()+&quot;响应码&quot;+replyCode+&quot;响应内容&quot;+replyText+&quot;来自Exchange:&quot;+exchange+&quot;RoutingKey&quot;+routingKey);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">将上面的类注入到配置类中</div><div class="line">template.setReturnCallback(rabbitCallBack);</div></pre></td></tr></table></figure><p>需要注意的是，每个RabbitTemplate只支持一个ReturnCallback。</p><p>####消息确认</p><p>对于发布者确认（也称为发布者确认），该模板需要一个将其publisherConfirms属性设置为true。通过调用setConfirmCallback（ConfirmCallback回调）注册一个RabbitTemplate.ConfirmCallback，确认被发送到客户端。回调必须实现这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class RabbitConfirmCallBack implements RabbitTemplate.ConfirmCallback&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123;</div><div class="line">if(ack)&#123;</div><div class="line">            System.out.println(correlationData);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(cause);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">将上面的类注入到配置类中</div><div class="line">template.setConfirmCallback(rabbitConfirmCallBack);</div></pre></td></tr></table></figure><p>CorrelationData是客户端接收到的原始信息，如果ack为true，表示信息经过确认，如果ack为false，则cause会包含ack为false的原因。</p><p>RabbitTemplate只支持一个ConfirmCallback</p><p>当rabbitTemplate发送操作完成时，通道关闭;当连接工厂缓存已满时，将阻止接收确认或返回消息。当缓存满时，框架将延迟关闭达5秒钟，以便有时间接收确认/返回。当使用确认时，当收到最后一次确认时，频道将被关闭。仅使用返回时，通道将保持打开5秒。通常建议将连接工厂的channelCacheSize设置为足够大的值，以使发布消息的通道返回缓存而不是关闭。您可以使用RabbitMQ management plugin监控频道使用情况;如果您看到频道正在快速打开/关闭，则应考虑增加缓存大小以减少服务器上的开销。</p><h3 id="与spring-message整合"><a href="#与spring-message整合" class="headerlink" title="与spring message整合"></a>与spring message整合</h3><p>从版本1.4开始，构建在RabbitTemplate之上的RabbitMessagingTemplate提供了与Spring Framework消息抽象（即org.springframework.messaging.Message）的集成。这允许你使用spring-messaging Message&lt;?&gt; 抽象来发送和接收消息。其他Spring项目（如Spring Integration和Spring的STOMP支持）使用了这种抽象。有两个消息转换器参与:一个用于在Spring消息传递Message&lt;?&gt;和Spring AMQP的Message抽象之间进行转换，另一个用于在Spring AMQP的Message抽象和底层RabbitMQ客户端库所需的格式之间进行转换。默认情况下，消息的payload由的RabbitTemplate的消息转换器负责转换。或者，你可以注入一个自定义MessagingMessageConverter与其他payload转换器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MessagingMessageConverter amqpMessageConverter = new MessagingMessageConverter();</div><div class="line">amqpMessageConverter.setPayloadConverter(myPayloadConverter);</div><div class="line">rabbitMessagingTempalte.setAmqpMessageConverter(amqpMessageConverter);</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对RabbitMq进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">   private RabbitCallBack rabbitCallBack;</div><div class="line">   @Autowired</div><div class="line">   private RabbitConfirmCallBack rabbitConfirmCallBack;</div><div class="line"></div><div class="line">   @Bean</div><div class="line">   public ConnectionFactory rabbitMqConnection() &#123;</div><div class="line">       CachingConnectionFactory connectionFactory = new CachingConnectionFactory();</div><div class="line">       connectionFactory.setHost(&quot;47.95.205.65&quot;);</div><div class="line">       connectionFactory.setPort(5672);</div><div class="line">       connectionFactory.setConnectionNameStrategy(ConnectionFactory -&gt; &quot;MyConnection&quot;);</div><div class="line">       connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line">       connectionFactory.setUsername(&quot;admin&quot;);</div><div class="line">       connectionFactory.setPassword(&quot;123&quot;);</div><div class="line">       connectionFactory.setChannelCacheSize(25);</div><div class="line">       //单位是毫秒</div><div class="line">       connectionFactory.setChannelCheckoutTimeout(2000);</div><div class="line">       connectionFactory.setPublisherConfirms(true);</div><div class="line">       connectionFactory.setPublisherReturns(true);</div><div class="line">       connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CHANNEL);</div><div class="line">       return connectionFactory;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   @Bean</div><div class="line">   public AmqpTemplate rabbitTemplate() &#123;</div><div class="line">       RabbitTemplate template = new RabbitTemplate(rabbitMqConnection());</div><div class="line">       RetryTemplate retryTemplate = new RetryTemplate();</div><div class="line">       ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();</div><div class="line">       backOffPolicy.setInitialInterval(500);</div><div class="line">       backOffPolicy.setMultiplier(10.0);</div><div class="line">       backOffPolicy.setMaxInterval(10000);</div><div class="line">       retryTemplate.setBackOffPolicy(backOffPolicy);</div><div class="line">       template.setRetryTemplate(retryTemplate);</div><div class="line">       template.setMandatory(true);</div><div class="line">       template.setReturnCallback(rabbitCallBack);</div><div class="line">       template.setConfirmCallback(rabbitConfirmCallBack);</div><div class="line">       return template;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMq入门-连接和资源管理(3)</title>
      <link href="/2018/01/29/RabbitMq%E5%85%A5%E9%97%A8-%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-3/"/>
      <url>/2018/01/29/RabbitMq%E5%85%A5%E9%97%A8-%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官方文档  <a href="https://docs.spring.io/spring-amqp/docs/2.0.1.RELEASE/reference/html/_reference.html#_introduction_4" target="_blank" rel="external">https://docs.spring.io/spring-amqp/docs/2.0.1.RELEASE/reference/html/_reference.html#_introduction_4</a></p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用于管理与RabbitMQ代理的核心组件是ConnectionFactory接口。ConnectionFactory的实现类负责提供一个org.springframework.amqp.rabbit.connection.Connection的实例，它是com.rabbitmq.client.Connection的一个封装。官方提供的唯一的具体实现是CachingConnectionFactory。默认情况下，它建立一个可以被应用程序共享的连接代理(可以理解为一个全局配置)。因为与AMQP进行消息传递的“工作单元”实际上是一个“通道”（在某些方面，这与JMS中的Connection和Session之间的关系类似），所以可以共享连接。如你所想，连接实例提供了一个createChannel方法。 CachingConnectionFactory实现支持这些通道的高速缓存，并根据它们是否是事务处理来维护通道的单独高速缓存。在创建CachingConnectionFactory的实例时，可以通过构造函数提供主机名,用户名和密码。如果你想配置通道缓存的大小（默认是25），你也可以在这里调用setChannelCacheSize()方法.</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fnxha39o1fj30l209c74z.jpg" alt=""></p><p>可以看到一个SingleConnectionFactory实现类，它只在框架的单元测试代码中可用。它比CachingConnectionFactory简单，因为它不会缓存通道，但由于缺乏性能和弹性，它不适用于简单测试之外的实际应用。如果由于某种原因需要实现自己的ConnectionFactory，那么可以通过继承AbstractConnectionFactory来实现。</p><p>从版本1.3开始，CachingConnectionFactory可以缓存连接数也可以只缓存通道。在这种情况下，每次调用createConnection()都会创建一个新连接（或从缓存中检索一个空闲连接）。关闭连接会将其返回到缓存（如果尚未达到缓存大小）。在这样的连接上创建的通道也被缓存。</p><p>如果缓存大小为10，则可以使用任意数量的通道。如果超过10个通道正在使用，他们都返回到缓存，10将进入缓存;其余的将被关闭。</p><p>从版本1.6开始，默认通道高速缓存大小从1增加到25.在大容量，多线程环境中，缓存太小意味着频繁地创建和关闭通道。增加默认缓存大小将避免这种开销。可以通过RabbitMQ管理界面监视正在使用的频道，并且如果您看到许多频道正在创建和关闭，请考虑进一步增加缓存大小。缓存只能按需增长（以适应应用程序的并发需求），所以这种改变不会影响现有的低容量应用程序。</p><p>从版本1.4.2开始，CachingConnectionFactory有一个属性channelCheckoutTimeout。当此属性大于零时，channelCacheSize将成为可在连接上创建的通道数的最大值。如果达到限制，调用线程将阻塞，直到有一个通道可用或达到超时，在这种情况下会引发AmqpTimeoutException。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="标准的连接"><a href="#标准的连接" class="headerlink" title="标准的连接"></a>标准的连接</h4><p>如果没有使用spring框架创建通道，则需要手动的创建通道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CachingConnectionFactory connectionFactory = new CachingConnectionFactory(&quot;somehost&quot;);</div><div class="line">connectionFactory.setUsername(&quot;guest&quot;);</div><div class="line">connectionFactory.setPassword(&quot;guest&quot;);</div><div class="line"></div><div class="line">Connection connection = connectionFactory.createConnection();</div></pre></td></tr></table></figure><p>XML配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;connectionFactory&quot;</div><div class="line">      class=&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;somehost&quot;/&gt;</div><div class="line">    &lt;property name=&quot;username&quot; value=&quot;guest&quot;/&gt;</div><div class="line">    &lt;property name=&quot;password&quot; value=&quot;guest&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><p>如果配置了rabbitmq的命名空间，也可以这样做。它会使用默认的配置创建一个CachingConnectionFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;/&gt;</div></pre></td></tr></table></figure><p>从版本2.0开始，为注入到AbstractionConnectionFactory提供了一个ConnectionNameStrategy。生成的名称用于目标RabbitMQ连接的应用程序特定标识。如果RabbitMQ服务器支持，连接名称将显示在管理UI中。该值不必是唯一的，并且不能用作连接标识符，例如在HTTP API请求中。该值应该是可以让人理解的，并且是connection_name键下的ClientProperties的一部分。可以简单的使用lambda表达式设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connectionFactory.setConnectionNameStrategy(ConnectionFactory-&gt;&quot;MyConnection&quot;);</div></pre></td></tr></table></figure><p>当应用程序使用单个CachingConnectionFactory进行配置时，也就是默认情况下使用Spring Boot自动配置。当Broker(rabbitmq实例)阻止连接时，应用程序将停止工作。也就是说当Broker停止工作时，任何client也会无法使用。如果我们在同一个应用程序中有生产者和消费者，那么当生产者阻塞连接时，可能会导致死锁，因为Broker上没有资源，消费者也不能释放它们，因为连接被阻塞。为了缓解这个问题，需要再配置一个CachingConnectionFactory实例，一个用于生产者，一个用于消费者。分离的CachingConnectionFactory不推荐用于事务性生产者，因为事务性的生产者应该与消费者使用相同的通道。</p><h4 id="安全的连接-ssl"><a href="#安全的连接-ssl" class="headerlink" title="安全的连接(ssl)"></a>安全的连接(ssl)</h4><p>从版本1.4开始，提供了一个方便的RabbitConnectionFactoryBean，以便使用依赖注入方便地在底层客户端连接工厂中配置SSL属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;rabbit:connection-factory id=&quot;rabbitConnectionFactory&quot;</div><div class="line">    connection-factory=&quot;clientConnectionFactory&quot;</div><div class="line">    host=&quot;$&#123;host&#125;&quot;</div><div class="line">    port=&quot;$&#123;port&#125;&quot;</div><div class="line">    virtual-host=&quot;$&#123;vhost&#125;&quot;</div><div class="line">    username=&quot;$&#123;username&#125;&quot; password=&quot;$&#123;password&#125;&quot; /&gt;</div><div class="line"></div><div class="line">&lt;bean id=&quot;clientConnectionFactory&quot;</div><div class="line">        class=&quot;org.springframework.xd.dirt.integration.rabbit.RabbitConnectionFactoryBean&quot;&gt;</div><div class="line">    &lt;property name=&quot;useSSL&quot; value=&quot;true&quot; /&gt;</div><div class="line">    &lt;property name=&quot;sslPropertiesLocation&quot; value=&quot;file:/secrets/rabbitSSL.properties&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure><h4 id="Routing-Connection-Factory"><a href="#Routing-Connection-Factory" class="headerlink" title="Routing Connection Factory"></a>Routing Connection Factory</h4><p>从版本1.3开始，已经引入了AbstractRoutingConnectionFactory。这提供了一种机制来配置多个ConnectionFactory的映射，并在运行时通过一些lookupKey来确定目标ConnectionFactory。通常，实现检查线程绑定的上下文。为了方便起见，Spring AMQP提供了SimpleRoutingConnectionFactory，它从SimpleResourceHolder获取当前线程绑定的lookupKey。其核心的数据结构是一个Map<lookupkey,connection>，看一个使用demo</lookupkey,connection></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;connectionFactory&quot;</div><div class="line">      class=&quot;org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory&quot;&gt;</div><div class="line">&lt;property name=&quot;targetConnectionFactories&quot;&gt;</div><div class="line">&lt;map&gt;</div><div class="line">&lt;entry key=&quot;#&#123;connectionFactory1.virtualHost&#125;&quot; ref=&quot;connectionFactory1&quot;/&gt;</div><div class="line">&lt;entry key=&quot;#&#123;connectionFactory2.virtualHost&#125;&quot; ref=&quot;connectionFactory2&quot;/&gt;</div><div class="line">&lt;/map&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line"></div><div class="line">&lt;rabbit:template id=&quot;template&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class MyService &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private RabbitTemplate rabbitTemplate;</div><div class="line"></div><div class="line">    public void service(String vHost, String payload) &#123;</div><div class="line">        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);</div><div class="line">        rabbitTemplate.convertAndSend(payload);</div><div class="line">        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也就是说这种连接工厂支持动态的绑定和解绑你所使用的连接，但是需要注意，在使用完资源之后一定要unbind，就像lock方法一定要进行unlock。</p><h4 id="队列亲和性以及LocalizedQueueConnectionFactory"><a href="#队列亲和性以及LocalizedQueueConnectionFactory" class="headerlink" title="队列亲和性以及LocalizedQueueConnectionFactory"></a>队列亲和性以及LocalizedQueueConnectionFactory</h4><p>在群集中使用高可用队列时，为了获得最佳性能，可能需要连接到主队列所在的物理地址。虽然CachingConnectionFactory可以配置多个地址，但这只是用于故障转移，客户端将尝试按顺序重新连接。 LocalizedQueueConnectionFactory使用admin plugin提供的REST API来确定哪个节点的队列被选为主队列。然后它创建（或从缓存中检索）一个将连接到该节点的CachingConnectionFactory。如果连接失败，则确定新的主节点，并且让客户连接到它。 LocalizedQueueConnectionFactory配置了一个默认的连接工厂，以防队列的物理位置无法确定，在这种情况下，它将正常连接到集群。</p><p>出于这个原因（使用队列名称进行查找），LocalizedQueueConnectionFactory只能在容器配置为侦听单个队列时使用。</p><p>给出一个springboot的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">private RabbitProperties props;</div><div class="line"></div><div class="line">private final String[] adminUris = &#123; &quot;http://host1:15672&quot;, &quot;http://host2:15672&quot; &#125;;</div><div class="line"></div><div class="line">private final String[] nodes = &#123; &quot;rabbit@host1&quot;, &quot;rabbit@host2&quot; &#125;;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public ConnectionFactory defaultConnectionFactory() &#123;</div><div class="line">    CachingConnectionFactory cf = new CachingConnectionFactory();</div><div class="line">    cf.setAddresses(this.props.getAddresses());</div><div class="line">    cf.setUsername(this.props.getUsername());</div><div class="line">    cf.setPassword(this.props.getPassword());</div><div class="line">    cf.setVirtualHost(this.props.getVirtualHost());</div><div class="line">    return cf;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public ConnectionFactory queueAffinityCF(</div><div class="line">        @Qualifier(&quot;defaultConnectionFactory&quot;) ConnectionFactory defaultCF) &#123;</div><div class="line">    return new LocalizedQueueConnectionFactory(defaultCF,</div><div class="line">            StringUtils.commaDelimitedListToStringArray(this.props.getAddresses()),</div><div class="line">            this.adminUris, this.nodes,</div><div class="line">            this.props.getVirtualHost(), this.props.getUsername(), this.props.getPassword(),</div><div class="line">            false, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="消息发布确认与返回"><a href="#消息发布确认与返回" class="headerlink" title="消息发布确认与返回"></a>消息发布确认与返回</h4><p>通过将CachingConnectionFactory的publisherConfirms和publisherReturns属性分别设置为“true”来支持已确认和返回的消息。</p><p>当这些选项被设置时，由工厂创建的Channel被封装在一个PublisherCallbackChannel中，用于简化回调。当获得这样的channel时，客户端可以在channel上注册一个PublisherCallbackChannel.Listener。 PublisherCallbackChannel实现包含将确认/返回路由到合适的侦听器的逻辑。</p><h4 id="connectionListener和channelListener"><a href="#connectionListener和channelListener" class="headerlink" title="connectionListener和channelListener"></a>connectionListener和channelListener</h4><p>连接工厂支持注册ConnectionListener和ChannelListener实现。这使您可以接收有关connection和channel相关事件的通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">connectionFactory.setConnectionListeners();</div><div class="line">connectionFactory.setChannelListeners();</div></pre></td></tr></table></figure><h4 id="通道关闭事件日志"><a href="#通道关闭事件日志" class="headerlink" title="通道关闭事件日志"></a>通道关闭事件日志</h4><p>在1.5版本中引入了一个使用户能够控制日志级别的机制。</p><p>CachingConnectionFactory使用默认策略来记录通道关闭，如下所示：</p><p>正常通道关闭（200 OK）不记录。<br>如果通道由于被动队列声明失败而关闭，则会在调试级别进行记录。<br>如果由于独占消费者条件而导致basic.consume被拒绝，因此频道被关闭，则它将以INFO级别记录。<br>所有其他错误都记录在ERROR级别。</p><p>要修改此行为，请在其closeExceptionLogger属性中将自定义的ConditionalExceptionLogger注入到CachingConnectionFactory中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一节主要是讲了RabbitMq的核心ConnectionFactory的一些配置和要点，根据上面的讲述，自己配置一个ConnectionFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public ConnectionFactory rabbitMqConnection()&#123;</div><div class="line">    CachingConnectionFactory connectionFactory = new CachingConnectionFactory();</div><div class="line">    connectionFactory.setHost(&quot;47.95.205.65&quot;);</div><div class="line">    connectionFactory.setPort(5672);</div><div class="line">    connectionFactory.setConnectionNameStrategy(ConnectionFactory-&gt;&quot;MyConnection&quot;);</div><div class="line">    connectionFactory.setVirtualHost(&quot;/&quot;);</div><div class="line">    connectionFactory.setUsername(&quot;admin&quot;);</div><div class="line">    connectionFactory.setPassword(&quot;123&quot;);</div><div class="line">    connectionFactory.setChannelCacheSize(25);</div><div class="line">    //单位是毫秒</div><div class="line">    connectionFactory.setChannelCheckoutTimeout(2000);</div><div class="line">    connectionFactory.setPublisherConfirms(true);</div><div class="line">    connectionFactory.setPublisherReturns(true);</div><div class="line">    connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CHANNEL);</div><div class="line">    return connectionFactory;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-Unsafe(7)</title>
      <link href="/2018/01/22/JUC-Unsafe/"/>
      <url>/2018/01/22/JUC-Unsafe/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Unsafe"><a href="#什么是Unsafe" class="headerlink" title="什么是Unsafe"></a>什么是Unsafe</h3><p>如果你使用jdk8进行多线程的编程，在很多框架或者lock中随处可以看到compareAndSet方法和weakCompareAndSet这种方法，它实际上是加在CPU级别上的锁，所以相比于synchronized和volatile,CAS更加轻量，开始扮演着越来越重要的作用。找到它们的调用类就可以定位到Unsafe.class，这个类中绝大部分方法都是native方法，也就是使用c++编写的一些方法，jvm帮我们屏蔽掉了具体的细节。那么Unsafe的作用是什么呢?一句话可以概括。</p><blockquote><p>Java is a safe programming language and prevents programmer from doing a lot of stupid mistakes,most of which based on memory management.But, there is a way to do such mistakes intentionaly,using Unsafe.class.</p></blockquote><p>意思就是java是一个安全的编程语言，让程序员不会犯一些内存管理上的错误。但如果你执意要操作内存，那么使用Unsafe.class。但是作者并不推荐我们直接使用Unsafe，这就是Unsafe的由来，而不是说这个类的方法是非安全的。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="如果获取Unsafe"><a href="#如果获取Unsafe" class="headerlink" title="如果获取Unsafe"></a>如果获取Unsafe</h3><p>通过这个方法我们可以得到一些信息，get unsafe实例的方法会判断当前调用它的类加载器是谁，如果不是系统级的类加载器就会抛出安全异常，我们都知道parent delegete model。所以正常的调用方法是取不到Unsafe实例的，那么利用反射就可以啦，反射就是外挂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@CallerSensitive</div><div class="line">public static Unsafe getUnsafe() &#123;</div><div class="line">    Class var0 = Reflection.getCallerClass();</div><div class="line">    if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</div><div class="line">        throw new SecurityException(&quot;Unsafe&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        return theUnsafe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过反射获取Unsafe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class="line">field.setAccessible(true);</div><div class="line">Unsafe unsafe = (Unsafe) field.get(null);</div><div class="line">System.out.println(unsafe);</div></pre></td></tr></table></figure><h3 id="show-me-the-code"><a href="#show-me-the-code" class="headerlink" title="show me the code"></a>show me the code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">public class UnsafeTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(1000);</div><div class="line">        Counter counter=new SimpleCounter();</div><div class="line">        long start= System.currentTimeMillis();</div><div class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</div><div class="line">            executorService.submit(new CounterRunnable(counter,10000));</div><div class="line">        &#125;</div><div class="line">        executorService.shutdown();</div><div class="line">        executorService.awaitTermination(1, TimeUnit.HOURS);</div><div class="line">        long end = System.currentTimeMillis()-start;</div><div class="line">        System.out.println(&quot;result=&quot;+counter.getCount()+&quot;---耗时=&quot;+end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Unsafe getUnsafe()&#123;</div><div class="line">        Field field = null;</div><div class="line">        try &#123;</div><div class="line">            field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class="line">            field.setAccessible(true);</div><div class="line">            Unsafe unsafe = (Unsafe) field.get(null);</div><div class="line">            return unsafe;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    interface Counter&#123;</div><div class="line">        void increment();</div><div class="line">        long getCount();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class CounterRunnable implements Runnable&#123;</div><div class="line"></div><div class="line">        private final Counter counter;</div><div class="line">        private final int num;</div><div class="line"></div><div class="line">        public CounterRunnable(Counter counter, int num) &#123;</div><div class="line">            this.counter = counter;</div><div class="line">            this.num = num;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for(int i=0;i&lt;num;i++)&#123;</div><div class="line">                counter.increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static class  SimpleCounter implements Counter&#123;</div><div class="line">        private long i=0;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public  void increment() &#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public long getCount() &#123;</div><div class="line">            return i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个测试方法的主要意图是开启1000个线程，每个线程对一个long变量自增10000次。</p><blockquote><p>result=9745967—耗时=128   这是不加锁的情况下，可以看出答案时错的 没有意义</p><p>在increament方法上加synchronized关键字<br>result=10000000—耗时=461 答案正确，速度也可以接受，可见jdk对synchronized不断的优化还是有效果的</p><p>加锁 result=10000000—耗时=343 答案也是对的效率也高于synchronized.因为自旋锁的内部也是CAS实现的，所以也算是使用了CAS方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Lock lock = new ReentrantLock();</div><div class="line">@Override</div><div class="line">public   void increment() &#123;</div><div class="line">    lock.lock();</div><div class="line">    i++;</div><div class="line">    lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>使用AtomicLong result=0—耗时=293<br>性能介于lock和synchronized之间。</p><p>直接使用CAS方式:result=10000000—耗时=1129 性能真实出乎意料的差呀，调试了半天也没觉得代码有问题，可能和系统情况有关系。所以以后还是老老实实使用lock吧</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">static class  SimpleCounter implements Counter&#123;</div><div class="line">        private volatile long i=0;</div><div class="line">        private Unsafe unsafe;</div><div class="line">        private long offset;</div><div class="line">        SimpleCounter() throws NoSuchFieldException &#123;</div><div class="line">            unsafe = getUnsafe();</div><div class="line">            offset = unsafe.objectFieldOffset(SimpleCounter.class.getDeclaredField(&quot;i&quot;));</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public   void increment() &#123;</div><div class="line">            long current = i;</div><div class="line">            while (!unsafe.compareAndSwapLong(this,offset,current,current+1))&#123;</div><div class="line">                current = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public long getCount() &#123;</div><div class="line">            return i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>###利用Unsafe.class进行Unsafe操作</p><h4 id="青铜级"><a href="#青铜级" class="headerlink" title="青铜级"></a>青铜级</h4><p>来看这样一个Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class UnsafeFoo &#123;</div><div class="line">    static class Simple&#123;</div><div class="line">        private long l = 0;</div><div class="line">        public Simple()&#123;</div><div class="line">            this.l=1;</div><div class="line">            System.out.println(&quot;init&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public long getL() &#123;</div><div class="line">            return l;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InstantiationException &#123;</div><div class="line">        Simple s = new Simple();</div><div class="line">        System.out.println(s.getL());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码很简单，最后控制台上会输出init  1.表示类通过构造函数进行了初始化。但是依靠unsafe的allocateInstance方法，我们可以直接给一个实例分配内存，并且可以绕过它的构造函数,不仅如此，还可以得到类的信息以及类加载器的信息。<br>下面这段代码的输出结果l=0;没有init字符打印在控制台上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class UnsafeFoo &#123;</div><div class="line">    static class Simple&#123;</div><div class="line">        private long l = 0;</div><div class="line">        public Simple()&#123;</div><div class="line">            this.l=1;</div><div class="line">            System.out.println(&quot;init&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public long getL() &#123;</div><div class="line">            return l;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InstantiationException &#123;</div><div class="line">        Unsafe unsafe = getUnsafe();</div><div class="line">        Simple simple = (Simple) unsafe.allocateInstance(Simple.class);</div><div class="line">        System.out.println(simple.getL());</div><div class="line">        System.out.println(simple.getClass());</div><div class="line">        System.out.println(simple.getClass().getClassLoader());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Unsafe getUnsafe()&#123;</div><div class="line">        Field field = null;</div><div class="line">        try &#123;</div><div class="line">            field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class="line">            field.setAccessible(true);</div><div class="line">            Unsafe unsafe = (Unsafe) field.get(null);</div><div class="line">            return unsafe;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="黄金级"><a href="#黄金级" class="headerlink" title="黄金级"></a>黄金级</h4><p>在之前的代码中加入一个work方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static class Simple&#123;</div><div class="line">        private long l = 0;</div><div class="line">        public Simple()&#123;</div><div class="line">            this.l=1;</div><div class="line">            System.out.println(&quot;init&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public long getL() &#123;</div><div class="line">            return l;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public  void work()&#123;</div><div class="line">            if(l==2)&#123;</div><div class="line">                System.out.println(&quot;i am working&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>在主方法中调用,可以确定不会打印出 i am working 这句话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) throws InstantiationException, NoSuchFieldException &#123;</div><div class="line">    Unsafe unsafe = getUnsafe();</div><div class="line">    Simple simple = new Simple();</div><div class="line">    simple.work();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么如何利用unsafe方法强制修改内存中这个字段的值呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Field field = simple.getClass().getDeclaredField(&quot;l&quot;);</div><div class="line">unsafe.putInt(simple,unsafe.objectFieldOffset(field),2);</div><div class="line">simple.work();</div></pre></td></tr></table></figure><p>这样就可以看到i am working 打印在控制台上了，果然，如果别有用心的人使用了unsafe方法，会对程序的逻辑造成损坏。</p><h4 id="白金级"><a href="#白金级" class="headerlink" title="白金级"></a>白金级</h4><p>unsafe当然不止于操作类和方法，它还可以操作字节码文件，通过字节码文件调用函数。假设有一个简单的类A，把它编译成class文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    private int i=0;</div><div class="line">    public A()&#123;</div><div class="line">        this.i=1;</div><div class="line">    &#125;</div><div class="line">    public int get()&#123;</div><div class="line">        return i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在自己类中添加一个读取字节码文件的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static  byte[] readContent() throws IOException &#123;</div><div class="line">    File file = new File(&quot;/User/sc/Desktop/A.class&quot;);</div><div class="line">    FileInputStream fileInputStream = new FileInputStream(file);</div><div class="line">    byte[] bytes = new byte[(int) file.length()];</div><div class="line">    fileInputStream.read(bytes);</div><div class="line">    fileInputStream.close();</div><div class="line">    return bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主方法中读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">byte[] bytes = readContent();</div><div class="line">Class aClass = unsafe.defineClass(null, bytes, 0, bytes.length,UnsafeFoo.class.getClass().getClassLoader(),null);</div><div class="line">int  i = (int) aClass.getMethod(&quot;get&quot;).invoke(aClass.newInstance(), null);</div><div class="line">System.out.println(i);</div></pre></td></tr></table></figure><p>通过这样的方式，可以看到打印出1.也就是说unsafe解析class文件是经过了构造函数的。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot-Security认证流程</title>
      <link href="/2018/01/16/SpringBoot-Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/01/16/SpringBoot-Security%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>spring security的核心结构如图所示，实际上就是一套过滤器组成，每个过滤器都实现一种功能，用户也可以自定义过滤器加入到过滤器链中。</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180116151608847674631.png" alt="20180116151608847674631.png"></p><p><excerpt in="" index="" |="" 首页摘要=""><br> <a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="认证处理流程"><a href="#认证处理流程" class="headerlink" title="认证处理流程"></a>认证处理流程</h3><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180116151608956954220.png" alt="20180116151608956954220.png"></p><p>整个登录的流程大概可以分为这几个部分，当我们在页面上输入用户名密码点击登录后，Debug一下看看具体的流程是怎样的:</p><blockquote><p>UsernamePasswordAuthenticationFilter.class</p><p>这个类中关键的方法如下，其它都是一些简单的get、set方法。在这个方法中，首先获取到了请求的用户名和密码。</p><p>使用获取到的用户名密码构建了一个UsernamePasswordAuthenticationToken对象，这个对象其实是Authentication接口的一个实现，而Authentication<br>实际上是封装的用户信息</p><p>setDetails方法设置了一些本机的登录信息</p><p>最后返回了getAuthenticationManager对象，也就到了上图的第二步。这个对象本身并不包含验证的逻辑，他的作用是管理第三步中的Authentication<br>Provider，它是真正实现校验逻辑的一个类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;</div><div class="line">        if (this.postOnly &amp;&amp; !request.getMethod().equals(&quot;POST&quot;)) &#123;</div><div class="line">            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());</div><div class="line">        &#125; else &#123;</div><div class="line">            String username = this.obtainUsername(request);</div><div class="line">            String password = this.obtainPassword(request);</div><div class="line">            if (username == null) &#123;</div><div class="line">                username = &quot;&quot;;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (password == null) &#123;</div><div class="line">                password = &quot;&quot;;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            username = username.trim();</div><div class="line">            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);</div><div class="line">            this.setDetails(request, authRequest);</div><div class="line">            return this.getAuthenticationManager().authenticate(authRequest);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><blockquote><p>ProviderManager.class</p><p>这里就是流程图的第三步，也就是一个Authentication Provider的实现类，这里继续看这个关键方法</p><p>代码中首先对provider进行了遍历，因为不同的场景可能需要不同的认证方式，例如常见的用户名密码认证，手机验证码认证，图片认证，第三方登录等等<br>manager收到请求时会依次询问provider能不能处理这种认证，也就是provider.supports方法，manager会挑出一个provider对请求进行处理</p><p>如果支持校验，就执行校验逻辑provider.authenticate，如果不支持就跳出本次循环</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</div><div class="line">        Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</div><div class="line">        AuthenticationException lastException = null;</div><div class="line">        Authentication result = null;</div><div class="line">        boolean debug = logger.isDebugEnabled();</div><div class="line">        Iterator var6 = this.getProviders().iterator();</div><div class="line"></div><div class="line">        while(var6.hasNext()) &#123;</div><div class="line">            AuthenticationProvider provider = (AuthenticationProvider)var6.next();</div><div class="line">            if (provider.supports(toTest)) &#123;</div><div class="line">                if (debug) &#123;</div><div class="line">                    logger.debug(&quot;Authentication attempt using &quot; + provider.getClass().getName());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    result = provider.authenticate(authentication);</div><div class="line">                    if (result != null) &#123;</div><div class="line">                        this.copyDetails(authentication, result);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (AccountStatusException var11) &#123;</div><div class="line">                    this.prepareException(var11, authentication);</div><div class="line">                    throw var11;</div><div class="line">                &#125; catch (InternalAuthenticationServiceException var12) &#123;</div><div class="line">                    this.prepareException(var12, authentication);</div><div class="line">                    throw var12;</div><div class="line">                &#125; catch (AuthenticationException var13) &#123;</div><div class="line">                    lastException = var13;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (result == null &amp;&amp; this.parent != null) &#123;</div><div class="line">            try &#123;</div><div class="line">                result = this.parent.authenticate(authentication);</div><div class="line">            &#125; catch (ProviderNotFoundException var9) &#123;</div><div class="line">                ;</div><div class="line">            &#125; catch (AuthenticationException var10) &#123;</div><div class="line">                lastException = var10;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (result != null) &#123;</div><div class="line">            if (this.eraseCredentialsAfterAuthentication &amp;&amp; result instanceof CredentialsContainer) &#123;</div><div class="line">                ((CredentialsContainer)result).eraseCredentials();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.eventPublisher.publishAuthenticationSuccess(result);</div><div class="line">            return result;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (lastException == null) &#123;</div><div class="line">                lastException = new ProviderNotFoundException(this.messages.getMessage(&quot;ProviderManager.providerNotFound&quot;, new Object[]&#123;toTest.getName()&#125;, &quot;No AuthenticationProvider found for &#123;0&#125;&quot;));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.prepareException((AuthenticationException)lastException, authentication);</div><div class="line">            throw lastException;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><blockquote><p>AbstractUserDetailsAuthenticationProvider.class</p><p>方法的主要内容就是先从缓存中尝试获取user信息，并构建一个UserDetails实例，如果缓存中没有，就调用this.retrieveUser方法，也是这个方法的核心。在这里我们就可以用自己的方法控制权限的验证。可以自己新建一个类实现UserDetailsService接口，实现其中的验证逻辑。</p><p>经过验证逻辑之后会调用this.preAuthenticationChecks.check方法，也就是检查用户是否锁定，可用，过期，如果有则抛出异常</p><p>预检查之后执行this.additionalAuthenticationChecks方法，一个附加的检查，作用是检查密码是否匹配</p><p>this.postAuthenticationChecks.check后检查方法，再次检验上面的验证是否通过</p><p>所有的检查都通过之后，就认为用户的认真是成功的，这时拿用户的认证信息创建一个createSuccessAuthentication。创建一个新的Authentication对象并将信息补充完全再返回，也就是一个通过认证的Authentication。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123;</div><div class="line">        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;, &quot;Only UsernamePasswordAuthenticationToken is supported&quot;));</div><div class="line">        String username = authentication.getPrincipal() == null ? &quot;NONE_PROVIDED&quot; : authentication.getName();</div><div class="line">        boolean cacheWasUsed = true;</div><div class="line">        UserDetails user = this.userCache.getUserFromCache(username);</div><div class="line">        if (user == null) &#123;</div><div class="line">            cacheWasUsed = false;</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</div><div class="line">            &#125; catch (UsernameNotFoundException var6) &#123;</div><div class="line">                this.logger.debug(&quot;User &apos;&quot; + username + &quot;&apos; not found&quot;);</div><div class="line">                if (this.hideUserNotFoundExceptions) &#123;</div><div class="line">                    throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                throw var6;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Assert.notNull(user, &quot;retrieveUser returned null - a violation of the interface contract&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            this.preAuthenticationChecks.check(user);</div><div class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</div><div class="line">        &#125; catch (AuthenticationException var7) &#123;</div><div class="line">            if (!cacheWasUsed) &#123;</div><div class="line">                throw var7;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            cacheWasUsed = false;</div><div class="line">            user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</div><div class="line">            this.preAuthenticationChecks.check(user);</div><div class="line">            this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.postAuthenticationChecks.check(user);</div><div class="line">        if (!cacheWasUsed) &#123;</div><div class="line">            this.userCache.putUserInCache(user);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Object principalToReturn = user;</div><div class="line">        if (this.forcePrincipalAsString) &#123;</div><div class="line">            principalToReturn = user.getUsername();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return this.createSuccessAuthentication(principalToReturn, authentication, user);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h3 id="认证结果如何在多个请求中间共享"><a href="#认证结果如何在多个请求中间共享" class="headerlink" title="认证结果如何在多个请求中间共享"></a>认证结果如何在多个请求中间共享</h3><p>数据的共享当然是放到了session中，那么它是什么时间将什么东西放进了session中呢</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180116151609220621698.png" alt="20180116151609220621698.png"></p><blockquote><p>AbstractAuthenticationProcessingFilter.class</p><p>在成功进行了登录流程之后会执行successfulAuthentication方法，在这个方法中可以很明显的看到<br>SecurityContextHolder.getContext().setAuthentication(authResult)，就是把认证成功的信息放入到一个contextHolder中。SecurityContextHolder很简单，封装了Authentication对象，并重写了equals和hashcode方法保证唯一性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123;</div><div class="line">        if (this.logger.isDebugEnabled()) &#123;</div><div class="line">            this.logger.debug(&quot;Authentication success. Updating SecurityContextHolder to contain: &quot; + authResult);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        SecurityContextHolder.getContext().setAuthentication(authResult);</div><div class="line">        this.rememberMeServices.loginSuccess(request, response, authResult);</div><div class="line">        if (this.eventPublisher != null) &#123;</div><div class="line">            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.successHandler.onAuthenticationSuccess(request, response, authResult);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><blockquote><p>SecurityContextHolder.class</p><p>这个类写的不太好理解，通过init方法才发现它其实是封装了一个ThreadLocal，一个请求和响应大部分都是一个线程来做，所以当请求来的时候SecurityContext PersistenceFilter会尝试取出session，当认证完成，返回响应的时候会将认证信息写入session。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">private static void initialize() &#123;</div><div class="line">    if (!StringUtils.hasText(strategyName)) &#123;</div><div class="line">        strategyName = &quot;MODE_THREADLOCAL&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (strategyName.equals(&quot;MODE_THREADLOCAL&quot;)) &#123;</div><div class="line">        strategy = new ThreadLocalSecurityContextHolderStrategy();</div><div class="line">    &#125; else if (strategyName.equals(&quot;MODE_INHERITABLETHREADLOCAL&quot;)) &#123;</div><div class="line">        strategy = new InheritableThreadLocalSecurityContextHolderStrategy();</div><div class="line">    &#125; else if (strategyName.equals(&quot;MODE_GLOBAL&quot;)) &#123;</div><div class="line">        strategy = new GlobalSecurityContextHolderStrategy();</div><div class="line">    &#125; else &#123;</div><div class="line">        try &#123;</div><div class="line">            Class&lt;?&gt; clazz = Class.forName(strategyName);</div><div class="line">            Constructor&lt;?&gt; customStrategy = clazz.getConstructor();</div><div class="line">            strategy = (SecurityContextHolderStrategy)customStrategy.newInstance();</div><div class="line">        &#125; catch (Exception var2) &#123;</div><div class="line">            ReflectionUtils.handleReflectionException(var2);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ++initializeCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="获取认证过的用户信息"><a href="#获取认证过的用户信息" class="headerlink" title="获取认证过的用户信息"></a>获取认证过的用户信息</h3><blockquote><p>方法一<br>这种方式会返回认证的全部信息，如果只需要和用户相关的信息，可以使用方法三</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@GetMapping(&quot;/me&quot;)</div><div class="line">public Object getCurrentUser()&#123;</div><div class="line">    return SecurityContextHolder.getContext().getAuthentication();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>方法二<br>这种方式会返回认证的全部信息，如果只需要和用户相关的信息，可以使用方法三</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@GetMapping(&quot;/me&quot;)</div><div class="line">public Object getCurrentUser(Authentication authentication)&#123;</div><div class="line">    return authentication;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>方法三<br>返回用户相关信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@GetMapping(&quot;/me&quot;)</div><div class="line">public Object getCurrentUser(@AuthenticationPrincipal UserDetails userDetails)&#123;</div><div class="line">    return userDetails;</div><div class="line">&#125;</div></pre></td></tr></table></figure></the>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot-异步REST服务</title>
      <link href="/2018/01/15/SpringBoot-%E5%BC%82%E6%AD%A5REST%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/01/15/SpringBoot-%E5%BC%82%E6%AD%A5REST%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>在spring中调用请求时，经常会遇到某些业务需要长时间的计算，如果单线程来做费时费力，很快就会耗尽tomcat的连接数。所以一种思路是当http请求进来，可以另起一个线程处理业务，释放连接，当业务处理完成再将它返回，这样在处理业务的时间中，tomcat可以处理多个低时延的任务。</p><p><excerpt in="" index="" |="" 首页摘要=""><br> <a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>第一种方法就是使用Callable，模型如图:</p><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180115151600677737492.png" alt="20180115151600677737492.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@GetMapping(&quot;/order&quot;)</div><div class="line">public DeferredResult&lt;String&gt; order()&#123;</div><div class="line">    log.info(&quot;开始&quot;);</div><div class="line">    Callable&lt;String&gt; result = ()-&gt;&#123;</div><div class="line">        log.info(&quot;副线程开始&quot;);</div><div class="line">        Thread.sleep(10000 );</div><div class="line">        log.info(&quot;副线程结束&quot;);</div><div class="line">        return &quot;success&quot;;</div><div class="line">    &#125;;</div><div class="line">    log.info(&quot;结束&quot;);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a>DeferredResult</h3><p>模型如图:<br><img src="http://p1vpfd8u5.bkt.clouddn.com/20180115151601244565618.png" alt="20180115151601244565618.png"></p><p>其核心也是模拟了一个消息队列,应用2监听到消息队列的值发生变化，取出数据进行处理并将处理后的结果放回队列，应用1监听到事件完成，将信息取出返回</p><blockquote><p>Controller层</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">@Slf4j</div><div class="line">public class AsyncController &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private MockQueue mockQueue;</div><div class="line">    @Autowired</div><div class="line">    private DeferredResultHolder deferredResultHolder;</div><div class="line"></div><div class="line">        String orderNum = RandomStringUtils.randomNumeric(8);</div><div class="line">        mockQueue.setPlaceOrder(orderNum);</div><div class="line">        DeferredResult deferredResult =new DeferredResult();</div><div class="line">        deferredResultHolder.getMap().put(orderNum,deferredResult);</div><div class="line">        log.info(&quot;结束&quot;);</div><div class="line">        return deferredResult;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>模拟队列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">@Slf4j</div><div class="line">public class MockQueue &#123;</div><div class="line">    private String placeOrder;</div><div class="line">    private String completeOrder;</div><div class="line"></div><div class="line">    public String getCompleteOrder() &#123;</div><div class="line">        return completeOrder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getPlaceOrder() &#123;</div><div class="line">        return placeOrder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCompleteOrder(String completeOrder) &#123;</div><div class="line">        this.completeOrder = completeOrder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPlaceOrder(String placeOrder) &#123;</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            log.info(&quot;接到下单请求&quot;+placeOrder);</div><div class="line">            try &#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            this.completeOrder = placeOrder;</div><div class="line">            log.info(&quot;处理完成&quot;+placeOrder);</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class DeferredResultHolder &#123;</div><div class="line">    private Map&lt;String,DeferredResult&gt; map = new HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    public Map&lt;String, DeferredResult&gt; getMap() &#123;</div><div class="line">        return map;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMap(Map&lt;String, DeferredResult&gt; map) &#123;</div><div class="line">        this.map = map;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>监听队列</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">@Slf4j</div><div class="line">public class QueueListener implements ApplicationListener&lt;ContextRefreshedEvent&gt;&#123;</div><div class="line">    @Autowired</div><div class="line">    private MockQueue mockQueue;</div><div class="line">    @Autowired</div><div class="line">    private DeferredResultHolder resultHolder;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) &#123;</div><div class="line">        new Thread(()-&gt;&#123;</div><div class="line">            while (true)&#123;</div><div class="line">                if(StringUtils.isNotBlank(mockQueue.getCompleteOrder()))&#123;</div><div class="line">                    String orderNo = mockQueue.getCompleteOrder();</div><div class="line">                    log.info(&quot;返回订单处理结果&quot;+orderNo);</div><div class="line">                    resultHolder.getMap().get(orderNo).setResult(&quot;order success&quot;);</div><div class="line">                    mockQueue.setCompleteOrder(null);</div><div class="line">                &#125;else &#123;</div><div class="line">                    try &#123;</div><div class="line">                        Thread.sleep(100);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>同样是订单处理的场景，可以使用的消息队列有很多种，比如rabbitmq或者阿里的rocketmq。rabbitmq的应用非常广泛，rocketmq是阿里开源的专门用来处理电商场景的消息队列。学会了把这两种场景再补上。</p></the>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web容器对比</title>
      <link href="/2018/01/08/web%E5%AE%B9%E5%99%A8%E5%AF%B9%E6%AF%94/"/>
      <url>/2018/01/08/web%E5%AE%B9%E5%99%A8%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>公司里统一使用的是jetty，自己平时写项目都习惯性用tomcat。大概比较一下两个容器。</p><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180105151512096169138.png" alt="tomcat结构"></p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h4 id="接受请求"><a href="#接受请求" class="headerlink" title="接受请求"></a>接受请求</h4><ol><li>BIO: blocking IO</li><li>NIO: non blocking IO</li><li>APR: 操作系统级别解决异步IO，如果应用需要处理高并发的请求，可以配置为apr模式</li></ol><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ol><li>tomcat默认使用BIO的connector协议,并发达到几百会有瓶颈。可以通过修改protocol设置为org.apache.coyote.http11.Http11NioProtocol启动NIO。</li><li>useURIValidation=false关闭URL检查</li><li>enableLookUps=false消除DNS查询影响</li><li>compression=on采取资源压缩</li><li>因为tomcat运行在jvm上，所以可以通过优化jvm提高性能。tomcat默认内存128MB。可以修改Catalina.sh JAVA_OPTS参数，指定-Xms -Xmx，设置初始化大小和最大内存，减少频繁伸缩带来的消耗</li></ol><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p><img src="http://p1vpfd8u5.bkt.clouddn.com/20180108151537303260693.png" alt="20180108151537303260693.png"></p><p>可以看出jetty结构相比于tomcat要简单了很多，它只有一个数据模型，那就是handler。可以根据规则添加hanlder作为jetty的启动组件。与tomcat相同，每个组件都有一个观察者(LifyCycle接口)，当start、fail、stop事件被触发，listener将会被调用。</p><h4 id="接受请求-1"><a href="#接受请求-1" class="headerlink" title="接受请求"></a>接受请求</h4><ol><li>HTTP协议<ul><li>BIO</li><li>NIO</li></ul></li><li>AJP协议:假设在jboss服务器前加入了nginx服务器，那么nginx会解析http请求，jboss只需要处理nginx处理过的数据包，也就是ajp工作。所以处理ajp请求要快于http请求</li></ol><h3 id="tomcat与jetty比较"><a href="#tomcat与jetty比较" class="headerlink" title="tomcat与jetty比较"></a>tomcat与jetty比较</h3><p>jetty在架构上，核心就是handler。Handler的设计实际上是一个责任链的模式，对于组件生命周期的监控使用了观察者模式。tomcat的结构从server-&gt;service—&gt;container-&gt;engine-&gt;host-&gt;context-&gt;wrapper，是一种分层的设计，非常复杂但是也更加稳重。</p><p>对于J2ee规范，tomcat支持的更广泛，jetty更加轻量响应更快。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot-Data-Jpa之高级话题(3)</title>
      <link href="/2018/01/01/SpringBoot-Data-Jpa%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
      <url>/2018/01/01/SpringBoot-Data-Jpa%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="JPA的一些坑"><a href="#JPA的一些坑" class="headerlink" title="JPA的一些坑"></a>JPA的一些坑</h3><p>如果我们的Repository继承自JpaRepository，那么我们如果执行插入或保存代码的时候会出现异常,比如下面一个方法是会执行失败的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test8()&#123;</div><div class="line">    Book book = new Book();</div><div class="line">    book.setName(&quot;heng&quot;);</div><div class="line">    book.setUpdateDate(new Date());</div><div class="line">    book.setCreateDate(new Date());</div><div class="line">    bookRepository.save(book);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Connection is read-only. Queries leading to data modification are not allowed</p></blockquote><p>错误提示是ReadOnly，也就是说我们不能修改数据，那么如何解决这个问题呢，很简单。<strong><em><em>只需要在测试类或者方法上加@Transactional注解就可以</em></em></strong>。<br>那么这个问题ReadOnly是从哪里来的呢，我们继承的JpaRepository只是一个接口，那么找问题就要去找它的实现类，可以找到SimpleJpaRepository。在类注解上我们就找到了问题所在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Transactional(</div><div class="line">    readOnly = true</div><div class="line">)</div></pre></td></tr></table></figure><p>这里事务标注为只读，所以我们执行修改操作的时候要加事务注解对它进行覆盖。如果你对Repository层写的测试代码，那么你会发现，虽然Junit测试显示成功，sql也打印在了控制台，但是数据库并没有插入或修改这条数据。因为springboot对repository层默认进行了回滚，如果你使用Service层包装了Repository层，对Service写Junit测试，就不会出现事务回滚的情况，要解决这种回滚的情况，需要再添加一个注解:</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">@Transactional</div><div class="line">@Rollback(false)</div><div class="line">public void test8()&#123;</div><div class="line">    Book book = new Book();</div><div class="line">    book.setName(&quot;heng&quot;);</div><div class="line">    book.setUpdateDate(new Date());</div><div class="line">    book.setCreateDate(new Date());</div><div class="line">    bookRepository.save(book);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在测试代码就不会有什么问题了，如果你只想观察测试用例的sql语句，那么就不需要加RollBack这个注解了。</p><h3 id="自定义Repository"><a href="#自定义Repository" class="headerlink" title="自定义Repository"></a>自定义Repository</h3><p>如果我们想对Repository的方法做一些定制，Jpa当然也是支持的。这里简单演示一下在save方法前打印一句话。</p><p>第一步就是集成SimpleJpaRepository这个类，这个类是JpaRepository的实现类。实现一个构造方法，这里我们重写一个save方法，save之前打印这个保存实体的名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class MyRepository&lt;T&gt; extends SimpleJpaRepository&lt;T,Long&gt;&#123;</div><div class="line">    public MyRepository(JpaEntityInformation&lt;T, ?&gt; entityInformation, EntityManager entityManager) &#123;</div><div class="line">        super(entityInformation, entityManager);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public &lt;S extends T&gt; S save(S entity) &#123;</div><div class="line">        System.out.println(&quot;保存了:&quot;+entity.getClass().getSimpleName());</div><div class="line">        return super.save(entity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二步:在启动类上指定要使用的Jpa实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@EnableJpaRepositories(repositoryBaseClass = MyRepository.class)</div><div class="line">public class DemoApplication &#123;</div><div class="line">public static void main(String[] args) &#123;</div><div class="line">SpringApplication.run(DemoApplication.class, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这时当我们再调用测试方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">@Transactional</div><div class="line">public void test8()&#123;</div><div class="line">    Book book = new Book();</div><div class="line">    book.setName(&quot;heng&quot;);</div><div class="line">    book.setUpdateDate(new Date());</div><div class="line">    book.setCreateDate(new Date());</div><div class="line">    bookRepository.save(book);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就可以看到输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">保存了:Book</div><div class="line">Hibernate:</div><div class="line">    insert</div><div class="line">    into</div><div class="line">        sc_book</div><div class="line">        (sc_create_date, sc_update_date, sc_category_sc_id, sc_name)</div><div class="line">    values</div><div class="line">        (?, ?, ?, ?)</div></pre></td></tr></table></figure><h3 id="持久化上下文"><a href="#持久化上下文" class="headerlink" title="持久化上下文"></a>持久化上下文</h3><p>先来看这么一个场景</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">@Transactional</div><div class="line">public void test9()&#123;</div><div class="line">    Book one = bookRepository.findOne(2L);</div><div class="line">    one.setName(&quot;python&quot;);</div><div class="line">    bookRepository.save(one);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_0_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_0_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_0_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_0_,</div><div class="line">        book0_.sc_name as sc_name4_2_0_,</div><div class="line">        category1_.sc_id as sc_id1_4_1_,</div><div class="line">        category1_.sc_create_date as sc_creat2_4_1_,</div><div class="line">        category1_.sc_update_date as sc_updat3_4_1_,</div><div class="line">        category1_.sc_address as sc_addre4_4_1_,</div><div class="line">        category1_.sc_area as sc_area5_4_1_,</div><div class="line">        category1_.sc_city as sc_city6_4_1_,</div><div class="line">        category1_.sc_province as sc_provi7_4_1_,</div><div class="line">        category1_.sc_zip_code as sc_zip_c8_4_1_,</div><div class="line">        category1_.sc_age as sc_age9_4_1_,</div><div class="line">        category1_.sc_birth_day as sc_birt10_4_1_,</div><div class="line">        category1_.sc_gender as sc_gend11_4_1_,</div><div class="line">        category1_.sc_name as sc_name12_4_1_</div><div class="line">    from</div><div class="line">        sc_book book0_</div><div class="line">    left outer join</div><div class="line">        sc_category category1_</div><div class="line">            on book0_.sc_category_sc_id=category1_.sc_id</div><div class="line">    where</div><div class="line">        book0_.sc_id=?</div><div class="line">保存了:Book</div></pre></td></tr></table></figure><p>结果很奇怪，只有select的sql语句执行了，然后显示save方法也执行了，但是没有执行update的sql语句。这就是持久化上下文在起作用。先给出持久化上下文的特点再进行验证。</p><ul><li>持久化上下文的生命周期与事务一致</li><li>持久化上下文提供自动脏检查</li><li>持久化下上文是一级缓存</li></ul><p>解释一下持久化上下文对于编程人员来说其实是不可见的，我们可以把它想象成一个map。对于第一条，当事务开始的时候会创建一个map，在事务中的所有操作都会写入这个map中，事务结束map就会销毁。自动脏检查是说如果持久化上下文发现了自己map中的数据有修改，就会修改这些数据，在事务完成后提交，如果没有修改，就不会提交。对于缓存机制，我们可以通过代码来进行验证。</p><p>其实前两点就可以解释刚才代码中出现的现象，由于我们的Transactional注解会回滚掉，所以持久化上下文就不会执行update语句。如果想让它执行update那么我们只需要让jpa提交这个事务，而不是回滚这个事务就可以了。最简单的做法就是在方法上添加@Rollback(false)这个注解就可以了。当然要修改一下你要保存的数据，不要和查出来的数据一样，否则脏检查发现没有修改，也就不会执行update操作了。接着我们验证缓存机制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    @Test</div><div class="line">    @Transactional</div><div class="line">    @Rollback(false)</div><div class="line">    public void test9()&#123;</div><div class="line">        Book one = bookRepository.findOne(2L);</div><div class="line">        Book one1 = bookRepository.findOne(2L);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出sql:</div><div class="line"></div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_0_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_0_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_0_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_0_,</div><div class="line">        book0_.sc_name as sc_name4_2_0_,</div><div class="line">        category1_.sc_id as sc_id1_4_1_,</div><div class="line">        category1_.sc_create_date as sc_creat2_4_1_,</div><div class="line">        category1_.sc_update_date as sc_updat3_4_1_,</div><div class="line">        category1_.sc_address as sc_addre4_4_1_,</div><div class="line">        category1_.sc_area as sc_area5_4_1_,</div><div class="line">        category1_.sc_city as sc_city6_4_1_,</div><div class="line">        category1_.sc_province as sc_provi7_4_1_,</div><div class="line">        category1_.sc_zip_code as sc_zip_c8_4_1_,</div><div class="line">        category1_.sc_age as sc_age9_4_1_,</div><div class="line">        category1_.sc_birth_day as sc_birt10_4_1_,</div><div class="line">        category1_.sc_gender as sc_gend11_4_1_,</div><div class="line">        category1_.sc_name as sc_name12_4_1_</div><div class="line">    from</div><div class="line">        sc_book book0_</div><div class="line">    left outer join</div><div class="line">        sc_category category1_</div><div class="line">            on book0_.sc_category_sc_id=category1_.sc_id</div><div class="line">    where</div><div class="line">        book0_.sc_id=?</div></pre></td></tr></table></figure><p>可以看到我们执行了两次查询，同一个数据的操作，结果只执行了一次查询sql。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">    @Test</div><div class="line">    @Transactional</div><div class="line">    @Rollback(false)</div><div class="line">    public void test9()&#123;</div><div class="line">        bookRepository.findAll();</div><div class="line">        bookRepository.findAll();</div><div class="line">    &#125;</div><div class="line">输出sql:</div><div class="line"></div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_,</div><div class="line">        book0_.sc_name as sc_name4_2_</div><div class="line">    from</div><div class="line">        sc_book book0_</div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_,</div><div class="line">        book0_.sc_name as sc_name4_2_</div><div class="line">    from</div><div class="line">        sc_book book0_</div></pre></td></tr></table></figure><p>对于findall查询，执行了两次sql</p><p>可以得到的结论是，持久化上下文对于条件查询语句会做缓存，相同的查询会走缓存，而不是去连接数据库。对于findAll这种无限制条件的查询则不会缓存。</p><p>我们在说JpaRepository的时候发现它有flush和saveAndFlush这两个方法，其实这两个方法的作用就是立刻将持久化上下文与数据库进行同步，而不等待事务的提交。验证方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">@Transactional</div><div class="line">public void test9()&#123;</div><div class="line">    Book one = bookRepository.findOne(2L);</div><div class="line">    one.setName(&quot;python123&quot;);</div><div class="line">    bookRepository.saveAndFlush(one);</div><div class="line">    Book one1 = bookRepository.findOne(2L);</div><div class="line">    System.out.println(one1.getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过saveAndflush方法，数据库的数据立即就发生了改变，由于上下文中记录了数据的改变，所以第二次查询不需要经过数据库，直接可以从上下文中获取。因此第二次查询没有打印出sql语句，结果输出python123</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_0_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_0_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_0_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_0_,</div><div class="line">        book0_.sc_name as sc_name4_2_0_,</div><div class="line">        category1_.sc_id as sc_id1_4_1_,</div><div class="line">        category1_.sc_create_date as sc_creat2_4_1_,</div><div class="line">        category1_.sc_update_date as sc_updat3_4_1_,</div><div class="line">        category1_.sc_address as sc_addre4_4_1_,</div><div class="line">        category1_.sc_area as sc_area5_4_1_,</div><div class="line">        category1_.sc_city as sc_city6_4_1_,</div><div class="line">        category1_.sc_province as sc_provi7_4_1_,</div><div class="line">        category1_.sc_zip_code as sc_zip_c8_4_1_,</div><div class="line">        category1_.sc_age as sc_age9_4_1_,</div><div class="line">        category1_.sc_birth_day as sc_birt10_4_1_,</div><div class="line">        category1_.sc_gender as sc_gend11_4_1_,</div><div class="line">        category1_.sc_name as sc_name12_4_1_</div><div class="line">    from</div><div class="line">        sc_book book0_</div><div class="line">    left outer join</div><div class="line">        sc_category category1_</div><div class="line">            on book0_.sc_category_sc_id=category1_.sc_id</div><div class="line">    where</div><div class="line">        book0_.sc_id=?</div><div class="line">保存了:Book</div><div class="line">Hibernate:</div><div class="line">    update</div><div class="line">        sc_book</div><div class="line">    set</div><div class="line">        sc_create_date=?,</div><div class="line">        sc_update_date=?,</div><div class="line">        sc_category_sc_id=?,</div><div class="line">        sc_name=?</div><div class="line">    where</div><div class="line">        sc_id=?</div><div class="line">python123</div></pre></td></tr></table></figure><h3 id="抓取策略"><a href="#抓取策略" class="headerlink" title="抓取策略"></a>抓取策略</h3><p>在上面的select语句中我们可以发现一个问题，jpa会默认为我们抓取所有相关的表的数据，比如这里外联了category这张表，可以想象一下如果我们这张表关联了多张表的情况下再去默认外联很可能影响我们的查询效率，而大多数情况下我们可能不需要外联，那么这里就涉及到抓取策略。</p><p>抓取策略的配置在Book类上，@ManyToOne注解上进行配置，默认为EAGER类型，也就是不管需要不需要，我都查出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line">@Data</div><div class="line">public class Book extends CommonProperty &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @ManyToOne(fetch = FetchType.LAZY)</div><div class="line">    private Category category;</div><div class="line"></div><div class="line">    @OneToMany(mappedBy = &quot;book&quot;)</div><div class="line">    private List&lt;BookAuthor&gt; authors;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>改为lazy模式后查看sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">select</div><div class="line">    book0_.sc_id as sc_id1_2_0_,</div><div class="line">    book0_.sc_create_date as sc_creat2_2_0_,</div><div class="line">    book0_.sc_update_date as sc_updat3_2_0_,</div><div class="line">    book0_.sc_category_sc_id as sc_categ5_2_0_,</div><div class="line">    book0_.sc_name as sc_name4_2_0_</div><div class="line">from</div><div class="line">    sc_book book0_</div><div class="line">where</div><div class="line">    book0_.sc_id=?</div></pre></td></tr></table></figure><p>可以看到当我们不需要类别信息的时候不会去外联这张category表。</p><p>当我们调用jpa默认提供的方法时会是这样一种效果，那么我们自定义的接口方法时什么样的呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Component</div><div class="line">public interface BookRepository extends JpaRepository&lt;Book,Long&gt; &#123;</div><div class="line">    Book findByName(String name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void test10()&#123;</div><div class="line">        Book python123 = bookRepository.findByName(&quot;python1&quot;);</div><div class="line">        System.out.println(python123.getCategory().getName());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">输出结果:</div><div class="line"></div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_,</div><div class="line">        book0_.sc_name as sc_name4_2_</div><div class="line">    from</div><div class="line">        sc_book book0_</div><div class="line">    where</div><div class="line">        book0_.sc_name=?</div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        category0_.sc_id as sc_id1_4_0_,</div><div class="line">        category0_.sc_create_date as sc_creat2_4_0_,</div><div class="line">        category0_.sc_update_date as sc_updat3_4_0_,</div><div class="line">        category0_.sc_address as sc_addre4_4_0_,</div><div class="line">        category0_.sc_area as sc_area5_4_0_,</div><div class="line">        category0_.sc_city as sc_city6_4_0_,</div><div class="line">        category0_.sc_province as sc_provi7_4_0_,</div><div class="line">        category0_.sc_zip_code as sc_zip_c8_4_0_,</div><div class="line">        category0_.sc_age as sc_age9_4_0_,</div><div class="line">        category0_.sc_birth_day as sc_birt10_4_0_,</div><div class="line">        category0_.sc_gender as sc_gend11_4_0_,</div><div class="line">        category0_.sc_name as sc_name12_4_0_</div><div class="line">    from</div><div class="line">        sc_category category0_</div><div class="line">    where</div><div class="line">        category0_.sc_id=?</div><div class="line">技术</div></pre></td></tr></table></figure><p>可以看到在默认的Eager模式下，jpa对于我们自定义的方法并没有做外联操作，而是执行了两次select操作。如果选择Lazy模式则会直接抛出异常no session。所以说在这里控制抓取策略是没有用的。这才是查询一条category的情况，实际环境中我们可能查询100条，就会有101句select语句，那么对性能就是一种极大的影响。那么就要想办法解决这种情况。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Query(&quot;from Book b left join b.category where b.name = ?1&quot;)</div><div class="line">Book findByName(String name);</div></pre></td></tr></table></figure><p>在自定义的方法上，明确指定查询要外联category表</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@EntityGraph(attributePaths = &#123;&quot;category&quot;&#125; )</div><div class="line">Book findByName(String name);</div></pre></td></tr></table></figure><p>在这个注解中，我们可以传入一个String 数组，也就是说，如果这个Book表关联了多个表，那么这里就可以填入想要外联的表在Book类中的属性名称,就会在查询的时候执行外联操作，而不是多个select,如图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_0_,</div><div class="line">        category1_.sc_id as sc_id1_4_1_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_0_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_0_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_0_,</div><div class="line">        book0_.sc_name as sc_name4_2_0_,</div><div class="line">        category1_.sc_create_date as sc_creat2_4_1_,</div><div class="line">        category1_.sc_update_date as sc_updat3_4_1_,</div><div class="line">        category1_.sc_address as sc_addre4_4_1_,</div><div class="line">        category1_.sc_area as sc_area5_4_1_,</div><div class="line">        category1_.sc_city as sc_city6_4_1_,</div><div class="line">        category1_.sc_province as sc_provi7_4_1_,</div><div class="line">        category1_.sc_zip_code as sc_zip_c8_4_1_,</div><div class="line">        category1_.sc_age as sc_age9_4_1_,</div><div class="line">        category1_.sc_birth_day as sc_birt10_4_1_,</div><div class="line">        category1_.sc_gender as sc_gend11_4_1_,</div><div class="line">        category1_.sc_name as sc_name12_4_1_</div><div class="line">    from</div><div class="line">        sc_book book0_</div><div class="line">    left outer join</div><div class="line">        sc_category category1_</div><div class="line">            on book0_.sc_category_sc_id=category1_.sc_id</div><div class="line">    where</div><div class="line">        book0_.sc_name=?</div></pre></td></tr></table></figure><p>这个注解似乎已经完美解决了我们的问题，但是在真实场景中，我们可能要写10个查询方法根据不同的条件，那么我们每个方法都要加上这个注解，其实是很麻烦的事情，那么有没有方法，让我们只需要修改一处就行了呢，当然可以。</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line">@Data</div><div class="line">@NamedEntityGraph(name = &quot;Book.fetch.category_author&quot;,</div><div class="line">attributeNodes = &#123;</div><div class="line">        @NamedAttributeNode(&quot;category&quot;),</div><div class="line">        @NamedAttributeNode(&quot;authors&quot;)</div><div class="line">&#125;)</div><div class="line">public class Book extends CommonProperty &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @ManyToOne</div><div class="line">    private Category category;</div><div class="line"></div><div class="line">    @OneToMany(mappedBy = &quot;book&quot;)</div><div class="line">    private List&lt;BookAuthor&gt; authors;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">    @EntityGraph(&quot;Book.fetch.category_author&quot;)</div><div class="line">    Book findByName(String name);</div></pre></td></tr></table></figure><p>我们只需要在Book实体类中添加一个NamedEntityGraph注解，并指定一个名字，名字可以任意取，并声明要抓取的策略。然后在方法上只需要声明这个Graph的名称即可。如果你有多个要抓取的策略，那么可以使用@NamedEntityGraphs注解，嵌套@NamedEntityGraph就可以了。</p><h3 id="继承策略"><a href="#继承策略" class="headerlink" title="继承策略"></a>继承策略</h3><h4 id="single-table"><a href="#single-table" class="headerlink" title="single table"></a>single table</h4><p>在之前的实体类中，我们提取了Id、createTime、updateTime这些公共属性，并让实体表继承了这些属性，那么每个表就会增加响应的列。现在考虑如果我们新增了电子书和实体书两个类，两种书同属于Book，所以我们可以考虑让这两种书继承Book类，并且我们需要存储两种书的数据，那么这时候我们就需要在两种书的实体类上添加@Entity注解，我们观察一下数据库会有什么变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@Data</div><div class="line">@Entity</div><div class="line">public class PrintBook extends Book &#123;</div><div class="line">        private String press;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Entity</div><div class="line">@Data</div><div class="line">public class EBook extends Book &#123;</div><div class="line">    private String webSite;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>新建两个实体类，并运行项目</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fn14k7cr5nj30ek02374i.jpg" alt=""></p><p>可以发现数据库中并没有新增两个表，而是增加了三个字段，两个字段是我们自己定义的，并且默认都是allow null的属性。dtype则是自动生成的,不可为null。也就是说现在我们数据库中的book必须制定是Ebook还是PrintBook，如果数据库之前存了数据，现在执行查询是会报错的。要么对该列进行填充，要么删除所有数据。我们先清空数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">    @Test</div><div class="line">    @Transactional</div><div class="line">    public void test11()&#123;</div><div class="line">        EBook eBook = new EBook();</div><div class="line">        eBook.setWebSite(&quot;123&quot;);</div><div class="line">        eBook.setName(&quot;西游记&quot;);</div><div class="line">        bookRepository.saveAndFlush(eBook);</div><div class="line">    &#125;</div><div class="line">输出结果:</div><div class="line">保存了:EBook</div><div class="line">Hibernate:</div><div class="line">    insert</div><div class="line">    into</div><div class="line">        sc_book</div><div class="line">        (sc_create_date, sc_update_date, sc_category_sc_id, sc_name, sc_web_site, dtype)</div><div class="line">    values</div><div class="line">        (?, ?, ?, ?, ?, &apos;EBook&apos;)</div><div class="line"></div><div class="line"></div><div class="line">    @Test</div><div class="line">    @Transactional</div><div class="line">    public void test12()&#123;</div><div class="line">        PrintBook printBook = new PrintBook();</div><div class="line">        printBook.setName(&quot;水浒传&quot;);</div><div class="line">        printBook.setPress(&quot;北京出版社&quot;);</div><div class="line">        bookRepository.saveAndFlush(printBook);</div><div class="line">    &#125;</div><div class="line">输出结果:</div><div class="line">保存了:PrintBook</div><div class="line">Hibernate:</div><div class="line">    insert</div><div class="line">    into</div><div class="line">        sc_book</div><div class="line">        (sc_create_date, sc_update_date, sc_category_sc_id, sc_name, sc_press, dtype)</div><div class="line">    values</div><div class="line">        (?, ?, ?, ?, ?, &apos;PrintBook&apos;)</div></pre></td></tr></table></figure><p>可以看出jpa根据我们声明的类型，会自动添加dtype属性到数据库。那么查询操作也是类似的道理，如果findAll则会查出来两种类型，如果声明了一种返回类型，则会自动添加dtype条件进行查询。</p><p>有一点要注意的是，子类中的属性不能设置为not null，因为其他子类在进行插入操作的时候不会插入这个子类的属性，设置为not null就会影响其他子类的插入操作。</p><p>####joined<br>上面通过dtype的表形式只是jpa种默认的一种继承策略，我们可以修改继承策略来建立不同的表结构。需要在父类上添加注解</p><p>@Inheritance(strategy = InheritanceType.JOINED)</p><p>共有三种继承策略, SINGLE_TABLE为默认策略，那么我们尝试一下其他两种策略，首先要清空数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SINGLE_TABLE,</div><div class="line">TABLE_PER_CLASS,</div><div class="line">JOINED;</div></pre></td></tr></table></figure><p>使用这种继承策略，会建立两个额外的表，也就是Ebook表和PrintBook表，每次插入数据的时候都会向两个表中执行两个insert语句，select语句会使用join外联，这也符合我们对Joined策略的理解。Ebook和PrintBook的表结构也是类似的，除了自身特有的属性，还有一个外键和Book表相关联。</p><h4 id="TABLE-PER-CLASS"><a href="#TABLE-PER-CLASS" class="headerlink" title="TABLE_PER_CLASS"></a>TABLE_PER_CLASS</h4><p>从字面上很难理解是什么意思，清空数据库后启动项目，发现报错了。错误的内容是说当我们使用这种策略的时候主键不允许使用自增的形式。为什么呢，因为对于前两种方式，主键都是存储在Book表中，也就是说只有一个主键。而使用这种方式建立的表，每个表都有一个主键，它会把数据聚合在一起，如果使用自增的策略，可能导致多个表有相同的主键，所以会报错。那么这时候，我们要使用其他生成策略:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Id</div><div class="line">@GeneratedValue(generator = &quot;sequenceGenerator&quot;)</div><div class="line">@GenericGenerator(name=&quot;sequenceGenerator&quot;,strategy = &quot;org.hibernate.id.enhanced.SequenceStyleGenerator&quot;,</div><div class="line">parameters = &#123;</div><div class="line">        @Parameter(name = SequenceStyleGenerator.SEQUENCE_PARAM,value = &quot;ID_SEQUENCE&quot;),</div><div class="line">        @Parameter(name = SequenceStyleGenerator.INITIAL_PARAM,value = &quot;1000&quot;),</div><div class="line">        @Parameter(name = SequenceStyleGenerator.INCREMENT_PARAM,value = &quot;1&quot;),</div><div class="line">        @Parameter(name = SequenceStyleGenerator.OPT_PARAM,value = &quot;pooled&quot;)</div><div class="line">&#125;)</div><div class="line">private Long id;</div></pre></td></tr></table></figure><p>这里我们选择一种Hibernate的序列化生成Id的策略，并进行了一些配置,同时这里也显示出了我们抽取公共属性的好处，只需要修改一处代码。 观察生成的表结构:</p><p>同样是生成了三张表，但是Ebook和PrintBook表和JOINED策略生成的表结构有所差别</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fn15ox9hr6j30ge03zzkr.jpg" alt=""></p><p>这张表包含了Book表中的所有属性，而不是通过外键关联主表，执行测试用例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">    @Test</div><div class="line">    @Transactional</div><div class="line">    @Rollback(false)</div><div class="line">    public void test13()&#123;</div><div class="line">        EBook eBook = new EBook();</div><div class="line">        eBook.setWebSite(&quot;www.baidu.com&quot;);</div><div class="line">        eBook.setName(&quot;python&quot;);</div><div class="line">        bookRepository.save(eBook);</div><div class="line"></div><div class="line">        PrintBook printBook =new PrintBook();</div><div class="line">        printBook.setPress(&quot;工业出版社&quot;);</div><div class="line">        printBook.setName(&quot;java&quot;);</div><div class="line">        bookRepository.save(printBook);</div><div class="line">    &#125;</div><div class="line">输出:</div><div class="line"></div><div class="line">保存了:EBook</div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        next_val as id_val</div><div class="line">    from</div><div class="line">        id_sequence for update</div><div class="line"></div><div class="line">Hibernate:</div><div class="line">    update</div><div class="line">        id_sequence</div><div class="line">    set</div><div class="line">        next_val= ?</div><div class="line">    where</div><div class="line">        next_val=?</div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        next_val as id_val</div><div class="line">    from</div><div class="line">        id_sequence for update</div><div class="line"></div><div class="line">Hibernate:</div><div class="line">    update</div><div class="line">        id_sequence</div><div class="line">    set</div><div class="line">        next_val= ?</div><div class="line">    where</div><div class="line">        next_val=?</div><div class="line">保存了:PrintBook</div><div class="line">Hibernate:</div><div class="line">    insert</div><div class="line">    into</div><div class="line">        sc_ebook</div><div class="line">        (sc_create_date, sc_update_date, sc_category_sc_id, sc_name, sc_web_site, sc_id)</div><div class="line">    values</div><div class="line">        (?, ?, ?, ?, ?, ?)</div><div class="line">Hibernate:</div><div class="line">    insert</div><div class="line">    into</div><div class="line">        sc_print_book</div><div class="line">        (sc_create_date, sc_update_date, sc_category_sc_id, sc_name, sc_press, sc_id)</div><div class="line">    values</div><div class="line">        (?, ?, ?, ?, ?, ?)</div></pre></td></tr></table></figure><p>可以看到除了id的操作之外，jpa向两种表分别插入了数据，Book表不会插入任何数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">    @Test</div><div class="line">    public void test14()&#123;</div><div class="line">        bookRepository.findAll();</div><div class="line">    &#125;</div><div class="line">输出结果:</div><div class="line">Hibernate:</div><div class="line">    select</div><div class="line">        book0_.sc_id as sc_id1_2_,</div><div class="line">        book0_.sc_create_date as sc_creat2_2_,</div><div class="line">        book0_.sc_update_date as sc_updat3_2_,</div><div class="line">        book0_.sc_category_sc_id as sc_categ5_2_,</div><div class="line">        book0_.sc_name as sc_name4_2_,</div><div class="line">        book0_.sc_web_site as sc_web_s1_6_,</div><div class="line">        book0_.sc_press as sc_press1_7_,</div><div class="line">        book0_.clazz_ as clazz_</div><div class="line">    from</div><div class="line">        ( select</div><div class="line">            sc_id,</div><div class="line">            sc_create_date,</div><div class="line">            sc_update_date,</div><div class="line">            sc_name,</div><div class="line">            sc_category_sc_id,</div><div class="line">            null as sc_web_site,</div><div class="line">            null as sc_press,</div><div class="line">            0 as clazz_</div><div class="line">        from</div><div class="line">            sc_book</div><div class="line">        union</div><div class="line">        select</div><div class="line">            sc_id,</div><div class="line">            sc_create_date,</div><div class="line">            sc_update_date,</div><div class="line">            sc_name,</div><div class="line">            sc_category_sc_id,</div><div class="line">            sc_web_site,</div><div class="line">            null as sc_press,</div><div class="line">            1 as clazz_</div><div class="line">        from</div><div class="line">            sc_ebook</div><div class="line">        union</div><div class="line">        select</div><div class="line">            sc_id,</div><div class="line">            sc_create_date,</div><div class="line">            sc_update_date,</div><div class="line">            sc_name,</div><div class="line">            sc_category_sc_id,</div><div class="line">            null as sc_web_site,</div><div class="line">            sc_press,</div><div class="line">            2 as clazz_</div><div class="line">        from</div><div class="line">            sc_print_book</div><div class="line">    ) book0_</div></pre></td></tr></table></figure><p>可以看到，对于findAll查询，执行了union查询方式。对于声明类型的查询，则会直接去查询对应类型的表。这种继承策略实际上和不使用继承策略效果是相同的，适用于子类与父类差异比较大的场合，因为使用这种策略查询的效率非常差。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot-Data JPA之Repository(2)</title>
      <link href="/2017/12/31/SpringBoot-Data-JPA%E4%B9%8BRepository-2/"/>
      <url>/2017/12/31/SpringBoot-Data-JPA%E4%B9%8BRepository-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><p>首先进行一下配置，让我们更方便的观察sql语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">spring.jpa.properties.hibernate.format_sql = true  //格式化sql</div><div class="line"></div><div class="line">spring.jpa.show-sql=true  //显示sql</div></pre></td></tr></table></figure><p>我们先实现一个简单的查找，通过继承Repository接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public interface BookRepository extends Repository&lt;Book,Long&gt;&#123;</div><div class="line">    /**</div><div class="line">     * 根据名字查找</div><div class="line">     */</div><div class="line">    List&lt;Book&gt; findByName(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>测试代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@RunWith(SpringRunner.class)</div><div class="line">@SpringBootTest</div><div class="line">public class BookRepositoryTest &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private BookRepository bookRepository;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void test1()&#123;</div><div class="line">        System.out.println(bookRepository.getClass().getName());</div><div class="line">        bookRepository.findByName(&quot;sc&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以发现我们并没有写任何sql语句就实现了查询操作,为了研究到底是怎么做到的，所以打印了一下bookRepository的类型</p><blockquote><p>com.sun.proxy.$Proxy77</p></blockquote><p>可以看出它并不是我们声明的接口类型了，所以在实际执行过程中，是接口的代理在为我们执行sql操作。</p><h3 id="CrudRepositoy"><a href="#CrudRepositoy" class="headerlink" title="CrudRepositoy"></a>CrudRepositoy</h3><p>进入Repository接口的源代码，发现它并没有任何方法。我们依次看一下继承了Repository接口的子接口。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmzxyp1y8sj30n005bdi1.jpg" alt=""></p><p>首先看看CrudRepository接口，顾名思义，这个接口是一些简单的Crud操作，可以通过继承这个接口实现crud操作。在类名上有一个@NoRepositoryBean注解，表示这个接口不会生成代理，只是提供一些通用的方法。因为它继承自Repository接口，Repository接口会生成代理。首先修改一下BookRepository，继承CrudRepository接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test2()&#123;</div><div class="line">    Book book = new Book();</div><div class="line">    book.setName(&quot;java入门&quot;);</div><div class="line">    book.setUpdateDate(new Date());</div><div class="line">    book.setCreateDate(new Date());</div><div class="line">    bookRepository.save(book);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">public void test3()&#123;</div><div class="line">    Iterable&lt;Book&gt; all = bookRepository.findAll();</div><div class="line"></div><div class="line">    Book one = bookRepository.findOne(1L);</div><div class="line"></div><div class="line">    bookRepository.deleteAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一个sql语句都没写，便可以执行crud操作，对于小型的项目，真的很方便。在test2中，如果主键没有设置会执行insert语句，如果主键设置了，则会执行update语句，前提是主键对应的行项目是存在的。CrudRepository接口的方法都是比较简单的。</p><h3 id="PagingAndSortingRepository"><a href="#PagingAndSortingRepository" class="headerlink" title="PagingAndSortingRepository"></a>PagingAndSortingRepository</h3><p>一个提供了分页和排序的Repository，同样先修改我们的代码继承自PagingAndSortingRepository。编写测试代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test4()&#123;</div><div class="line">    bookRepository.findAll(new Sort(Sort.Direction.DESC,&quot;name&quot;,&quot;id&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>表示根据name和id降序排列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test5()&#123;</div><div class="line">    bookRepository.findAll(new Sort(new Sort.Order(Sort.Direction.DESC,&quot;name&quot;),new Sort.Order(Sort.Direction.ASC,&quot;id&quot;)));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>根据name的降序和id的升序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void test6()&#123;</div><div class="line">    Pageable pageable = new PageRequest(0,2,new Sort(Sort.Direction.DESC,&quot;name&quot;));</div><div class="line">    Page&lt;Book&gt; result = bookRepository.findAll(pageable);</div><div class="line">    System.out.println(&quot;共&quot;+result.getTotalPages()+&quot;页,共&quot;+result.getTotalElements()+&quot;条数据&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分页加排序,jpa会根据底层不同的数据库，生成不同的分页查询语句。</p><h3 id="JpaRepository"><a href="#JpaRepository" class="headerlink" title="JpaRepository"></a>JpaRepository</h3><p>这是我们最常继承的一个Repository，JpaRepository继承自PagingAndSortingRepository和QueryByExampleExecutor。</p><p>在这个接口中，JpaRepository覆盖了返回Iterator类型的一些方法，返回List类型更方便使用。</p><p>提供了flush方法和saveAndFlush方法，这些方法与持久化上下文有关。</p><p>通过传入Example对象执行带有条件的findAll方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void test7()&#123;</div><div class="line">    Book book =new Book();</div><div class="line">    book.setName(&quot;java&quot;);</div><div class="line">    ExampleMatcher exampleMatcher = ExampleMatcher.matching().withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);</div><div class="line">    //这里我们还可以指定一个匹配器，这里使用的是包含关系，也可以指定以xxx开头，以xxx结尾</div><div class="line">    Example&lt;Book&gt; example = Example.of(book,exampleMatcher);</div><div class="line">    bookRepository.findAll(example);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="静态查询"><a href="#静态查询" class="headerlink" title="静态查询"></a>静态查询</h3><p>jpa为我们提供了一种机制，让我可以把一些常见的查询语句转换为接口名称，只要接口名称符合规范就可以得到正确的结果。我们在最开始写的findByName方法实际上就是一个静态查询的例子。对应的查询转换可以见下面的表格,支持还是非常全面的</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fn00ifh6eoj30nu0iqadf.jpg" alt=""><br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn00if6c7yj30nw0adwgi.jpg" alt=""></p><p>当然如果查询语句非常复杂，想要用sql语句直接操作也是可以的。jpa有专门的语法让我们使用查询语句，叫做JPQL语句。可以屏蔽底层数据库的差异来写sql，并不针对表名来查询，而是针对类和类的属性来查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Query(&quot;from Book b where b.name like ?1 and b.id = ?2 order by b.name desc&quot;)</div><div class="line">List&lt;Book&gt; findBooks(String name,Long id);</div></pre></td></tr></table></figure><p>这个方法的意思就是根据name和id查找book。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Query(&quot;select count(1) from Book b where b.name like ?1 and b.id = ?2 order by b.name desc&quot;)</div><div class="line">List&lt;Book&gt; findBooks(String name,Long id);</div></pre></td></tr></table></figure><p>也可以直接写出select内容，不管方法的名称限定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Query(&quot;update Book b set b.name = ?1 where b.id = ?2&quot;)</div><div class="line">@Modifying</div><div class="line">int modifyBook(String name,Long id);</div></pre></td></tr></table></figure><p>在我们执行udpate或者delete这种操作的时候，接口方法必须要加@Modifying注解，否则无法生效。同时可能springboot-data-jpa的版本不同，有可能需要在业务代码或者测试代码上增加事务注解,如下，否则会抛异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">@Transactional</div><div class="line">public void test1()&#123;</div><div class="line">    bookRepository.modifyBook(&quot;java11111&quot;,2L);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在@Query注解中，我们可以声明nativeQuery这个属性为true。表示使用原生的sql，这时你写的sql语句就要符合你的底层数据库，而不能使用JPQL语句来写了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot-Data JPA之对象映射(1)</title>
      <link href="/2017/12/31/springboot-Data-JPA%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84/"/>
      <url>/2017/12/31/springboot-Data-JPA%E4%B9%8B%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>由于公司使用的是mybatis框架，所以自己学了学Hibernate。用的最多的应该就是SpringBoot-Data-Jpa，记录一下学习笔记。</p><h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line">@Data</div><div class="line">@Table(name=&quot;sc_category&quot;)</div><div class="line">public class Category &#123;</div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private int id;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@Table 指定表的名称</p><p>@Entity注解表示该对象可以映射成数据库的一张表</p><p>@Id表示该字段为主键</p><p>@GeneratedValue表示主键策略,它包含两个属性，strategy和generator。其中strategy默认为AUTO，generator默认为“”。generator用于自定义主键生成策略，需要额外添加一个@GenericGenerator注解。<br>strategy四个属性为：</p><ul><li>TABLE:根据特定表格生成主键</li><li>SEQUENCE:按照序列生成主键，需要数据库支持</li><li>IDENTITY:主键列自增长</li><li>AUTO: 根据数据库自动选择策略。mysql会选择IDENTITY</li></ul><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Basic</div><div class="line">@Column(name = &quot;sc_name&quot;,length = 10,nullable = false,unique = true)</div><div class="line">private String name;</div><div class="line"></div><div class="line">@Transient</div><div class="line">private String xxxx;</div><div class="line"></div><div class="line">@Column(columnDefinition = &quot;INT(3)&quot;)</div><div class="line">private int age;</div><div class="line"></div><div class="line">@Temporal(TemporalType.DATE)</div><div class="line">private Date birthDay;</div><div class="line"></div><div class="line">@Enumerated(EnumType.STRING)</div><div class="line">private GenderEnum gender;</div></pre></td></tr></table></figure><p>我们继续添加上面的属性，要注意的是每次修改属性代码，都要讲之前的数据库表删除，因为已经存在的列，hibernate是不会修改的。</p><p>@Basic每个属性都会默认加上这个注解，可以不写。</p><p>@Transizent表示这个属性不必写入数据库中。</p><p>@Colomn,这个注解包括了很多列的属性，常用的nullable可空的，unique唯一的，不可重复。要注意的是String类型的列可以用length来控制长度，而数字类型，例如int，就要用columnDefinition这个属性来控制长度。</p><p>@Temporal主要是控制时间的格式，有三种：DATE精确到日/DATETIME精确到时分秒/DATETIMESTAMP时间戳</p><p>@Enumerated注解的使用场景，比如性别我们只允许填入男或女，那么我们就可以建立一个枚举类，用这个注解指定保存到数据库的字段类型，可选String或Ordinary。枚举类代码很简单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public enum GenderEnum &#123;</div><div class="line">    MAN,</div><div class="line">    WOMEN;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="内嵌对象"><a href="#内嵌对象" class="headerlink" title="内嵌对象"></a>内嵌对象</h3><p>比如说我们对于地址字段，总是由省、市、区、邮编、地址等信息组成，如果每个表都写一遍就很累赘，有下面一种解决方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">新建一个地址类</div><div class="line">@Embeddable</div><div class="line">public class Address &#123;</div><div class="line">    private String province;</div><div class="line">    private String city;</div><div class="line">    private String area;</div><div class="line">    private String address;</div><div class="line">    private String zipCode;</div><div class="line">&#125;</div><div class="line"></div><div class="line">并在之前的类中继续添加一个属性,注意这里两个注解是不一样的，很容易弄混。</div><div class="line">    @Enumerated</div><div class="line">    private Address address;</div></pre></td></tr></table></figure><h3 id="内嵌集合"><a href="#内嵌集合" class="headerlink" title="内嵌集合"></a>内嵌集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@ElementCollection</div><div class="line">private List&lt;String&gt; hobbies;</div></pre></td></tr></table></figure><p>例如我们添加了这样的一个属性，那么jpa会自动生成一张关联表</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmzqzvqqgoj305501cjra.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmzqzwm8h2j305v02sjra.jpg" alt=""></p><p>hobbies属性与category表的主键相关联，如果在集合中插入了3条数据，那么就会在hobbies表中增加三条对应category ID的记录。集合中的对象不仅可以是像String这种基本属性，也可以是自定义的复杂属性，比如我们刚刚建立的地址类:List<address>,hibernate也会生成一张表，机制与hobbies类似。</address></p><h3 id="自定义表名列名"><a href="#自定义表名列名" class="headerlink" title="自定义表名列名"></a>自定义表名列名</h3><p>有时候为了防止表名重复或者出发到数据库的关键字，我们会在表名前加一个前缀，如果每个表都去指定就太麻烦了，我们可以通过自己实现一个命名策略简化这些步骤。首先新建一个配置类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MyNameStrategy extends ImplicitNamingStrategyJpaCompliantImpl&#123;</div><div class="line">    @Override</div><div class="line">    protected Identifier toIdentifier(String stringForm, MetadataBuildingContext buildingContext) &#123;</div><div class="line">        return super.toIdentifier(&quot;sc_&quot;+stringForm, buildingContext); //在这里加一个前缀</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">spring.jpa.hibernate.naming.implicit-strategy=com.example.demo.config.MyNameStrategy 在配置文件中加入配置</div></pre></td></tr></table></figure><p>这样，在每个表和列之前都加入了一个前缀sc_,如果有的表或者列不需要前缀，可以再列或者表上指定名称，因为直接指定的优先级更高。</p><h3 id="多对一关系的映射"><a href="#多对一关系的映射" class="headerlink" title="多对一关系的映射"></a>多对一关系的映射</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line">public class Book &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @ManyToOne</div><div class="line">    private Category category;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>category类我们不做改变，新增一个book类。因为多本书可以属于同一个分类，所以书对于类别的关系是多对一的，我们添加一个@ManyToOne注解</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmzrb75z10j308y022gli.jpg" alt=""></p><p>我们可以看到hibernate做的就是添加了一个列，这个列其实是一个外键，对应的就是category表的id属性。这里我们就做了一个单向的从book到category的多对一关系。</p><h3 id="一对多关系映射"><a href="#一对多关系映射" class="headerlink" title="一对多关系映射"></a>一对多关系映射</h3><p>由于一个分类可以对应多个book，所以category对于book就是一对多的映射关系，我们可以通过集合来表示这种关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@OneToMany</div><div class="line">private List&lt;Book&gt; books;</div></pre></td></tr></table></figure><p>这个注解产生的效果与内嵌集合的效果相同，都是新增了一张中间表来映射关系。通过这种注解，category和book建立了一种双向的关联。在book这一方添加了一个外键，在category这一方建立了一张中间表。那么如果我们希望book这一方来维护这种关系，而category这一方只需要声明这种一对多关系，因为我希望通过category来查找相应的book。那么我们可以这样来做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@OneToMany(mappedBy = &quot;category&quot;)</div><div class="line">private List&lt;Book&gt; books;</div></pre></td></tr></table></figure><p>我们添加一个mappdby属性，意思是说，category这一方放弃维护关系，而是交给book表中category这一列来维护，我们看一下生成的表就很容易明白了。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmzrb75z10j308y022gli.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmzrx319tuj306102fdfr.jpg" alt=""></p><p>可以看出，book表依旧生成了一个外键，而category则没有生成之前那张中间表。我们也可以使用同样的注解使book放弃维护，让category维护一对多关系。</p><h3 id="多对多关系映射"><a href="#多对多关系映射" class="headerlink" title="多对多关系映射"></a>多对多关系映射</h3><p>我们继续建立一张BookAuthor表和Author表。一本书可以有多个作者，一个作者也可以有多本书。我们尝试建立一种多对多的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line">public class Author &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @OneToMany(mappedBy = &quot;author&quot;)</div><div class="line">    private List&lt;BookAuthor&gt; books;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Entity</div><div class="line">@Data</div><div class="line">public class Book &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @ManyToOne</div><div class="line">    private Category category;</div><div class="line"></div><div class="line">    @OneToMany(mappedBy = &quot;book&quot;)</div><div class="line">    private List&lt;BookAuthor&gt; authors;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@Entity</div><div class="line">@Data</div><div class="line">public class BookAuthor &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    @ManyToOne</div><div class="line">    private Book book;</div><div class="line"></div><div class="line">    @ManyToOne</div><div class="line">    private Author author;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种实现多对多的方式是通过一张中间表来完成的，执行项目之后会在数据库中生成一张中间表，通过外键关联两张表。那么很多人就会产生疑惑，为什么我们不直接使用@ManyToMany注解表示多对多的关系呢？因为这个注解很难用- -!在Hibernate最佳实践中明确告诉我们尽量不要用ManyToMany这种形式。永远把多对多关系拆分成两个多对一关系。通过这种方式，当我们获取对应关系的时候，默认是按照主键Id的顺序排序的，如果我们想指定排序规则，可以使用这种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@OneToMany(mappedBy = &quot;author&quot;)</div><div class="line">@OrderBy(&quot;book.name ASC&quot;)</div><div class="line">private List&lt;BookAuthor&gt; books;</div></pre></td></tr></table></figure><p>这样表示通过BookAuthor类的book属性，根据book的name属性升序排序。</p><h3 id="一对一关系映射"><a href="#一对一关系映射" class="headerlink" title="一对一关系映射"></a>一对一关系映射</h3><p>一对一的的映射其实是这样一种场景，比如一个Author表和一个AuthorInfo表，我们大部分查询只需要Author表里面的信息，少数时间需要查询info里面的信息，那么我们就可以吧不常用的信息放到info表里，这样Author和AuthorInfo就形成了一种一对一的关系映射。为了演示，增加一个AuthorInfo类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Entity</div><div class="line">@Data</div><div class="line">public class AuthorInfo &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    private String school;</div><div class="line"></div><div class="line">    @OneToOne(mappedBy = &quot;info&quot;) //将关系的管理权交给autho对象的info属性</div><div class="line">    private Author author;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Data</div><div class="line">@Entity</div><div class="line">public class Author &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    @OneToMany(mappedBy = &quot;author&quot;)</div><div class="line">    private List&lt;BookAuthor&gt; books;</div><div class="line"></div><div class="line">    @OneToOne</div><div class="line">    private AuthorInfo info;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样在author表中就多出了一个infoId的字段，通过外键来管理author info，而author_info表不会出现author表的外键。</p><h3 id="继承的映射"><a href="#继承的映射" class="headerlink" title="继承的映射"></a>继承的映射</h3><p>在java中我们可以通过继承来解决属性的重用，而在关系型数据中是不存在继承这种关系的。那么我们来看一下Hibernate是如何解决这种问题的。我们新建一个CommonProperty类，抽出每个实体类都有的Id属性，并增加一个创建时间和修改时间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@MappedSuperclass</div><div class="line">@Data</div><div class="line">public class CommonProperty &#123;</div><div class="line"></div><div class="line">    @Id</div><div class="line">    @GeneratedValue</div><div class="line">    private Long id;</div><div class="line"></div><div class="line">    @Temporal(TemporalType.DATE)</div><div class="line">    private Date createDate;</div><div class="line"></div><div class="line">    @Temporal(TemporalType.DATE)</div><div class="line">    private Date updateDate;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后我们让每个实体类都去继承这个类就可以了。执行之后查看数据库发现每个实体表都会增加上述三个属性。实现的关键就在于这个@MappedSuperclass注解。@MappedSuperclass标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis分布式原理及操作</title>
      <link href="/2017/12/30/redis%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/12/30/redis%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="传统分布式算法"><a href="#传统分布式算法" class="headerlink" title="传统分布式算法"></a>传统分布式算法</h3><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>假设我们有20个数据需要缓存，并且有4个分布式redis节点。数据直接通过编号对4进行取余，得到他们Hash到的位置，并放置在对应的redis节点上。效果如图</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmyrl9l2i8j30f70avt9h.jpg" alt=""></p><p>但是随着我们业务的变化，Redis节点的数量可能会增加或者减少。假设我们增加一个redis节点</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmyrqg77cfj30dl0e5gmh.jpg" alt=""></p><p>重新进行hash之后，对应关系如图所示，绿色的部分就是我们两次hash，数据还映射到同一个redis的数据，总共有4个，也就是说，在传统的分布式算法下，增加一个节点，数据的命中率下降到了4/20=20%。我们演示只用了20个数据，在实际生产环境中，很可能是成千上万的数据，那么这些miss的数据就会直接去访问数据库，对数据库造成巨大的压力。那么如何解决或者降低这种缓存miss的概率呢，一个解决方案就是redis采用的一致性hash算法。</p><h3 id="Consistent-hashing一致性算法原理"><a href="#Consistent-hashing一致性算法原理" class="headerlink" title="Consistent hashing一致性算法原理"></a>Consistent hashing一致性算法原理</h3><h4 id="环形hash空间"><a href="#环形hash空间" class="headerlink" title="环形hash空间"></a>环形hash空间</h4><p>通常hash算法都是将value映射到一个32位的key值当中，我们假设将这个数轴首尾相接形成一个环</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmysqyxksfj307p06xdfx.jpg" alt=""></p><p>现在映射空间已经形成，我们要考虑如何将数据映射到空间上。</p><p>假设有4个对象O1~O4,可以通过hash函数计算出hash值的key，映射到如下的位置</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fmyt2pww53j30e80bv74o.jpg" alt=""></p><p>接着我们使用相同的hash算法把缓存实例(redis)映射到环形空间，一般是通过hash IP地址或者机器名等等</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmyt7o8709j30e90b6mxl.jpg" alt=""></p><p>通过hash算法我们现在已经把reids和数据都进行了hash，那么怎么确定哪个数据映射到哪个redis上呢<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmytartexsj30du0bmgm6.jpg" alt=""></p><p>映射方法如图，我们顺时针看这个圈，每个数据O按顺时针方向找到第一个R，那么这个O就存储在这个R节点上。现在并没有看出这个算法的优势，现在我们假设移除一个Redis节点R2，那么O4数据就会miss，那么这个算法会按原来的方案，将数据映射到R3上。如果我们移除R3节点，受影响的就是O2和O3，其实我们发现，移除或者增加节点，只会影响到新增R与逆时针的第一个R节点之间的数据，其他数据不会受到影响。而使用传统的Hash算法，基本上每个节点都会受到影响，这就体现了一致性Hash的一个优势，那就是<strong><em><em>缩小了影响范围</em></em></strong>。</p><h4 id="Hash算法的倾斜性"><a href="#Hash算法的倾斜性" class="headerlink" title="Hash算法的倾斜性"></a>Hash算法的倾斜性</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmytk2wik1j30ey0b5dg7.jpg" alt=""><br>在实际的Hash计算中，很可能会出现上图中描述的现象。从这个图中我们可以看出来，大量的数据映射到R1节点上，R2,R3都非常空闲。这样会造成R1节点的负载很高，这就是Hash算法的倾斜性。<br>那么如何解决这种Hash倾斜性带来的问题呢</p><h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>假设我们增加3个虚拟节点，将其均匀的分布在环上。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmytsc78azj30e10bf3yw.jpg" alt=""></p><p>可以看出这时的环比刚才而言均匀了许多，我们可以让映射到V1的节点实际上存储到R1,V2存储到R2，V3存储到R3。这样R1 R2 R3之间的负载就均衡了。实际在Redis中，虚拟节点可能会建立成百上千个。Redis通过建立虚拟节点，并将虚拟节点Hash到实际的Redis节点上，通过这种方法将真实节点进行放大，就解决了这种Hash倾斜性造成的问题。在Jedis的源码中，我们可以再Sharded这个类的init方法中看到，每个实例的虚拟节点默认是160个。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>一致性Hash算法最大限度上抑制了key的重新分布，并且随着缓存实例数量的增加，对key命中的影响会越来越小，而传统的Hash算法，影响只会越来越大。</p><h3 id="Jedis配置"><a href="#Jedis配置" class="headerlink" title="Jedis配置"></a>Jedis配置</h3><p>首先在服务器启动两个Redis节点并在本地项目中配置相应的端口和IP</p><p>ShardedPool配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">public class RedisShardedPool &#123;</div><div class="line"></div><div class="line"></div><div class="line">    private static ShardedJedisPool pool;</div><div class="line">    private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty(&quot;redis.max.total&quot;,&quot;20&quot;));</div><div class="line">    private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty(&quot;redis.max.idle&quot;,&quot;20&quot;));</div><div class="line">    private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty(&quot;redis.min.idle&quot;,&quot;20&quot;));</div><div class="line"></div><div class="line">    private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty(&quot;redis.test.borrow&quot;,&quot;true&quot;));</div><div class="line">    private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty(&quot;redis.test.return&quot;,&quot;true&quot;));</div><div class="line"></div><div class="line">    private static String redisIp = PropertiesUtil.getProperty(&quot;redis.ip&quot;);</div><div class="line">    private static Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty(&quot;redis.port&quot;));</div><div class="line"></div><div class="line">    private static String redis2Ip = PropertiesUtil.getProperty(&quot;redis2.ip&quot;);</div><div class="line">    private static Integer redis2Port = Integer.parseInt(PropertiesUtil.getProperty(&quot;redis2.port&quot;));</div><div class="line"></div><div class="line"></div><div class="line">    private static void initPool()&#123;</div><div class="line">        JedisPoolConfig conf = new JedisPoolConfig();</div><div class="line">        conf.setMaxTotal(maxTotal);</div><div class="line">        conf.setMaxIdle(maxIdle);</div><div class="line">        conf.setMinIdle(minIdle);</div><div class="line">        conf.setTestOnBorrow(testOnBorrow);</div><div class="line">        conf.setTestOnReturn(testOnReturn);</div><div class="line">        conf.setBlockWhenExhausted(true);</div><div class="line">        JedisShardInfo info1 = new JedisShardInfo(redisIp,redisPort);</div><div class="line">        JedisShardInfo info2 = new JedisShardInfo(redis2Ip,redis2Port);</div><div class="line">        List&lt;JedisShardInfo&gt; list = Arrays.asList(info1,info2);</div><div class="line">        //MURMUR Hash就是一致性算法</div><div class="line">        pool = new ShardedJedisPool(conf,list, Hashing.MURMUR_HASH, Sharded.DEFAULT_KEY_TAG_PATTERN);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        initPool();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static ShardedJedis   getJedis()&#123;</div><div class="line">        return pool.getResource();</div><div class="line">    &#125;</div><div class="line">    public static void returnBrokenResource(ShardedJedis jedis)&#123;</div><div class="line">        pool.returnBrokenResource(jedis);</div><div class="line">    &#125;</div><div class="line">    public static void returnResource(ShardedJedis jedis)&#123;</div><div class="line">        pool.returnResource(jedis);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            ShardedJedis jedis = pool.getResource();</div><div class="line">            jedis.set(i+&quot;&quot;,i+&quot;&quot;);</div><div class="line">            returnResource(jedis);</div><div class="line">        &#125;</div><div class="line">        pool.destroy();</div><div class="line">        System.out.println(&quot;end&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>操作方法类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">@Slf4j</div><div class="line">public class RedisShardedPoolUtil &#123;</div><div class="line">    public static String set(String key,String value)&#123;</div><div class="line">        ShardedJedis jedis = null;</div><div class="line">        String result= null;</div><div class="line">        try &#123;</div><div class="line">            jedis = RedisShardedPool.getJedis();</div><div class="line">            result = jedis.set(key, value);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;set key:&#123;&#125; value:&#123;&#125; error&quot;,key,value);</div><div class="line">            RedisShardedPool.returnBrokenResource(jedis);</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">        RedisShardedPool.returnResource(jedis);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static String get(String key)&#123;</div><div class="line">        ShardedJedis jedis = null;</div><div class="line">        String reslut= null;</div><div class="line">        try &#123;</div><div class="line">            jedis = RedisShardedPool.getJedis();</div><div class="line">            reslut = jedis.get(key);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;get key:&#123;&#125; error&quot;,key);</div><div class="line">            RedisShardedPool.returnBrokenResource(jedis);</div><div class="line">            return reslut;</div><div class="line">        &#125;</div><div class="line">        RedisShardedPool.returnResource(jedis);</div><div class="line">        return reslut;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 时间单位是秒</div><div class="line">     */</div><div class="line">    public static String setEx(String key,String value,int exTime)&#123;</div><div class="line">        ShardedJedis jedis = null;</div><div class="line">        String result= null;</div><div class="line">        try &#123;</div><div class="line">            jedis = RedisShardedPool.getJedis();</div><div class="line">            result = jedis.setex(key,exTime,value);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;setex key:&#123;&#125; value:&#123;&#125; error&quot;,key,value);</div><div class="line">            RedisShardedPool.returnBrokenResource(jedis);</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">        RedisShardedPool.returnResource(jedis);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public static Long expire(String key,int exTime)&#123;</div><div class="line">        ShardedJedis jedis = null;</div><div class="line">        Long result= null;</div><div class="line">        try &#123;</div><div class="line">            jedis = RedisShardedPool.getJedis();</div><div class="line">            result = jedis.expire(key,exTime);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;expire key:&#123;&#125;  error&quot;,key);</div><div class="line">            RedisShardedPool.returnBrokenResource(jedis);</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">        RedisShardedPool.returnResource(jedis);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Long del(String key)&#123;</div><div class="line">        ShardedJedis jedis = null;</div><div class="line">        Long result= null;</div><div class="line">        try &#123;</div><div class="line">            jedis = RedisShardedPool.getJedis();</div><div class="line">            result = jedis.del(key);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;del key:&#123;&#125;  error&quot;,key);</div><div class="line">            RedisShardedPool.returnBrokenResource(jedis);</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">        RedisShardedPool.returnResource(jedis);</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMq入门-实现微博关注demo(2)</title>
      <link href="/2017/12/23/RabbitMq%E5%85%A5%E9%97%A8-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E5%8D%9A%E5%85%B3%E6%B3%A8demo-2/"/>
      <url>/2017/12/23/RabbitMq%E5%85%A5%E9%97%A8-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E5%8D%9A%E5%85%B3%E6%B3%A8demo-2/</url>
      
        <content type="html"><![CDATA[<p>在网上看了很多RabbitMq的demo，发现都是Exchange三种路由模式的demo，很少有真实案例的demo，在这里分享一个自己写的模拟微博关注的demo,方便理解和学习。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>SpringBoot  RabbitMq</p><h3 id="构思"><a href="#构思" class="headerlink" title="构思"></a>构思</h3><ol><li>美女发布消息，关注她的人可以接收到消息</li><li>关注和取关都记录到日志中</li><li>美女和关注者都可以动态添加,添加一个美女就是添加一个Fanout模式的Exchange，一个关注者就是一个队列绑定到对应美女的Exchange</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmpi6l7tvbj30hm0bn75v.jpg" alt=""></p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><p>列出想要实现的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@RestController</div><div class="line">public class Controller &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private LikeService likeService;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 美女注册</div><div class="line">     */</div><div class="line">    @GetMapping(&quot;/addBeauty&quot;)</div><div class="line">    public void addBeauty(String name)&#123;</div><div class="line">        likeService.addBeauty(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关注她</div><div class="line">     */</div><div class="line">    @GetMapping(&quot;/like&quot;)</div><div class="line">    public void like(String boyName,String girlName)</div><div class="line">    &#123;</div><div class="line">        likeService.like(boyName,girlName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 取关</div><div class="line">     */</div><div class="line">    @GetMapping(&quot;/unlike&quot;)</div><div class="line">    public void unlike(String boyName,String girlName)&#123;</div><div class="line">        likeService.unlike(boyName,girlName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 美女发朋友圈了</div><div class="line">     */</div><div class="line">    @GetMapping(&quot;/post&quot;)</div><div class="line">    public void postMessage(String girlName,String message)&#123;</div><div class="line">         likeService.postMessage(girlName,message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class BaseRabbitConfig &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public ConnectionFactory connectionFactory()&#123;</div><div class="line">        CachingConnectionFactory factory = new CachingConnectionFactory();</div><div class="line">        factory.setVirtualHost(&quot;/&quot;);</div><div class="line">        factory.setUsername(&quot;用户名&quot;);</div><div class="line">        factory.setPassword(&quot;密码&quot;);</div><div class="line">        factory.setAddresses(&quot;IP+PORT&quot;);</div><div class="line">        return factory;</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public RabbitManagementTemplate rabbitManagementTemplate()&#123;</div><div class="line">        return new RabbitManagementTemplate(&quot;http://用户名:密码@IP+PORT/api/&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public AmqpAdmin amqpAdmin()&#123;</div><div class="line">        return new RabbitAdmin(connectionFactory());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public RabbitTemplate rabbitTemplate()&#123;</div><div class="line">        return new RabbitTemplate(connectionFactory());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@Configuration</div><div class="line">public class LogRabbitConfig extends BaseRabbitConfig &#123;</div><div class="line"></div><div class="line">    public static final String LOG_QUEUE = &quot;LOG_QUEUE&quot;;</div><div class="line">    public static final String LOG_EXCHANGE = &quot;LOG_EXCHANGE&quot;;</div><div class="line">    public final static String ROUTING_KEY=&quot;log&quot;;</div><div class="line">    @Bean</div><div class="line">    public Queue logQueue()&#123;</div><div class="line">        return new Queue(LOG_QUEUE);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 监听容器</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public SimpleMessageListenerContainer container(ConnectionFactory connectionFactory, LogListener logListener)&#123;</div><div class="line">        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</div><div class="line">        container.setConnectionFactory(connectionFactory);</div><div class="line">        container.setQueueNames(new String[]&#123;LOG_QUEUE&#125;);</div><div class="line">        container.setMessageListener(logListener);</div><div class="line">        return container;</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    LogListener logListener()&#123;</div><div class="line">        return new LogListener();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public DirectExchange directExchange()&#123;</div><div class="line">        return new DirectExchange(LOG_EXCHANGE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    Binding binding(Queue logQueue,DirectExchange directExchange)&#123;</div><div class="line">        return BindingBuilder.bind(logQueue).to(directExchange).with(ROUTING_KEY);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里我注册了一个RabbitManagementTemplate，作用是调用HttpApi。因为我的构想是希望能够实现队列和交换器的热插拔，这时要解决的问题就是实时获取Exchange的列表和一些绑定的信息，但在网上并没有找到相关的资料。<br>这里一个技巧就是查找函数了，在IDEA中可以双击shift搜索函数。比如我想要的功能是getExchanges(),因为我猜这个功能的调用函数就叫这个名字，果然在这里发现了:</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmqrsrah7ij30cp0dqjuz.jpg" alt=""></p><p>可以看到还可以取到队列，绑定的信息，这就是我们实现热插拔的必要条件了，接着看到它的构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public RabbitManagementTemplate() &#123;</div><div class="line">        this(&quot;http://guest:guest@localhost:15672/api/&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>所以只要我们把地址填成我们自己的rabbitmq配置就可以，这个对象其实就是调用了RabbitMq的HttpApi。我们可以打开RabbitMq的webUI，拉到最下面</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmqrw8gd75j305j02djrd.jpg" alt=""></p><p>点击这个Http API就可以通过Restful的方式调用这些API</p><h3 id="业务实现"><a href="#业务实现" class="headerlink" title="业务实现"></a>业务实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Service</div><div class="line">public class LikeService &#123;</div><div class="line">    @Autowired</div><div class="line">    private RabbitTemplate rabbitTemplate;</div><div class="line">    @Autowired</div><div class="line">    private AmqpAdmin amqpAdmin;</div><div class="line">    @Autowired</div><div class="line">    private RabbitManagementTemplate rabbitManagementTemplate;</div><div class="line">    public void addBeauty(String name) &#123;</div><div class="line">        try &#123;</div><div class="line">            FanoutExchange fanoutExchange = new FanoutExchange(name);</div><div class="line">            amqpAdmin.declareExchange(fanoutExchange);</div><div class="line">            System.out.println(&quot;初始化交换器成功 :&quot;+name);</div><div class="line">            rabbitTemplate.convertAndSend(LogRabbitConfig.LOG_EXCHANGE,LogRabbitConfig.ROUTING_KEY,&quot;初始化交换器&quot;+name);</div><div class="line"></div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            System.out.println(&quot;初始化交换器失败 :&quot;+name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void like(String boyName, String girlName) &#123;</div><div class="line"></div><div class="line">        Queue queue = new Queue(boyName);</div><div class="line">        FanoutExchange fanoutExchange = (FanoutExchange) rabbitManagementTemplate.getExchange(girlName);</div><div class="line">        amqpAdmin.declareQueue(queue);</div><div class="line">        amqpAdmin.declareBinding(BindingBuilder.bind(queue).to(fanoutExchange));</div><div class="line">        SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();</div><div class="line">        container.setQueueNames(boyName);</div><div class="line">        container.setConnectionFactory(rabbitTemplate.getConnectionFactory());</div><div class="line">        container.setMessageListener(new BoyListener());</div><div class="line">        container.start();</div><div class="line">        System.out.println(boyName+&quot;关注了&quot;+girlName);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void postMessage(String girlName, String message) &#123;</div><div class="line">        System.out.println(girlName+&quot;发了一条微博&quot;+message);</div><div class="line">        rabbitTemplate.convertAndSend(girlName,&quot;&quot;,message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void unlike(String boyName, String girlName) &#123;</div><div class="line">            Queue queue = rabbitManagementTemplate.getQueue(boyName);</div><div class="line">            rabbitManagementTemplate.deleteQueue(queue);</div><div class="line">        rabbitTemplate.convertAndSend(LogRabbitConfig.LOG_EXCHANGE,LogRabbitConfig.ROUTING_KEY,boyName+&quot;取关了&quot;+girlName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@RabbitListener</div><div class="line">public class BoyListener implements MessageListener&#123;</div><div class="line">    @Override</div><div class="line">    public void onMessage(org.springframework.amqp.core.Message message) &#123;</div><div class="line">        System.out.println(message.getMessageProperties().getConsumerQueue()+&quot;看到&quot;+message.getMessageProperties().getReceivedExchange()+&quot;发朋友圈&quot;+new String(message.getBody()));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@Service</div><div class="line">public class LogListener implements MessageListener&#123;</div><div class="line">    @Override</div><div class="line">    public void onMessage(Message message) &#123;</div><div class="line">        System.out.println(&quot;LOG QUEUE ============&quot;);</div><div class="line">        System.out.println(new String(message.getBody()));</div><div class="line">        //写入文件</div><div class="line">        System.out.println(&quot;======================&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmqp9ou0irj308q083gmi.jpg" alt=""></p><p>这里中文出现了乱码，目前已经解决问题,代码在这里</p><blockquote><p><a href="https://gitee.com/swiftsc/RabbitMq-mockweipo" target="_blank" rel="external">https://gitee.com/swiftsc/RabbitMq-mockweipo</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMq入门-基本概念(1)</title>
      <link href="/2017/12/22/RabbitMq%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2017/12/22/RabbitMq%E5%85%A5%E9%97%A8-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>Java Message Service，是java平台面向消息中间件的API，提供了与消息中间件厂商无关的访问方法，作用相当于JDBC，在多个应用程序之间，提供异步的通信服务。由于JMS只是一套API，具体的实现还是依靠Mq来做，目前使用最多的就是AcitveMq，因此在springboot中，jms默认使用的就是activemq。目前springboot集成了两种jms的实现:AcitveMq和Artemis(没听说过),实现了AMQP协议的rabbitMq以及一种发布订阅系统kafka。</p><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>Advanced Message Queuing Protocol,是一个应用层的消息队列协议，基于此协议开发消息队列产品，可以不受编程语言的限制。</p><h3 id="为什么选择RabbitMq"><a href="#为什么选择RabbitMq" class="headerlink" title="为什么选择RabbitMq"></a>为什么选择RabbitMq</h3><p>一张图就能说明</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmp9tuv6cxj30py0nq42h.jpg" alt=""></p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="RabbitMq相关概念"><a href="#RabbitMq相关概念" class="headerlink" title="RabbitMq相关概念"></a>RabbitMq相关概念</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmpb1g99e8j30jx0a7t9f.jpg" alt=""></p><ol><li><p>Virtual host: rabbitmq server实际上是由多个vutrual rabbitmq server组成的,即Vhost，默认是 “/”,每个用户所能使用的Exchange和queue也都是一个vhost的，而不能跨vhost调用。这样做的优点是可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。</p></li><li><p>Queue: 消息队列，FIFO，支持缓存、持久化、自动删除</p></li><li><p>Exchange: 交换机，用来管理队列。在实际操作中，消息并不直接发布给队列，而是发布给Exchange，Exchange根据不同的路由策略选择转发到哪条队列中。Exchange有4种类型：direct(默认)，fanout, topic, 和headers。</p></li><li><p>Binding: 指定Exchange与Queue建立关系，支持多对多，一对多，多对一。</p></li><li><p>Connection: 与rabbitmq server建立的一种TCP连接。客户端可以断开连接，server不会主动断开。</p></li><li><p>Channel: 一个Connection支持多个Channel，以减少建立Connection所需要的消耗。应用可以通过多线程的方式建立多个Channel，共用一个Connection，减少消耗  </p></li></ol><h3 id="Exchange交换机制"><a href="#Exchange交换机制" class="headerlink" title="Exchange交换机制"></a>Exchange交换机制</h3><ol><li>Direct: 直接交换器，Exchange会将消息发送完全匹配ROUTING_KEY的Queue</li><li>Fanout: 广播方式，Exchange都会将消息转发给所有绑定的Queue</li><li>Topic: Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，工作方式类似于sql中的like模糊匹配。</li><li><p>Headers: 与ROUTING_KEY无关，根据消息中的键值对进行匹配，headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型。</p><p> x-match = all   ：表示所有的键值对都匹配才能接受到消息</p><p> x-match = any ：表示只要有键值对匹配就能接受到消息</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">例如 初始化Exchange:HashMap message = new HashMap(3);</div><div class="line"> message.put(&quot;x-match&quot;,&quot;any&quot;);</div><div class="line"> message.put(&quot;name&quot;,&quot;sc&quot;);</div><div class="line"> message.put(&quot;age&quot;,10);</div><div class="line"> channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;, message);</div><div class="line"> </div><div class="line"> 生产者发布消息:HashMap message = new HashMap(3);</div><div class="line">  message.put(&quot;name&quot;,&quot;sc&quot;);</div><div class="line"> message.put(&quot;age&quot;,20);</div><div class="line">   由于配置的x-match属性为any，所以Exchange会转发这条信息，如果改为all，则会拒绝这条信息。</div></pre></td></tr></table></figure><h3 id="RabbitMq在阿里云上的配置"><a href="#RabbitMq在阿里云上的配置" class="headerlink" title="RabbitMq在阿里云上的配置"></a>RabbitMq在阿里云上的配置</h3><p>由于自己有一个阿里云服务器，所以想把Rabbit放在云上使用，结果碰到了一些坑。由于rabbitmq默认是不支持外网访问的，初始化时的guest用户只能在localhost访问，那么我们就需要配置一个远程访问权限的用户。</p><p>我使用的是rabbitmq3.6.3,centos7</p><ol><li>进入安装目录/sbin         ./rabbitmqctl add_user 用户名 密码</li><li>给默认vhost / 设置权限    ./rabbitmqctl set_permissions -p “/“ 用户名 “.<em>“ “.</em>“ “.*”</li><li>赋予管理员权限            ./rabbitmqctl set_user_tags 用户名 administrator</li><li>配置文件 由于安装方式不同，配置文件的位置可能也不同，如果存在/etc/rabbitmq/目录，就编辑这个目录下rabbitmq.config(没有就创建),加入以下代码[<br>{rabbit, [{tcp_listeners, [5672]}, {loopback_users, [“用户名”]}]}<br>].注意最后有个点号。如果你是直接解压缩使用的，那么就在解压缩目录下的rabbit-xxxx/etc/rabbit，创建文件添加代码就可以了。</li><li>通过公网网址：15672访问。</li></ol><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fmpabysk3ij30pl0aw76g.jpg" alt=""><br>通过这里就可以查看你的配置文件有没有找到，通过web管理也可以很方便的管理rabbit,可以自己摸索一下。</p><h3 id="基础Demo"><a href="#基础Demo" class="headerlink" title="基础Demo"></a>基础Demo</h3><p>RabbitMq配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class MyRabbitConfig &#123;</div><div class="line">    @Value(&quot;$&#123;rabbit.host&#125;&quot;)</div><div class="line">    private String host;</div><div class="line">    @Value(&quot;$&#123;rabbit.port&#125;&quot;)</div><div class="line">    private int port;</div><div class="line">    @Value(&quot;$&#123;rabbit.username&#125;&quot;)</div><div class="line">    private String username;</div><div class="line">    @Value(&quot;$&#123;rabbit.password&#125;&quot;)</div><div class="line">    private String password;</div><div class="line">    @Value(&quot;$&#123;rabbit.vhost&#125;&quot;)</div><div class="line">    private String vhost;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public ConnectionFactory connectionFactory()&#123;</div><div class="line">        CachingConnectionFactory factory = new CachingConnectionFactory();</div><div class="line">        factory.setHost(host);</div><div class="line">        factory.setPort(port);</div><div class="line">        factory.setUsername(username);</div><div class="line">        factory.setPassword(password);</div><div class="line">        factory.setVirtualHost(vhost);</div><div class="line">        factory.setPublisherConfirms(true);</div><div class="line">        return factory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</div><div class="line">    public RabbitTemplate rabbitTemplate()&#123;</div><div class="line">        RabbitTemplate template = new RabbitTemplate(connectionFactory());</div><div class="line">        return template;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public Queue helloQueue()&#123;</div><div class="line">        return new Queue(&quot;hello&quot;);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public Queue userQueue()&#123;</div><div class="line">        return new Queue(&quot;user&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 验证topic</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public Queue queueMessage()&#123;</div><div class="line">        return new Queue(&quot;topic.message&quot;);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public Queue queueMessages()&#123;</div><div class="line">        return new Queue(&quot;topic.messages&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * fanout</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    public Queue AMessage()&#123;</div><div class="line">        return new Queue(&quot;fanout.A&quot;);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public Queue BMessage()&#123;</div><div class="line">        return new Queue(&quot;fanout.B&quot;);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    public Queue CMessage()&#123;</div><div class="line">        return new Queue(&quot;fanout.C&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * topic exchange</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    TopicExchange exchange()&#123;</div><div class="line">        return new TopicExchange(&quot;topicExchange&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * fanout exchange</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    FanoutExchange fanoutExchange()&#123;</div><div class="line">        return new FanoutExchange(&quot;fanoutExchange&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 完全匹配</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    Binding bindingTopic(Queue queueMessage,TopicExchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 模糊匹配</div><div class="line">     */</div><div class="line">    @Bean</div><div class="line">    Binding bindingTopics(Queue queueMessages,TopicExchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);</div><div class="line">    &#125;</div><div class="line"> /**</div><div class="line"> * fanout 绑定</div><div class="line"> */</div><div class="line">    @Bean</div><div class="line">    Binding bindingA(Queue AMessage,FanoutExchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(AMessage).to(exchange);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    Binding bindingB(Queue BMessage,FanoutExchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(BMessage).to(exchange);</div><div class="line">    &#125;</div><div class="line">    @Bean</div><div class="line">    Binding bindingC(Queue CMessage,FanoutExchange exchange)&#123;</div><div class="line">        return BindingBuilder.bind(CMessage).to(exchange);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>GetMapping测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@Autowired</div><div class="line">private TopicSender topicSender;</div><div class="line"></div><div class="line">@Autowired</div><div class="line">private FanoutSender fanoutSender;</div><div class="line"></div><div class="line">@GetMapping(&quot;/topic&quot;)</div><div class="line">public void topic()&#123;</div><div class="line">    topicSender.send();</div><div class="line">&#125;</div><div class="line">@GetMapping(&quot;/fanout&quot;)</div><div class="line">public void fan()&#123;</div><div class="line">    fanoutSender.send();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Fanout测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class FanoutSender &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private AmqpTemplate template;</div><div class="line"></div><div class="line">    public void send()&#123;</div><div class="line">        String message = &quot;fanout send&quot;;</div><div class="line">        template.convertAndSend(&quot;fanoutExchange&quot;,&quot;haha&quot;,message);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Component</div><div class="line">@RabbitListener(queues = &quot;fanout.C&quot;)</div><div class="line">public class FanoutRC &#123;</div><div class="line">    @RabbitHandler</div><div class="line">    public void process(String message)&#123;</div><div class="line">        System.out.println(&quot;fanout C :&quot;+ message);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Component</div><div class="line">@RabbitListener(queues = &quot;fanout.B&quot;)</div><div class="line">public class FanoutRB &#123;</div><div class="line">    @RabbitHandler</div><div class="line">    public void process(String message)&#123;</div><div class="line">        System.out.println(&quot;fanout B :&quot;+ message);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@Component</div><div class="line">@RabbitListener(queues = &quot;fanout.A&quot;)</div><div class="line">public class FanoutRA &#123;</div><div class="line">    @RabbitHandler</div><div class="line">    public void process(String message)&#123;</div><div class="line">        System.out.println(&quot;fanout A :&quot;+ message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Topic测试代码,这里同时测试了反馈机制，需要继承ConfirmCallBack接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class TopicSender implements RabbitTemplate.ConfirmCallback&#123;</div><div class="line"></div><div class="line">//    @Autowired</div><div class="line">//    private AmqpTemplate template;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private RabbitTemplate template;</div><div class="line"></div><div class="line">    public void send()&#123;</div><div class="line">        template.setConfirmCallback(this);</div><div class="line">        CorrelationData data = new CorrelationData(UUID.randomUUID().toString());</div><div class="line">        String message1 = &quot;I am topic.message =====&quot;;</div><div class="line">        template.convertAndSend(&quot;topicExchange&quot;,&quot;topic.message&quot;,message1,data);</div><div class="line">        CorrelationData data1 = new CorrelationData(UUID.randomUUID().toString());</div><div class="line">        String message2 = &quot;I am topic.apple.12312&quot;;</div><div class="line">        template.convertAndSend(&quot;topicExchange&quot;,&quot;topic.messages&quot;,message2,data1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void confirm(CorrelationData correlationData, boolean b, String s) &#123;</div><div class="line">        System.out.println(&quot;sender confirm callback: &quot;+correlationData.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@Component</div><div class="line">@RabbitListener(queues = &quot;topic.messages&quot;)</div><div class="line">public class TopicReceiver2 &#123;</div><div class="line"></div><div class="line">    @RabbitHandler</div><div class="line">    public void say(String mes)&#123;</div><div class="line">        System.out.println(&quot;topic.# receive: &quot;+mes);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@Component</div><div class="line">@RabbitListener(queues = &quot;topic.message&quot;)</div><div class="line">public class TopicReceiver1 &#123;</div><div class="line"></div><div class="line">    @RabbitHandler</div><div class="line">    public void say(String mess)&#123;</div><div class="line">        System.out.println(&quot;topic.message receive: &quot;+mess);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring4.3.x源码阅读笔记-AOP(3)</title>
      <link href="/2017/12/19/spring4-3-x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-AOP-3/"/>
      <url>/2017/12/19/spring4-3-x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-AOP-3/</url>
      
        <content type="html"><![CDATA[<p>Spring AOP部分源码比较复杂，看了书上的内容还是觉得云里雾里，好在这部分的参考资料比较多，感谢原博主。在这里自己整理一下思路。</p><blockquote><p><a href="http://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="external">http://blog.csdn.net/luanlouis/article/details/51155821</a></p><p>《Spring源码深度解析》</p></blockquote><h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><p>切面（Aspect）：类似于OOP中的Class，一个Aspect存放一个系统功能的所有逻辑；</p><p>连接点（Joinpoint）：程序执行过程中的某一事件，如方法被调用时、抛出异常时；</p><p>切入点（Pointcut）：它是一个表达式，用于确定哪些类的哪些函数需要插入横切逻辑；它只精确到函数，究竟要在函数执行的哪个阶段插入横切逻辑，这就由通知的类型决定；</p><p>通知（Advice）：具体的横切逻辑；</p><p>Spring中有四种Advice：</p><p>前置通知（Before Advice）</p><p>后置通知（After Advice）</p><p>返回通知（After Return Advice）</p><p>环绕通知（Around Advice）</p><p>抛出异常后通知（After Throwing Advice）</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm9s3lt0lj30k90guq8h.jpg" alt=""></p><h3 id="自己动手写一个AOP过程"><a href="#自己动手写一个AOP过程" class="headerlink" title="自己动手写一个AOP过程"></a>自己动手写一个AOP过程</h3><p>上面图中使用AOP的方式是我们在写代码时最常见的一种，只需要添加相应的jar包，并在配置文件中声明扫描位置和启动自动注解即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;context:component-scan base-package=&quot;com.sc.aop.impl&quot;/&gt;</div><div class="line">&lt;aop:aspectj-autoproxy/&gt;</div></pre></td></tr></table></figure><p>但是这种写法不利于我们的源码阅读，我们通过代码手动装配一个AOP来打断点看源码</p><blockquote><p><a href="http://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="external">http://blog.csdn.net/luanlouis/article/details/51155821</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public interface TicketService &#123;</div><div class="line"></div><div class="line">    void sellTicket();</div><div class="line">    void inquire();</div><div class="line">    void withdraw();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class RailWayStation implements TicketService &#123;</div><div class="line">    @Override</div><div class="line">    public void sellTicket() &#123;</div><div class="line">        System.out.println(&quot;卖票&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void inquire() &#123;</div><div class="line">        System.out.println(&quot;咨询&quot;);</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void withdraw() &#123;</div><div class="line">        System.out.println(&quot;回执&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">以上是业务逻辑,下面是三个切面类</div><div class="line">public class MyAfter implements AfterReturningAdvice &#123;</div><div class="line">    @Override</div><div class="line">    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;</div><div class="line">        System.out.println(&quot;给你开发票&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class MyBefore implements MethodBeforeAdvice &#123;</div><div class="line">    @Override</div><div class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</div><div class="line">        System.out.println(&quot;询问票价&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public class MyAround implements MethodInterceptor &#123;</div><div class="line">    @Override</div><div class="line">    public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123;</div><div class="line">        System.out.println(&quot;摄像头在360°监控&quot;);</div><div class="line">        Object returnValue = methodInvocation.proceed();</div><div class="line">        System.out.println(&quot;摄像头在360°监控&quot;);</div><div class="line">        return returnValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        RailWayStation service = new RailWayStation();</div><div class="line"></div><div class="line">        //实例化通知</div><div class="line">        Advice before = new MyBefore();</div><div class="line">        Advice after = new MyAfter();</div><div class="line">        Advice around = new MyAround();</div><div class="line"></div><div class="line">        //装配代理bean</div><div class="line">        ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();</div><div class="line">        proxyFactoryBean.setInterfaces(TicketService.class);</div><div class="line">        proxyFactoryBean.setTarget(service);</div><div class="line">        proxyFactoryBean.setProxyTargetClass(true);</div><div class="line"></div><div class="line">        proxyFactoryBean.addAdvice(before);</div><div class="line">        proxyFactoryBean.addAdvice(after);</div><div class="line">        proxyFactoryBean.addAdvice(around);</div><div class="line">        proxyFactoryBean.setProxyTargetClass(false);</div><div class="line"></div><div class="line">        TicketService ticketService = (TicketService) proxyFactoryBean.getObject();</div><div class="line">        ticketService.sellTicket();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">打印结果:</div><div class="line">询问票价</div><div class="line">摄像头在360°监控</div><div class="line">卖票</div><div class="line">摄像头在360°监控</div><div class="line">给你开发票</div></pre></td></tr></table></figure><p>就这样，我们通过创建ProxyFactoryBean，并手动组装了一个Aop过程。可见AOP实现的关键是这个ProxyFactoryBean，那么就从这里入手看源码。</p><h3 id="AOP核心ProxyFactoryBean"><a href="#AOP核心ProxyFactoryBean" class="headerlink" title="AOP核心ProxyFactoryBean"></a>AOP核心ProxyFactoryBean</h3><p>通过这幅图我们就可以理解刚刚main函数中所做的一些配置,我们可以从getObject这一句来进入源码</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmmbjcujqvj30gn0c3whc.jpg" alt="源自网络"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public Object getObject() throws BeansException &#123;</div><div class="line">//初始化一个通知链</div><div class="line">        this.initializeAdvisorChain();</div><div class="line">        if (this.isSingleton()) &#123;</div><div class="line">//生成singlton类型bean的代理</div><div class="line">            return this.getSingletonInstance();</div><div class="line">        &#125; else &#123;</div><div class="line">            if (this.targetName == null) &#123;</div><div class="line">                this.logger.warn(&quot;Using non-singleton proxies with singleton targets is often undesirable. Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return this.newPrototypeInstance();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private synchronized Object getSingletonInstance() &#123;</div><div class="line">        if (this.singletonInstance == null) &#123;</div><div class="line">            this.targetSource = this.freshTargetSource();</div><div class="line">            if (this.autodetectInterfaces &amp;&amp; this.getProxiedInterfaces().length == 0 &amp;&amp; !this.isProxyTargetClass()) &#123;</div><div class="line">//获取要代理的类</div><div class="line">                Class&lt;?&gt; targetClass = this.getTargetClass();</div><div class="line">                if (targetClass == null) &#123;</div><div class="line">                    throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);</div><div class="line">                &#125;</div><div class="line">//设置代理类的接口，所以在main函数中，可以不显式的指定接口，但必须要有接口才行</div><div class="line">                this.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            super.setFrozen(this.freezeProxy);</div><div class="line">//关键方法:创建AOP代理</div><div class="line">//有两种方式：JDK动态代理和CGLIB</div><div class="line">            this.singletonInstance = this.getProxy(this.createAopProxy());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return this.singletonInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</div><div class="line"> //在这里，spring通过判断这三个条件来决定使用JDK动态代理还是CGLIB</div><div class="line"> //1.optimize属性控制cglib是否使用激进的优化策略，使用cglib才有效</div><div class="line"> //2.proxyTargetClss属性默认是false，如果指定为true则使用cglib进行代理</div><div class="line"> //3.hasNoUserSuppliedProxyInterfaces是否存在接口</div><div class="line">        if (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUserSuppliedProxyInterfaces(config)) &#123;</div><div class="line">            return new JdkDynamicAopProxy(config);</div><div class="line">        &#125; else &#123;</div><div class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</div><div class="line">            if (targetClass == null) &#123;</div><div class="line">                throw new AopConfigException(&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                return (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="JDK动态代理实现AOP"><a href="#JDK动态代理实现AOP" class="headerlink" title="JDK动态代理实现AOP"></a>JDK动态代理实现AOP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable&#123;&#125;</div></pre></td></tr></table></figure><p>可以看到该类实现了InvocationHandler这个接口，当我自己实现一个动态代理的时候就会实现这个接口，那么该类最重要的就是invoke方法的内容了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"> public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</div><div class="line">        Object oldProxy = null;</div><div class="line">        boolean setProxyContext = false;</div><div class="line">        TargetSource targetSource = this.advised.targetSource;</div><div class="line">        Class&lt;?&gt; targetClass = null;</div><div class="line">        Object target = null;</div><div class="line"></div><div class="line">        Object retVal;</div><div class="line">        try &#123;</div><div class="line">//实现代理对象的equals方法</div><div class="line">            if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</div><div class="line">                Boolean var20 = this.equals(args[0]);</div><div class="line">                return var20;</div><div class="line">            &#125;</div><div class="line">//实现代理对象的hashCode方法</div><div class="line">            if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</div><div class="line">                Integer var18 = this.hashCode();</div><div class="line">                return var18;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</div><div class="line">                Class var17 = AopProxyUtils.ultimateTargetClass(this.advised);</div><div class="line">                return var17;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (this.advised.opaque || !method.getDeclaringClass().isInterface() || !method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</div><div class="line">                if (this.advised.exposeProxy) &#123;</div><div class="line">                    oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">                    setProxyContext = true;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                target = targetSource.getTarget();</div><div class="line">                if (target != null) &#123;</div><div class="line">                    targetClass = target.getClass();</div><div class="line">                &#125;</div><div class="line">//获取当前方法的拦截器链</div><div class="line">                List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">                if (chain.isEmpty()) &#123;</div><div class="line">//没有拦截器链直接调用切点方法</div><div class="line">                    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">                    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</div><div class="line">                &#125; else &#123;</div><div class="line">//将拦截器链封装到ReflectiveMethodInvocation中</div><div class="line">                    MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</div><div class="line"></div><div class="line">//先执行拦截器链的方法</div><div class="line">                    retVal = invocation.proceed();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Class&lt;?&gt; returnType = method.getReturnType();</div><div class="line"></div><div class="line">                if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</div><div class="line">                    retVal = proxy;</div><div class="line">                &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</div><div class="line">                    throw new AopInvocationException(&quot;Null return value from advice does not match primitive return type for: &quot; + method);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                Object var13 = retVal;</div><div class="line">                return var13;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</div><div class="line">                targetSource.releaseTarget(target);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (setProxyContext) &#123;</div><div class="line">                AopContext.setCurrentProxy(oldProxy);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return retVal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ====</div><div class="line">   public Object proceed() throws Throwable &#123;</div><div class="line">//判断通知方法是否执行完了</div><div class="line">        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123;</div><div class="line">            return this.invokeJoinpoint();</div><div class="line">        &#125; else &#123;</div><div class="line">//获取下一个要执行的拦截器</div><div class="line">            Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);</div><div class="line">//执行拦截器方法</div><div class="line">            if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123;</div><div class="line">                InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice;</div><div class="line">                return dm.methodMatcher.matches(this.method, this.targetClass, this.arguments) ? dm.interceptor.invoke(this) : this.proceed();</div><div class="line">            &#125; else &#123;</div><div class="line">                return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>通过上面的方式，就实现了JDK动态代理的AOP，主要工作就是创建拦截器链，并使用ReflectiveMethodInvocation对象的proceed方法实现拦截器的调用，对目标方法进行前置/后置的增强.</p><h4 id="CGLIB实现AOP"><a href="#CGLIB实现AOP" class="headerlink" title="CGLIB实现AOP"></a>CGLIB实现AOP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> public Object getProxy(ClassLoader classLoader) &#123;</div><div class="line">        if (logger.isDebugEnabled()) &#123;</div><div class="line">            logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">//获取需要代理的目标类</div><div class="line">            Class&lt;?&gt; rootClass = this.advised.getTargetClass();</div><div class="line">            Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);</div><div class="line">            Class&lt;?&gt; proxySuperClass = rootClass;</div><div class="line">            int x;</div><div class="line">            if (ClassUtils.isCglibProxyClass(rootClass)) &#123;</div><div class="line">                proxySuperClass = rootClass.getSuperclass();</div><div class="line">                Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</div><div class="line">                Class[] var5 = additionalInterfaces;</div><div class="line">                int var6 = additionalInterfaces.length;</div><div class="line"></div><div class="line">                for(x = 0; x &lt; var6; ++x) &#123;</div><div class="line">                    Class&lt;?&gt; additionalInterface = var5[x];</div><div class="line">                    this.advised.addInterface(additionalInterface);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">//验证代理类</div><div class="line">            this.validateClassIfNecessary(proxySuperClass, classLoader);</div><div class="line">//配置Enhancer对代理类进行增强</div><div class="line">            Enhancer enhancer = this.createEnhancer();</div><div class="line">            if (classLoader != null) &#123;</div><div class="line">                enhancer.setClassLoader(classLoader);</div><div class="line">                if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) &#123;</div><div class="line">                    enhancer.setUseCache(false);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            enhancer.setSuperclass(proxySuperClass);</div><div class="line">            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));</div><div class="line">            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</div><div class="line">            enhancer.setStrategy(new CglibAopProxy.ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</div><div class="line">//设置拦截器</div><div class="line">            Callback[] callbacks = this.getCallbacks(rootClass);</div><div class="line">            Class&lt;?&gt;[] types = new Class[callbacks.length];</div><div class="line">            for(x = 0; x &lt; types.length; ++x) &#123;</div><div class="line">                types[x] = callbacks[x].getClass();</div><div class="line">            &#125;</div><div class="line">            enhancer.setCallbackFilter(new CglibAopProxy.ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));</div><div class="line">            enhancer.setCallbackTypes(types);</div><div class="line">//生成代理并返回</div><div class="line">            return this.createProxyClassAndInstance(enhancer, callbacks);</div><div class="line">        &#125; catch (CodeGenerationException var9) &#123;</div><div class="line">            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass() + &quot;]: Common causes of this problem include using a final class or a non-visible class&quot;, var9);</div><div class="line">        &#125; catch (IllegalArgumentException var10) &#123;</div><div class="line">            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; + this.advised.getTargetClass() + &quot;]: Common causes of this problem include using a final class or a non-visible class&quot;, var10);</div><div class="line">        &#125; catch (Throwable var11) &#123;</div><div class="line">            throw new AopConfigException(&quot;Unexpected AOP exception&quot;, var11);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>CGLIB中的callback拦截器作用相当于JDK动态代理中的ReflectiveMethodInvocation，我们看一下两者的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    private Callback[] getCallbacks(Class&lt;?&gt; rootClass) throws Exception &#123;</div><div class="line">        boolean exposeProxy = this.advised.isExposeProxy();</div><div class="line">        boolean isFrozen = this.advised.isFrozen();</div><div class="line">        boolean isStatic = this.advised.getTargetSource().isStatic();</div><div class="line">//从名字就可以看出来，将拦截器封装在DynamicAdvisedInterceptor中</div><div class="line">        Callback aopInterceptor = new CglibAopProxy.DynamicAdvisedInterceptor(this.advised);</div><div class="line">        Object targetInterceptor;</div><div class="line">        if (exposeProxy) &#123;</div><div class="line">            targetInterceptor = isStatic ? new CglibAopProxy.StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());</div><div class="line">        &#125; else &#123;</div><div class="line">            targetInterceptor = isStatic ? new CglibAopProxy.StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.DynamicUnadvisedInterceptor(this.advised.getTargetSource());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Callback targetDispatcher = (Callback)(isStatic ? new CglibAopProxy.StaticDispatcher(this.advised.getTargetSource().getTarget()) : new CglibAopProxy.SerializableNoOp());</div><div class="line"> //将拦截器链加入callback</div><div class="line">       Callback[] mainCallbacks = new Callback[]&#123;aopInterceptor, (Callback)targetInterceptor, new CglibAopProxy.SerializableNoOp(), targetDispatcher, this.advisedDispatcher, new CglibAopProxy.EqualsInterceptor(this.advised), new CglibAopProxy.HashCodeInterceptor(this.advised)&#125;;</div><div class="line">        Callback[] callbacks;</div><div class="line">        if (isStatic &amp;&amp; isFrozen) &#123;</div><div class="line">            Method[] methods = rootClass.getMethods();</div><div class="line">            Callback[] fixedCallbacks = new Callback[methods.length];</div><div class="line">            this.fixedInterceptorMap = new HashMap(methods.length);</div><div class="line"></div><div class="line">            for(int x = 0; x &lt; methods.length; ++x) &#123;</div><div class="line">                List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);</div><div class="line">                fixedCallbacks[x] = new CglibAopProxy.FixedChainStaticTargetInterceptor(chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());</div><div class="line">                this.fixedInterceptorMap.put(methods[x].toString(), x);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];</div><div class="line">            System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);</div><div class="line">            System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);</div><div class="line">            this.fixedInterceptorOffset = mainCallbacks.length;</div><div class="line">        &#125; else &#123;</div><div class="line">            callbacks = mainCallbacks;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return callbacks;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>CGLIB中的DynamicAdvisedInterceptor拦截器，通过实现MethodInterceptor接口的intercept方法来完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</div><div class="line">            Object oldProxy = null;</div><div class="line">            boolean setProxyContext = false;</div><div class="line">            Class&lt;?&gt; targetClass = null;</div><div class="line">            Object target = null;</div><div class="line"></div><div class="line">            Object var15;</div><div class="line">            try &#123;</div><div class="line">                if (this.advised.exposeProxy) &#123;</div><div class="line">                    oldProxy = AopContext.setCurrentProxy(proxy);</div><div class="line">                    setProxyContext = true;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                target = this.getTarget();</div><div class="line">                if (target != null) &#123;</div><div class="line">                    targetClass = target.getClass();</div><div class="line">                &#125;</div><div class="line">//获取拦截器链</div><div class="line">                List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</div><div class="line">                Object retVal;</div><div class="line">                if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</div><div class="line">                    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</div><div class="line">//拦截器链为空，执行原方法</div><div class="line">                    retVal = methodProxy.invoke(target, argsToUse);</div><div class="line">                &#125; else &#123;</div><div class="line">//否则执行代理方法</div><div class="line">                    retVal = (new CglibAopProxy.CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy)).proceed();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                retVal = CglibAopProxy.processReturnType(proxy, target, method, retVal);</div><div class="line">                var15 = retVal;</div><div class="line">            &#125; finally &#123;</div><div class="line">                if (target != null) &#123;</div><div class="line">                    this.releaseTarget(target);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (setProxyContext) &#123;</div><div class="line">                    AopContext.setCurrentProxy(oldProxy);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return var15;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>JDK动态代理与CGLIB的实现方式虽然不同，但是思想确实相通的。都是通过封装拦截器链，对原有方法进行拦截调用。</p><h3 id="拦截器链"><a href="#拦截器链" class="headerlink" title="拦截器链"></a>拦截器链</h3><p>我们回过头来看main函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">proxyFactoryBean.addAdvice(before);</div><div class="line">proxyFactoryBean.addAdvice(after);</div><div class="line">proxyFactoryBean.addAdvice(around);</div></pre></td></tr></table></figure><p>各种Advice本质上来说都是一个拦截器,在Spring的底层，会把我们定义的各个Adivce分别包裹成一个MethodInterceptor,这些Advice按照加入Advised顺序，构成一个AdvisorChain,也就是拦截器链。<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmmdsdb3lkj30gm09cwjb.jpg" alt="来源于博客"></p><p>方法请求会依次穿过这些拦截器，调用拦截器中的方法后就会放行(proceed)。<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fmmdw85tgfj30gl0ciwin.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> spring4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring4.3.x源码阅读笔记-XML配置文件解析(2)</title>
      <link href="/2017/12/18/spring4-3-x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90-2/"/>
      <url>/2017/12/18/spring4-3-x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90-2/</url>
      
        <content type="html"><![CDATA[<h3 id="验证XML"><a href="#验证XML" class="headerlink" title="验证XML"></a>验证XML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</div><div class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">       http://www.springframework.org/schema/context</div><div class="line">       http://www.springframework.org/schema/context/spring-context.xsd</div><div class="line">       http://www.springframework.org/schema/mvc</div><div class="line">       http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;</div></pre></td></tr></table></figure><p>我们在编写spring.xml文件时都会在头部加入这样一段代码，这段代码就是通过xsd模式验证XML文件结构的正确性。另一种验证方法就是DTD模式验证，不过现在很少使用了。读取XML之前，spring会验证XML文件内的标签是否符合要求，符合要求才会进行下一步。XML的错误验证，一般在编译器就可以发现。</p><h3 id="获取Document对象"><a href="#获取Document对象" class="headerlink" title="获取Document对象"></a>获取Document对象</h3><p>XML通过验证后，spring会读取配置文件，读取的过程XML会转化为InputSream对象，并最终转换为一个Document对象</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="解析BeanDefinations"><a href="#解析BeanDefinations" class="headerlink" title="解析BeanDefinations"></a>解析BeanDefinations</h3><p>将配置文件转换为Document对象后，主要的工作就是提取并注册Document对象中的Bean。可以通过一段代码看看Document提取Bean的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">    public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</div><div class="line">    //初始化一个Reader</div><div class="line">        BeanDefinitionDocumentReader documentReader = this.createBeanDefinitionDocumentReader();</div><div class="line">    //统计已经注册的bean的个数</div><div class="line">        int countBefore = this.getRegistry().getBeanDefinitionCount();</div><div class="line">    //加载及注册bean</div><div class="line">        documentReader.registerBeanDefinitions(doc, this.createReaderContext(resource));</div><div class="line">    //记录本次加载bean的个数</div><div class="line">        return this.getRegistry().getBeanDefinitionCount() - countBefore;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</div><div class="line">        this.readerContext = readerContext;</div><div class="line">        this.logger.debug(&quot;Loading bean definitions&quot;);</div><div class="line">        Element root = doc.getDocumentElement();</div><div class="line">        this.doRegisterBeanDefinitions(root);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   protected void doRegisterBeanDefinitions(Element root) &#123;</div><div class="line">        BeanDefinitionParserDelegate parent = this.delegate;</div><div class="line">        this.delegate = this.createDelegate(this.getReaderContext(), root, parent);</div><div class="line">        if (this.delegate.isDefaultNamespace(root)) &#123;</div><div class="line">        //profile属性可以在web.xml中配置，用于切换开发环境或者生产环境</div><div class="line">            String profileSpec = root.getAttribute(&quot;profile&quot;);</div><div class="line">            if (StringUtils.hasText(profileSpec)) &#123;</div><div class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, &quot;,; &quot;);</div><div class="line">                if (!this.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</div><div class="line">                    if (this.logger.isInfoEnabled()) &#123;</div><div class="line">                        this.logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec + &quot;] not matching: &quot; + this.getReaderContext().getResource());</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">//预处理，方法为空，为扩展而设计</div><div class="line">        this.preProcessXml(root);</div><div class="line"> //解析bean</div><div class="line">        this.parseBeanDefinitions(root, this.delegate);</div><div class="line"> //后处理，方法为空，为扩展而设计</div><div class="line">        this.postProcessXml(root);</div><div class="line">        this.delegate = parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">   protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">        if (delegate.isDefaultNamespace(root)) &#123;</div><div class="line">            NodeList nl = root.getChildNodes();</div><div class="line"></div><div class="line">            for(int i = 0; i &lt; nl.getLength(); ++i) &#123;</div><div class="line">                Node node = nl.item(i);</div><div class="line">                if (node instanceof Element) &#123;</div><div class="line">                    Element ele = (Element)node;</div><div class="line">                    //将要解析的bean分为两类，一类是默认标签的解析</div><div class="line">                    if (delegate.isDefaultNamespace(ele)) &#123;</div><div class="line">                        this.parseDefaultElement(ele, delegate);</div><div class="line">                    &#125; else &#123;</div><div class="line">                    //自定义标签的解析</div><div class="line">                        delegate.parseCustomElement(ele);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            delegate.parseCustomElement(root);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> //默认标签解析</div><div class="line"></div><div class="line"> //功能很清楚，可以对四种默认标签进行解析:import，alias，bean，beans</div><div class="line"> //import 功能是可以将一个spring配置文件拆分成多个，同个import合并在一起，有利于功能的划分。</div><div class="line"> //alias可以指定一个bean的别名</div><div class="line"> //beans 嵌套进行解析就可以了</div><div class="line"> //bean 解析的主角，最为复杂</div><div class="line">    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">        if (delegate.nodeNameEquals(ele, &quot;import&quot;)) &#123;</div><div class="line">            this.importBeanDefinitionResource(ele);</div><div class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;alias&quot;)) &#123;</div><div class="line">            this.processAliasRegistration(ele);</div><div class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;bean&quot;)) &#123;</div><div class="line">            this.processBeanDefinition(ele, delegate);</div><div class="line">        &#125; else if (delegate.nodeNameEquals(ele, &quot;beans&quot;)) &#123;</div><div class="line">            this.doRegisterBeanDefinitions(ele);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">   protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">   //这个方法让bdHolder包含配置文件的各种属性</div><div class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</div><div class="line">        if (bdHolder != null) &#123;</div><div class="line">   //如果有自定义的属性，对其进行解析</div><div class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">   //对bdHolder进行注册</div><div class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());</div><div class="line">            &#125; catch (BeanDefinitionStoreException var5) &#123;</div><div class="line">                this.getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, var5);</div><div class="line">            &#125;</div><div class="line">//发出响应事件，通知相关监听器，bean加载完成</div><div class="line">            this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>可以发现spring的源码每个方法的分工都非常明确，层层嵌套非常深入。首先要明确BeanDefination的继承关系，BeanDefination只是一个接口，抽象类AbstractBeanDefination实现了这个接口，并且有三个具体的实现类继承自这个抽象类。继续来看最后这个方法的内部实现。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fml5kcytl3j30ir0b7gmz.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</div><div class="line">//获取ID属性</div><div class="line">        String id = ele.getAttribute(&quot;id&quot;);</div><div class="line">//解析name属性</div><div class="line">        String nameAttr = ele.getAttribute(&quot;name&quot;);</div><div class="line">//解析alias属性</div><div class="line">        List&lt;String&gt; aliases = new ArrayList();</div><div class="line">        if (StringUtils.hasLength(nameAttr)) &#123;</div><div class="line">            String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, &quot;,; &quot;);</div><div class="line">            aliases.addAll(Arrays.asList(nameArr));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String beanName = id;</div><div class="line">        if (!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</div><div class="line">            beanName = (String)aliases.remove(0);</div><div class="line">            if (this.logger.isDebugEnabled()) &#123;</div><div class="line">                this.logger.debug(&quot;No XML &apos;id&apos; specified - using &apos;&quot; + beanName + &quot;&apos; as bean name and &quot; + aliases + &quot; as aliases&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (containingBean == null) &#123;</div><div class="line">            this.checkNameUniqueness(beanName, aliases, ele);</div><div class="line">        &#125;</div><div class="line">//关键方法  其他标签的信息的封装</div><div class="line">        AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean);</div><div class="line">        if (beanDefinition != null) &#123;</div><div class="line">            if (!StringUtils.hasText(beanName)) &#123;</div><div class="line">                try &#123;</div><div class="line">                    if (containingBean != null) &#123;</div><div class="line">//如果bean解析成功，但没有name属性，则生成一个name</div><div class="line">                        beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, this.readerContext.getRegistry(), true);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        beanName = this.readerContext.generateBeanName(beanDefinition);</div><div class="line">                        String beanClassName = beanDefinition.getBeanClassName();</div><div class="line">                        if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</div><div class="line">                            aliases.add(beanClassName);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (this.logger.isDebugEnabled()) &#123;</div><div class="line">                        this.logger.debug(&quot;Neither XML &apos;id&apos; nor &apos;name&apos; specified - using generated bean name [&quot; + beanName + &quot;]&quot;);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (Exception var9) &#123;</div><div class="line">                    this.error(var9.getMessage(), ele);</div><div class="line">                    return null;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            String[] aliasesArray = StringUtils.toStringArray(aliases);</div><div class="line">            return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</div><div class="line">        &#125; else &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //其他标签信息的封装方法</div><div class="line">   public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) &#123;</div><div class="line">        this.parseState.push(new BeanEntry(beanName));</div><div class="line">        String className = null;</div><div class="line">        if (ele.hasAttribute(&quot;class&quot;)) &#123;</div><div class="line">            className = ele.getAttribute(&quot;class&quot;).trim();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            String parent = null;</div><div class="line">//解析parent属性</div><div class="line">            if (ele.hasAttribute(&quot;parent&quot;)) &#123;</div><div class="line">                parent = ele.getAttribute(&quot;parent&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            AbstractBeanDefinition bd = this.createBeanDefinition(className, parent);</div><div class="line">//解析默认bean的各种属性</div><div class="line">            this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</div><div class="line">            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, &quot;description&quot;));</div><div class="line">//解析meta标签</div><div class="line">            this.parseMetaElements(ele, bd);</div><div class="line">//解析lookup-method标签</div><div class="line">            this.parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</div><div class="line">//解析replace-method标签</div><div class="line">            this.parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</div><div class="line">//解析构造函数标签</div><div class="line">            this.parseConstructorArgElements(ele, bd);</div><div class="line">//解析property标签</div><div class="line">            this.parsePropertyElements(ele, bd);</div><div class="line">//解析Qualifier标签</div><div class="line">            this.parseQualifierElements(ele, bd);</div><div class="line">            bd.setResource(this.readerContext.getResource());</div><div class="line">            bd.setSource(this.extractSource(ele));</div><div class="line">            AbstractBeanDefinition var7 = bd;</div><div class="line">            return var7;</div><div class="line">        &#125; catch (ClassNotFoundException var13) &#123;</div><div class="line">            this.error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, var13);</div><div class="line">        &#125; catch (NoClassDefFoundError var14) &#123;</div><div class="line">            this.error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, var14);</div><div class="line">        &#125; catch (Throwable var15) &#123;</div><div class="line">            this.error(&quot;Unexpected failure during bean definition parsing&quot;, ele, var15);</div><div class="line">        &#125; finally &#123;</div><div class="line">            this.parseState.pop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    //解析默认bean的属性，通过字符串就可以看出在解析哪些属性，不做注释</div><div class="line">   public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName, BeanDefinition containingBean, AbstractBeanDefinition bd) &#123;</div><div class="line">        if (ele.hasAttribute(&quot;singleton&quot;)) &#123;</div><div class="line">            this.error(&quot;Old 1.x &apos;singleton&apos; attribute in use - upgrade to &apos;scope&apos; declaration&quot;, ele);</div><div class="line">        &#125; else if (ele.hasAttribute(&quot;scope&quot;)) &#123;</div><div class="line">            bd.setScope(ele.getAttribute(&quot;scope&quot;));</div><div class="line">        &#125; else if (containingBean != null) &#123;</div><div class="line">            bd.setScope(containingBean.getScope());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ele.hasAttribute(&quot;abstract&quot;)) &#123;</div><div class="line">            bd.setAbstract(&quot;true&quot;.equals(ele.getAttribute(&quot;abstract&quot;)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String lazyInit = ele.getAttribute(&quot;lazy-init&quot;);</div><div class="line">        if (&quot;default&quot;.equals(lazyInit)) &#123;</div><div class="line">            lazyInit = this.defaults.getLazyInit();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bd.setLazyInit(&quot;true&quot;.equals(lazyInit));</div><div class="line">        String autowire = ele.getAttribute(&quot;autowire&quot;);</div><div class="line">        bd.setAutowireMode(this.getAutowireMode(autowire));</div><div class="line">        String dependencyCheck = ele.getAttribute(&quot;dependency-check&quot;);</div><div class="line">        bd.setDependencyCheck(this.getDependencyCheck(dependencyCheck));</div><div class="line">        String autowireCandidate;</div><div class="line">        if (ele.hasAttribute(&quot;depends-on&quot;)) &#123;</div><div class="line">            autowireCandidate = ele.getAttribute(&quot;depends-on&quot;);</div><div class="line">            bd.setDependsOn(StringUtils.tokenizeToStringArray(autowireCandidate, &quot;,; &quot;));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        autowireCandidate = ele.getAttribute(&quot;autowire-candidate&quot;);</div><div class="line">        String destroyMethodName;</div><div class="line">        if (!&quot;&quot;.equals(autowireCandidate) &amp;&amp; !&quot;default&quot;.equals(autowireCandidate)) &#123;</div><div class="line">            bd.setAutowireCandidate(&quot;true&quot;.equals(autowireCandidate));</div><div class="line">        &#125; else &#123;</div><div class="line">            destroyMethodName = this.defaults.getAutowireCandidates();</div><div class="line">            if (destroyMethodName != null) &#123;</div><div class="line">                String[] patterns = StringUtils.commaDelimitedListToStringArray(destroyMethodName);</div><div class="line">                bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ele.hasAttribute(&quot;primary&quot;)) &#123;</div><div class="line">            bd.setPrimary(&quot;true&quot;.equals(ele.getAttribute(&quot;primary&quot;)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ele.hasAttribute(&quot;init-method&quot;)) &#123;</div><div class="line">            destroyMethodName = ele.getAttribute(&quot;init-method&quot;);</div><div class="line">            if (!&quot;&quot;.equals(destroyMethodName)) &#123;</div><div class="line">                bd.setInitMethodName(destroyMethodName);</div><div class="line">            &#125;</div><div class="line">        &#125; else if (this.defaults.getInitMethod() != null) &#123;</div><div class="line">            bd.setInitMethodName(this.defaults.getInitMethod());</div><div class="line">            bd.setEnforceInitMethod(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ele.hasAttribute(&quot;destroy-method&quot;)) &#123;</div><div class="line">            destroyMethodName = ele.getAttribute(&quot;destroy-method&quot;);</div><div class="line">            bd.setDestroyMethodName(destroyMethodName);</div><div class="line">        &#125; else if (this.defaults.getDestroyMethod() != null) &#123;</div><div class="line">            bd.setDestroyMethodName(this.defaults.getDestroyMethod());</div><div class="line">            bd.setEnforceDestroyMethod(false);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ele.hasAttribute(&quot;factory-method&quot;)) &#123;</div><div class="line">            bd.setFactoryMethodName(ele.getAttribute(&quot;factory-method&quot;));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (ele.hasAttribute(&quot;factory-bean&quot;)) &#123;</div><div class="line">            bd.setFactoryBeanName(ele.getAttribute(&quot;factory-bean&quot;));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return bd;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>至此，我们就解析了Bean标签所有的属性。再让我们回顾一下那个最初的入口方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</div><div class="line">   //这个方法让bdHolder包含配置文件的各种属性</div><div class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</div><div class="line">        if (bdHolder != null) &#123;</div><div class="line">   //如果有自定义的属性，对其进行解析</div><div class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</div><div class="line"></div><div class="line">            try &#123;</div><div class="line">   //对bdHolder进行注册</div><div class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry());</div><div class="line">            &#125; catch (BeanDefinitionStoreException var5) &#123;</div><div class="line">                this.getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, var5);</div><div class="line">            &#125;</div><div class="line">//发出响应事件，通知相关监听器，bean加载完成</div><div class="line">            this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>此时完成了第一行代码的工作，如果有需要会进入装饰bean方法，由于工作中没有使用过自定义的bean属性需要装饰，所以到下一行代码，对hdHolder进行注册。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">    public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123;</div><div class="line">        String beanName = definitionHolder.getBeanName();</div><div class="line">        //根据bean name属性进行注册</div><div class="line">        registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</div><div class="line">        String[] aliases = definitionHolder.getAliases();</div><div class="line">        if (aliases != null) &#123;</div><div class="line">            String[] var4 = aliases;</div><div class="line">            int var5 = aliases.length;</div><div class="line"></div><div class="line">            for(int var6 = 0; var6 &lt; var5; ++var6) &#123;</div><div class="line">                String alias = var4[var6];</div><div class="line">       //注册所有别名</div><div class="line">                registry.registerAlias(beanName, alias);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123;</div><div class="line">        Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</div><div class="line">        Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</div><div class="line">        if (beanDefinition instanceof AbstractBeanDefinition) &#123;</div><div class="line">            try &#123;</div><div class="line">//对BeanDefination的一些属性进行校验</div><div class="line">                ((AbstractBeanDefinition)beanDefinition).validate();</div><div class="line">            &#125; catch (BeanDefinitionValidationException var9) &#123;</div><div class="line">                throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Validation of bean definition failed&quot;, var9);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">//检查这个bean是否已经被注册</div><div class="line">        BeanDefinition oldBeanDefinition = (BeanDefinition)this.beanDefinitionMap.get(beanName);</div><div class="line">        if (oldBeanDefinition != null) &#123;</div><div class="line">            if (!this.isAllowBeanDefinitionOverriding()) &#123;</div><div class="line">                throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, &quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &apos;&quot; + beanName + &quot;&apos;: There is already [&quot; + oldBeanDefinition + &quot;] bound.&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</div><div class="line">                if (this.logger.isWarnEnabled()) &#123;</div><div class="line">                    this.logger.warn(&quot;Overriding user-defined bean definition for bean &apos;&quot; + beanName + &quot;&apos; with a framework-generated bean definition: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125; else if (!beanDefinition.equals(oldBeanDefinition)) &#123;</div><div class="line">                if (this.logger.isInfoEnabled()) &#123;</div><div class="line">                    this.logger.info(&quot;Overriding bean definition for bean &apos;&quot; + beanName + &quot;&apos; with a different definition: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125; else if (this.logger.isDebugEnabled()) &#123;</div><div class="line">                this.logger.debug(&quot;Overriding bean definition for bean &apos;&quot; + beanName + &quot;&apos; with an equivalent definition: replacing [&quot; + oldBeanDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</div><div class="line">            &#125;</div><div class="line">//这里因为是存在相同beanName的情况</div><div class="line">//将bean覆盖到beanDefinitionMap，这是一个ConcurrentHashMap，Key是beanName，value就是beanDefination</div><div class="line">            this.beanDefinitionMap.put(beanName, beanDefinition);</div><div class="line">        &#125; else &#123;</div><div class="line">            if (this.hasBeanCreationStarted()) &#123;</div><div class="line">                Map var4 = this.beanDefinitionMap;</div><div class="line"></div><div class="line">//这里是bean不存在的情况，控制并发访问，将bean放入Map中</div><div class="line">                synchronized(this.beanDefinitionMap) &#123;</div><div class="line">                    this.beanDefinitionMap.put(beanName, beanDefinition);</div><div class="line">                    List&lt;String&gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1);</div><div class="line">                    updatedDefinitions.addAll(this.beanDefinitionNames);</div><div class="line">                    updatedDefinitions.add(beanName);</div><div class="line">                    this.beanDefinitionNames = updatedDefinitions;</div><div class="line">                    if (this.manualSingletonNames.contains(beanName)) &#123;</div><div class="line">                        Set&lt;String&gt; updatedSingletons = new LinkedHashSet(this.manualSingletonNames);</div><div class="line">                        updatedSingletons.remove(beanName);</div><div class="line">                        this.manualSingletonNames = updatedSingletons;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                this.beanDefinitionMap.put(beanName, beanDefinition);</div><div class="line">                this.beanDefinitionNames.add(beanName);</div><div class="line">                this.manualSingletonNames.remove(beanName);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            this.frozenBeanDefinitionNames = null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (oldBeanDefinition != null || this.containsSingleton(beanName)) &#123;</div><div class="line"> //重置所以beanName的缓存</div><div class="line">            this.resetBeanDefinition(beanName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>到此就完成了bean的注册。这部分只是对spring默认标签的解析过程，自定义解析的过程的方法并不相同，但思想都大同小异。通过这部分代码，就可以对spring中xml文件解析出bean到内存中这个过程做到心中有数，后面要做的就是bean的加载。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fml6ssdvk4j30qk09mgn6.jpg" alt=""></p><blockquote><p>参考《Spring源码深度解析》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring4.3.x源码阅读笔记-从hello world开始(1)</title>
      <link href="/2017/12/18/spring4-3-x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/12/18/spring4-3-x%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>环境:Spring4.3.5、IDEA</p><p>网络上很多对spring源码讲解的博客基本上使用的都是spring3的版本，跟着做了一下发现最开始的XMLBeanFactory类已经废弃了，spring4中使用最频繁的是ClassPathXmlApplicationContext,所以自己也打打断点看代码，看看有什么变化。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>基于maven的spring4.3项目，创建一个User类，给一个简单的构造函数。在classpath下新建一个spring的xml文件，配置User Bean。最后创建一个类，在主方法中获取类的信息，观察调用栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">1.</div><div class="line">public class User &#123;</div><div class="line">    private int id;</div><div class="line">    private String email;</div><div class="line">    private String password;</div><div class="line">    private String username;</div><div class="line">    private String role;</div><div class="line">    private int status;</div><div class="line">    private Date regTime;</div><div class="line"></div><div class="line"></div><div class="line">    public User()&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public User(String username)&#123;</div><div class="line">        this.username = username;</div><div class="line">    &#125;</div><div class="line">    //get/set省略</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">2.</div><div class="line">    &lt;bean class=&quot;com.sc.model.User&quot; id=&quot;user&quot;&gt;</div><div class="line">        &lt;constructor-arg value=&quot;hello world&quot;/&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line"></div><div class="line">3.</div><div class="line">    public class Start &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-mybatis.xml&quot;);</div><div class="line">        User user = (User) applicationContext.getBean(&quot;user&quot;);</div><div class="line">        System.out.println(user.getUsername());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码正确的结果会打印出:hello world</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><p>###ApplicationContext</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</div><div class="line">throws BeansException &#123;</div><div class="line"></div><div class="line">super(parent);</div><div class="line">setConfigLocations(configLocations);</div><div class="line">if (refresh) &#123;</div><div class="line">refresh();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个方法就是我们测试代码的第一行的源码，和spring3的内容一样，首先支持以数组的方式设置spring配置文件，也就是支持读取多个spirng的配置文件。重要的还是refresh方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">public void refresh() throws BeansException, IllegalStateException &#123;</div><div class="line">synchronized (this.startupShutdownMonitor) &#123;</div><div class="line">// 准备上下文的刷新，实际上只记录了启动时间，</div><div class="line">//方法initPropertySources和validateRequiredProperties方法都是空的，可以留给用户自己扩展</div><div class="line">prepareRefresh();</div><div class="line"></div><div class="line">//初始化BeanFactory,并进行xml文件的读取，完成了配置文件的解析,这里就是spring3中的XmlBeanFactory方法，</div><div class="line">//也就是说ApplicationContext 是对XmlBeanFactory的一种增强，所以在spring4中废弃了XmlBeanFactory</div><div class="line">//这里实际上进行了很多的操作，再后面细说</div><div class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line"></div><div class="line">//对BeanFactory功能进行填充:</div><div class="line">//1.增加对SPEL的支持:如#&#123;&#125;</div><div class="line">//2.增加对属性编辑的支持:对日期属性注入的支持</div><div class="line">//3.设置了可忽略的接口</div><div class="line">//4.注册一些固定的依赖</div><div class="line">//5.增加对AspectJ支持</div><div class="line">//6.将相关环境变量以及属性注册以单例模式支持</div><div class="line">prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">try &#123;</div><div class="line"></div><div class="line">//下面三步都是对beanFacotry进行加载后处理</div><div class="line">//可以通过编写类实现BeanFactoryPostProcessor对配置文件中的bean进行拦截修改</div><div class="line">postProcessBeanFactory(beanFactory);</div><div class="line">invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">registerBeanPostProcessors(beanFactory);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// i18n处理</div><div class="line">initMessageSource();</div><div class="line"></div><div class="line">//初始化事件广播</div><div class="line">//1.如果用户自己定义，就用用户的</div><div class="line">//2.否则就使用默认的事件广播</div><div class="line">//用于存放监听器并在合适的时候调用监听器</div><div class="line">initApplicationEventMulticaster();</div><div class="line"></div><div class="line">// 空方法，留给子类扩展</div><div class="line">onRefresh();</div><div class="line"></div><div class="line">// 注册监听器到广播器</div><div class="line">registerListeners();</div><div class="line"></div><div class="line">//完成beanFactory的初始化，主要是非lazy-init属性的bean进行提前实例化</div><div class="line">finishBeanFactoryInitialization(beanFactory);</div><div class="line"></div><div class="line">//完成刷新,初始化lifeCycleProcessor管理bean的生命周期</div><div class="line">//激活监听器</div><div class="line">finishRefresh();</div><div class="line">&#125;</div><div class="line"></div><div class="line">catch (BeansException ex) &#123;</div><div class="line">if (logger.isWarnEnabled()) &#123;</div><div class="line">logger.warn(&quot;Exception encountered during context initialization - &quot; +</div><div class="line">&quot;cancelling refresh attempt: &quot; + ex);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Destroy already created singletons to avoid dangling resources.</div><div class="line">destroyBeans();</div><div class="line"></div><div class="line">// Reset &apos;active&apos; flag.</div><div class="line">cancelRefresh(ex);</div><div class="line"></div><div class="line">// Propagate exception to caller.</div><div class="line">throw ex;</div><div class="line">&#125;</div><div class="line"></div><div class="line">finally &#123;</div><div class="line">// Reset common introspection caches in Spring&apos;s core, since we</div><div class="line">// might not ever need metadata for singleton beans anymore...</div><div class="line">resetCommonCaches();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过一个refresh方法，完成了BeanFactory的实例化，剩下的就是通过get方法获取到bean就可以得到bean的属性信息。但是这个方法只能让我们大概了解BeanFactory的过程，其中还有很多具体的细节要分析。</p><h3 id="容器基础：BeanFacoty"><a href="#容器基础：BeanFacoty" class="headerlink" title="容器基础：BeanFacoty"></a>容器基础：BeanFacoty</h3><p>通过测试类方法的第一行代码，返回一个ApplicationContext对象。我们在refresh方法中，大部分操作都是围绕BeanFactory这个对象来进行的，下面的图给出了ApplicationContext和BeanFactory的关系。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmkz6i4ovcj314b0act9q.jpg" alt=""></p><p>接着看测试类的第二行代码，是一个getBean方法，其实现方法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line">  protected &lt;T&gt; T doGetBean(String name, Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123;</div><div class="line">      final String beanName = this.transformedBeanName(name);</div><div class="line">      Object sharedInstance = this.getSingleton(beanName);</div><div class="line">      Object bean;</div><div class="line">      //检查是否已经创建了bean</div><div class="line">      if (sharedInstance != null &amp;&amp; args == null) &#123;</div><div class="line">          if (this.logger.isDebugEnabled()) &#123;</div><div class="line">              if (this.isSingletonCurrentlyInCreation(beanName)) &#123;</div><div class="line">                  this.logger.debug(&quot;Returning eagerly cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos; that is not fully initialized yet - a consequence of a circular reference&quot;);</div><div class="line">              &#125; else &#123;</div><div class="line">                  this.logger.debug(&quot;Returning cached instance of singleton bean &apos;&quot; + beanName + &quot;&apos;&quot;);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)null);</div><div class="line">      &#125; else &#123;</div><div class="line">          if (this.isPrototypeCurrentlyInCreation(beanName)) &#123;</div><div class="line">              throw new BeanCurrentlyInCreationException(beanName);</div><div class="line">          &#125;</div><div class="line">  //若当前BeanFactory没有此bean，到父容器中查找</div><div class="line">          BeanFactory parentBeanFactory = this.getParentBeanFactory();</div><div class="line">          if (parentBeanFactory != null &amp;&amp; !this.containsBeanDefinition(beanName)) &#123;</div><div class="line">              String nameToLookup = this.originalBeanName(name);</div><div class="line">              if (args != null) &#123;</div><div class="line">                  return parentBeanFactory.getBean(nameToLookup, args);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              return parentBeanFactory.getBean(nameToLookup, requiredType);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          if (!typeCheckOnly) &#123;</div><div class="line">              this.markBeanAsCreated(beanName);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          try &#123;</div><div class="line">          //获取BeanDefination</div><div class="line">              final RootBeanDefinition mbd = this.getMergedLocalBeanDefinition(beanName);</div><div class="line">              this.checkMergedBeanDefinition(mbd, beanName, args);</div><div class="line">          //查看初始化依赖的bean</div><div class="line">              String[] dependsOn = mbd.getDependsOn();</div><div class="line">              String[] var11;</div><div class="line">              if (dependsOn != null) &#123;</div><div class="line">                  var11 = dependsOn;</div><div class="line">                  int var12 = dependsOn.length;</div><div class="line"></div><div class="line">                  for(int var13 = 0; var13 &lt; var12; ++var13) &#123;</div><div class="line">                      String dep = var11[var13];</div><div class="line">                      if (this.isDependent(beanName, dep)) &#123;</div><div class="line">                          throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &apos;&quot; + beanName + &quot;&apos; and &apos;&quot; + dep + &quot;&apos;&quot;);</div><div class="line">                      &#125;</div><div class="line"></div><div class="line">                      this.registerDependentBean(dep, beanName);</div><div class="line">                      this.getBean(dep);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">//创建单例模式bean</div><div class="line">              if (mbd.isSingleton()) &#123;</div><div class="line">                  sharedInstance = this.getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123;</div><div class="line">                      public Object getObject() throws BeansException &#123;</div><div class="line">                          try &#123;</div><div class="line">                              return AbstractBeanFactory.this.createBean(beanName, mbd, args);</div><div class="line">                          &#125; catch (BeansException var2) &#123;</div><div class="line">                              AbstractBeanFactory.this.destroySingleton(beanName);</div><div class="line">                              throw var2;</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;);</div><div class="line">                  bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</div><div class="line">         //创建原型bean</div><div class="line">              &#125; else if (mbd.isPrototype()) &#123;</div><div class="line">                  var11 = null;</div><div class="line"></div><div class="line">                  Object prototypeInstance;</div><div class="line">                  try &#123;</div><div class="line">                      this.beforePrototypeCreation(beanName);</div><div class="line">                      prototypeInstance = this.createBean(beanName, mbd, args);</div><div class="line">                  &#125; finally &#123;</div><div class="line">                      this.afterPrototypeCreation(beanName);</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  bean = this.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</div><div class="line">          //否则创建其他scope类型的bean,如request session gloable-session</div><div class="line">              &#125; else &#123;</div><div class="line">                  String scopeName = mbd.getScope();</div><div class="line">                  Scope scope = (Scope)this.scopes.get(scopeName);</div><div class="line">                  if (scope == null) &#123;</div><div class="line">                      throw new IllegalStateException(&quot;No Scope registered for scope name &apos;&quot; + scopeName + &quot;&apos;&quot;);</div><div class="line">                  &#125;</div><div class="line"></div><div class="line">                  try &#123;</div><div class="line">                      Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123;</div><div class="line">                          public Object getObject() throws BeansException &#123;</div><div class="line">                              AbstractBeanFactory.this.beforePrototypeCreation(beanName);</div><div class="line"></div><div class="line">                              Object var1;</div><div class="line">                              try &#123;</div><div class="line">                                  var1 = AbstractBeanFactory.this.createBean(beanName, mbd, args);</div><div class="line">                              &#125; finally &#123;</div><div class="line">                                  AbstractBeanFactory.this.afterPrototypeCreation(beanName);</div><div class="line">                              &#125;</div><div class="line"></div><div class="line">                              return var1;</div><div class="line">                          &#125;</div><div class="line">                      &#125;);</div><div class="line">                      bean = this.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</div><div class="line">                  &#125; catch (IllegalStateException var21) &#123;</div><div class="line">                      throw new BeanCreationException(beanName, &quot;Scope &apos;&quot; + scopeName + &quot;&apos; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, var21);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125; catch (BeansException var23) &#123;</div><div class="line">              this.cleanupAfterBeanCreationFailure(beanName);</div><div class="line">              throw var23;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">//创建之后，如果有需要就进行类型转换</div><div class="line">      if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</div><div class="line">          try &#123;</div><div class="line">              return this.getTypeConverter().convertIfNecessary(bean, requiredType);</div><div class="line">          &#125; catch (TypeMismatchException var22) &#123;</div><div class="line">              if (this.logger.isDebugEnabled()) &#123;</div><div class="line">                  this.logger.debug(&quot;Failed to convert bean &apos;&quot; + name + &quot;&apos; to required type &apos;&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;&apos;&quot;, var22);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</div><div class="line">          &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">     //否则，直接返回bean</div><div class="line">          return bean;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>这段代码虽然很长，但是条例非常清楚，非常佩服代码的作者，在变量命名、方法的封装上都值得学习。经过此方法，就获得了指定的bean，然后可以再测试类中强转为pojo，然后调用pojo的get方法就可以获得属性信息了。</p><blockquote><p>参考《Spring源码深度解析》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> spring4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-ConcurrentHashMap(6)</title>
      <link href="/2017/12/17/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-ConcurrentHashMap-6/"/>
      <url>/2017/12/17/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-ConcurrentHashMap-6/</url>
      
        <content type="html"><![CDATA[<p>无论是HashMap还是ConcurrentHashMap都是日常使用和面试中的热点问题，所以必须整理一波。而且java8中对于HashMap的改动还是相当大的。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>HashMap的结构是由数组+链表+红黑树组成的</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmjuws4d1vj30e70doq3x.jpg" alt=""></p><p>HashMap的主体是一个Node[]，也就是一个Node数组，图中每个蓝色的球就是一个Node，Node的结构就是一个键值对:Node<k,v>。顾名思义，HashMap通过hash算法将键值对映射到一个位置，那么具体怎么做呢。</k,v></p><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>hashMap的hash方法并没有我们想象的那么简单。并不是只经过一次hashcode计算，而是把hashcode再与hashcode的高16位进行一次抑或运算。这个如果大家把这个过程自己写一下就发现，这样做这个HashMap里面的元素的位置会尽量分布均匀。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                   boolean evict) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">        if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">            n = (tab = resize()).length;</div><div class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">            tab[i] = newNode(hash, key, value, null);</div><div class="line">        else &#123;</div><div class="line">            Node&lt;K,V&gt; e; K k;</div><div class="line">            if (p.hash == hash &amp;&amp;</div><div class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                e = p;</div><div class="line">            else if (p instanceof TreeNode)</div><div class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">            else &#123;</div><div class="line">                for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                    if ((e = p.next) == null) &#123;</div><div class="line">                        p.next = newNode(hash, key, value, null);</div><div class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                            treeifyBin(tab, hash);</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        break;</div><div class="line">                    p = e;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (e != null) &#123; // existing mapping for key</div><div class="line">                V oldValue = e.value;</div><div class="line">                if (!onlyIfAbsent || oldValue == null)</div><div class="line">                    e.value = value;</div><div class="line">                afterNodeAccess(e);</div><div class="line">                return oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ++modCount;</div><div class="line">        if (++size &gt; threshold)</div><div class="line">            resize();</div><div class="line">        afterNodeInsertion(evict);</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>put和get是Hashmap最常用的操作了，JAVA8对hashmap进行了优化，最主要的一点就是当链表的长度大于等于8时，链表就会变成一个红黑树来提高效率。我们看一下代码思路:<br>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p><blockquote><p>摘自<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">https://tech.meituan.com/java-hashmap.html</a></p></blockquote><h4 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h4><p>我们知道当hashmap的键值对个数增加的时候，hashmap会自动进行扩容。什么时候扩容当然我们是可以控制的，就是通过hashmap的构造函数:initSize和loadFactor,默认构造参数初始大小为16，负载因子为0.75。也就是当Node个数超过16*0.75=12个的时候就会自动扩容，扩容的大小是当前大小的一倍。这里要主要，resize的时候是键值对的数量超过12，而不是数组中的node个数超过12。这里扩容后会对原HashMap中的元素重新hash，但是效率很高，因为直接扩大二倍，所以原有node的位置要么不变，要么当前位置+扩容大小，复杂度为O(1)。</p><p>通过get方法我们知道，当链表长度&gt;=8会变成一个红黑树。java8之前,在最极端的情况下,对链表的查询复杂度是O(n),而红黑树则降低到了O(logn)，大大提高了put和get的效率。</p><p>那么当链表长度减少时，红黑树会怎么变化呢。Hashmap也有默认参数，当红黑树中元素的个数&lt;=6，红黑树恢复为链表状态。</p><h4 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h4><p>说道hashmap总会说道线程安全这个问题，因为在hashmap的get、put方法中并没有对操作进行加锁处理。另一方面，当并发对hashmap进行修改，触发hashMap的resize方法，如果多个线程同时检测到元素个数超过数组大小*loadFactor，这样就会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。</p><h4 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h4><p>应尽量减少resize操作，所以在可以预计hashMap大小的情况小，应该给hashmap一个初始值，防止频繁的resize，对于负载因子，应当尽量少的改动。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>java8对concurrentHashMap也做了较大的修改，放弃了之前的段锁概念(segment lock)而改用更加高效的CAS操作实现并发hashmap。与HashMap相同的是ConcurrentHashMap的结构也是数组+链表+红黑树,有一个最重要的不同点就是ConcurrentHashMap不允许key或value为null值。CAS需要一个状态标识符，源码中使用了sizeCtrl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private transient volatile int sizeCtl;</div><div class="line"></div><div class="line">1. 负数代表正在进行初始化或扩容操作</div><div class="line">2. -1代表正在初始化</div><div class="line">3. -N 表示有N-1个线程正在进行扩容操作</div><div class="line">4. 正数或0代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小</div></pre></td></tr></table></figure><p>我们还是从get/put/resize的方法中关注ConcurrentHashMap如何保证线程安全</p><h4 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    return putVal(key, value, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/** Implementation for put and putIfAbsent */</div><div class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class="line">    if (key == null || value == null) throw new NullPointerException();</div><div class="line">    int hash = spread(key.hashCode());</div><div class="line">    int binCount = 0;</div><div class="line">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class="line">        if (tab == null || (n = tab.length) == 0)</div><div class="line">            ①tab = initTable();</div><div class="line">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class="line">            if (②casTabAt(tab, i, null,</div><div class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class="line">                break;                   // no lock when adding to empty bin</div><div class="line">        &#125;</div><div class="line">        ③else if ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        else &#123;</div><div class="line">            V oldVal = null;</div><div class="line">            synchronized (f) &#123;</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        binCount = 1;</div><div class="line">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            if (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                if (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            if ((e = e.next) == null) &#123;</div><div class="line">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, null);</div><div class="line">                                break;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = 2;</div><div class="line">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != null) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            if (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (binCount != 0) &#123;</div><div class="line">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                if (oldVal != null)</div><div class="line">                    return oldVal;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addCount(1L, binCount);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先可以看到在put方法中，如果table为null,首先会初始化这个map，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">       Node&lt;K,V&gt;[] tab; int sc;</div><div class="line">       while ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">           if ((sc = sizeCtl) &lt; 0)</div><div class="line">               Thread.yield(); // lost initialization race; just spin</div><div class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</div><div class="line">               try &#123;</div><div class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</div><div class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class="line">                       table = tab = nt;</div><div class="line">                       sc = n - (n &gt;&gt;&gt; 2);</div><div class="line">                   &#125;</div><div class="line">               &#125; finally &#123;</div><div class="line">                   sizeCtl = sc;</div><div class="line">               &#125;</div><div class="line">               break;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       return tab;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>代码比较短，首先会判断sizeCtl<0，表示正在初始化或者在扩容，那么久yield()方法礼让等待，否则就设置状态为-1,表示正在初始化。最后finally中的操作表示sizectl设置为容量大小*0.75，因为上面sc =="" n="" -(n="">&gt;&gt;2)，表示n减去n右移2位，也就是n-n<em>1/2</em>1/2 = 0.75n,所以这里和HashMap中的负载因子和容量大小是对应的。<br>继续回到put方法的②:</0，表示正在初始化或者在扩容，那么久yield()方法礼让等待，否则就设置状态为-1,表示正在初始化。最后finally中的操作表示sizectl设置为容量大小*0.75，因为上面sc></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</div><div class="line">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里，如果没有发生碰撞，使用CAS的方式对该位置赋值，会比较内存中的值与你指定的这个值是否相等，如果相等才接受你的修改，否则拒绝你的修改。</p><p>如果该节点发生碰撞，则继续③:检查是否处于扩容状态，如果是则调用helptransfer方法帮助扩容,首先拿到这个nextTable对象，调用transfer方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</div><div class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</div><div class="line">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</div><div class="line">            int rs = resizeStamp(tab.length);</div><div class="line">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class="line">                   (sc = sizeCtl) &lt; 0) &#123;</div><div class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div class="line">                    break;</div><div class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</div><div class="line">                    transfer(tab, nextTab);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return nextTab;</div><div class="line">        &#125;</div><div class="line">        return table;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>ConcurrentHashMap的扩容是允许多线程进行的，当一个线程发现当前的Table正在被扩容，它也会参与进来，帮助进行扩容操作。<br>如果没有在进行扩容操作，会继续进入一个sychronized代码块，在这一部分，会判断是链表节点还是红黑树节点，并对其进行赋值，这点与Hashmap一致。跳出循环后会检验链表长度是不是超过了阈值，需要进行结构转换。</p><p>最后一句代码调用了addCount函数:<br>以CAS的方式把当前ConcurrentHashMap的元素个数+1,更新baseCount的值，检测是否进行扩容。</p><h4 id="transfor扩容方法"><a href="#transfor扩容方法" class="headerlink" title="transfor扩容方法"></a>transfor扩容方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class="line">    int n = tab.length, stride;</div><div class="line">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class="line">        stride = MIN_TRANSFER_STRIDE; // subdivide range</div><div class="line">    if (nextTab == null) &#123;            // initiating</div><div class="line">        try &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</div><div class="line">            nextTab = nt;</div><div class="line">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class="line">            sizeCtl = Integer.MAX_VALUE;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        nextTable = nextTab;</div><div class="line">        transferIndex = n;</div><div class="line">    &#125;</div><div class="line">    ①int nextn = nextTab.length;</div><div class="line">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class="line">    ②boolean advance = true;</div><div class="line">    boolean finishing = false; // to ensure sweep before committing nextTab</div><div class="line">    for (int i = 0, bound = 0;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; int fh;</div><div class="line">        ③while (advance) &#123;</div><div class="line">            int nextIndex, nextBound;</div><div class="line">            if (--i &gt;= bound || finishing)</div><div class="line">                advance = false;</div><div class="line">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</div><div class="line">                i = -1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">            else if (U.compareAndSwapInt</div><div class="line">                     (this, TRANSFERINDEX, nextIndex,</div><div class="line">                      nextBound = (nextIndex &gt; stride ?</div><div class="line">                                   nextIndex - stride : 0))) &#123;</div><div class="line">                bound = nextBound;</div><div class="line">                i = nextIndex - 1;</div><div class="line">                advance = false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</div><div class="line">            int sc;</div><div class="line">            ④if (finishing) &#123;</div><div class="line">                nextTable = null;</div><div class="line">                table = nextTab;</div><div class="line">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            ⑤if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class="line">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class="line">                    return;</div><div class="line">                finishing = advance = true;</div><div class="line">                i = n; // recheck before commit</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ⑥else if ((f = tabAt(tab, i)) == null)</div><div class="line">            advance = casTabAt(tab, i, null, fwd);</div><div class="line">        ⑦else if ((fh = f.hash) == MOVED)</div><div class="line">            advance = true; // already processed</div><div class="line">        ⑧else &#123;</div><div class="line">            synchronized (f) &#123;</div><div class="line">                if (tabAt(tab, i) == f) &#123;</div><div class="line">                    Node&lt;K,V&gt; ln, hn;</div><div class="line">                    if (fh &gt;= 0) &#123;</div><div class="line">                        int runBit = fh &amp; n;</div><div class="line">                        Node&lt;K,V&gt; lastRun = f;</div><div class="line">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class="line">                            int b = p.hash &amp; n;</div><div class="line">                            if (b != runBit) &#123;</div><div class="line">                                runBit = b;</div><div class="line">                                lastRun = p;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        if (runBit == 0) &#123;</div><div class="line">                            ln = lastRun;</div><div class="line">                            hn = null;</div><div class="line">                        &#125;</div><div class="line">                        else &#123;</div><div class="line">                            hn = lastRun;</div><div class="line">                            ln = null;</div><div class="line">                        &#125;</div><div class="line">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class="line">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class="line">                            if ((ph &amp; n) == 0)</div><div class="line">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class="line">                            else</div><div class="line">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class="line">                        &#125;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                    else if (f instanceof TreeBin) &#123;</div><div class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class="line">                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</div><div class="line">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</div><div class="line">                        int lc = 0, hc = 0;</div><div class="line">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</div><div class="line">                            int h = e.hash;</div><div class="line">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class="line">                                (h, e.key, e.val, null, null);</div><div class="line">                            if ((h &amp; n) == 0) &#123;</div><div class="line">                                if ((p.prev = loTail) == null)</div><div class="line">                                    lo = p;</div><div class="line">                                else</div><div class="line">                                    loTail.next = p;</div><div class="line">                                loTail = p;</div><div class="line">                                ++lc;</div><div class="line">                            &#125;</div><div class="line">                            else &#123;</div><div class="line">                                if ((p.prev = hiTail) == null)</div><div class="line">                                    hi = p;</div><div class="line">                                else</div><div class="line">                                    hiTail.next = p;</div><div class="line">                                hiTail = p;</div><div class="line">                                ++hc;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div class="line">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</div><div class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class="line">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class="line">                        setTabAt(nextTab, i, ln);</div><div class="line">                        setTabAt(nextTab, i + n, hn);</div><div class="line">                        setTabAt(tab, i, fwd);</div><div class="line">                        advance = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们在上面put操作的时候就可以看出来，transfer扩容方法是支持并发的，虽然思想和Hashmap中的差不多，但是具体操作起来就复杂了很多。</p><blockquote><p>参考<a href="http://blog.csdn.net/u010723709/article/details/48007881" target="_blank" rel="external">http://blog.csdn.net/u010723709/article/details/48007881</a></p></blockquote><p>首先在①处，初始化了一个新的table长度为原有table长度的两倍。接着又new 了一个ForwardingNode。这个类用于连接两个table的节点类，它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找。②处初始化了一个advance变量，此变量是并发扩容的关键属性，如果等于true，说明这个节点已经处理过。从③开始进入了这个方法的主体，通过i–依次遍历原hash表中的节点。④处在于如果所有的节点都已经完成复制工作，就把nextTable赋值给table，清空临时对象nextTable，若没有完成复制工作，将会继续下面的代码继续复制</p><p>⑤处将sizeCtl-1表示一个新的线程通过helftransfer方法进入transfer方法帮助扩容。</p><p>⑥表示当前节点为空，设置为一个forwad节点，继续向后遍历</p><p>⑦遍历到ForwardingNode节点，说明此节点被处理过了，直接跳过</p><p>⑧该节点可能是链表节点也可能是树节点，进入sychronized代码块中进行复制</p><ol><li>如果是链表节点,把链表分表拆分为，hash&amp;n等于0和不等于0的，然后分别放在新表的i和i+n位置,个人认为原博主的配图有误，所以自己分析了一下这里</li><li>如果是树节点，与链表的处理方式相同</li></ol><p>多线程又是如何实现的呢？<br>    遍历到ForwardingNode节点((fh = f.hash) == MOVED)，说明此节点被处理过了，直接跳过。这是控制并发扩容的核心。由于给节点上了锁，只允许当前线程完成此节点的操作，处理完毕后，将对应值设为ForwardingNode（fwd），其他线程看到forward，直接向后遍历。如此便完成了多线程的复制工作，也解决了线程安全问题。</p><p>concurrentHashMap确实有些复杂的让人窒息，关键性操作的代码真的很长，看下来需要一些耐心，但是我终于大概明白了ConcurrentHashMap的原理，以后还要经常拿来看一看。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-JMM(5)</title>
      <link href="/2017/12/17/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-JMM/"/>
      <url>/2017/12/17/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-JMM/</url>
      
        <content type="html"><![CDATA[<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>在写这篇博客之前参考了大量的博客和书籍，但是个人总感觉理解不来，在这里记录下自己的看法，可能不对。</p><p>在并发编程中，我们要解决的关键性问题就是线程通信和同步的问题——那么就有两种结局方案，共享内存和消息传递。共享内存的方式就是各个线程在一个公共的内存区域中共同读写变量，消息传递则是通过显示的方法交换信息。</p><p>所以JAVA对内存进行了一种抽象，形成了java内存模型JMM。这种模型可以说就是为了方便多线程编程而设计。JMM的设计说起来其实很简单，各个线程拥有自己的本地内存，线程之间的共享变量存储在<br>主存中，为了提高效率，各自的本地内存中还保留了一份共享变量的拷贝。本地内存是一个抽象的概念，并不存在，它在物理上覆盖了缓存区，寄存器以及各种优化技术。</p><p>因此JAVA中线程之间的通信可以使用以下方式：</p><ol><li>一个线程将数据写入到主存中</li><li>另一个线程去主存获取这个数据</li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmjrum6j9lj30ae0be74i.jpg" alt=""></p><p>也就是说线程之间依靠在主存之中共享变量实现了线程之间的通信，虽然说起来这个过程很简单，但我们看的还是太过于宏观，屏蔽了太多底层的东西。因为我们对于多线程的编程都停留在java语言这种高级语言的层面，但是java语言底层会和操作系统、内存、寄存器这些硬件打交道。而这些硬件由于读写速率有很大差别，因此会有一些对编程语言的优化策略，并不是每条指令都是顺序执行的。由于存在这种硬件优化策略，所以java语言就要保证它的多线程编程所得出的结果是程序员所希望的结果，也就是对编程人员的可见性。所以为了保证这种对编程人员的可见性，java并发编程就需要抽象一种既能保证执行结果又能让程序设计人员无需关心底层的内存模型，这就是JMM。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="从PIPELINE看JMM"><a href="#从PIPELINE看JMM" class="headerlink" title="从PIPELINE看JMM"></a>从PIPELINE看JMM</h3><p>学过计算机组成原理或计算机体系结构的同学可能见过这幅图</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmjsbm9tn9j30n704dwfn.jpg" alt=""></p><p>这就是把一条机器指令分为了五个原子的步骤去执行IF表示取指令，WB表示写回内存。下一条指令会在前一条写回内存后才会执行，这么这个看来就是一个线程安全的模型了。只可惜，现实中的计算机指令流水线并不会这样设计，因为这样的效率实在是太低了。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmjsfmdpkaj30ke05idi4.jpg" alt=""></p><p>实际上的流水线是这样的一种模型，在第一个位置空出来后就可以执行第二条了。这样才能最大限度的利用资源。那么为了提高效率，问题也就随之而来了，这样的一种模型就会造成一种数据依赖的情况，有可能第二条指令需要第一条指令的运算结果,出现这种情况最快的优化就是让IF在EX之后执行，通过通道直接获取到EX之后的值，而不必等到写回内存再去内存中调用。其实这种情况分细了来说就是流水线中遇到的WAR,WAW等读写冲突现象。</p><p>说完了计组中pipeline的思想，那么我们把JMM作一下类比，我们可以把JMM当做处理pipeline的容器，java代码在编译成字节码之后，为了解决读写冲突也需要设定一系列的机制。这些机制就包括设定内存屏障，happens-before原则，顺序一致性模型等等。如果你知道pipeline对机器指令读写冲突的解决方案，从字面上你就能理解jmm这些机制的作用。</p><p>所以知道了以上几种jmm的设计原则之后，就有了volatile的内存语义，lock的内存语义等等。它们讲述这些不同的线程之间通信和同步的方式在jmm中是怎样实现的。其实归根结底就是想解决在经历过种种编译优化之后怎样保持各个线程之间的数据依赖问题。</p><p>其实出现这些问题最根本的原因是人们对提升计算机效率的永恒追求，因为追求性能，出现了经典的五层流水线模型。因为追求性能出现了java并发编程。于是在硬件和软件层面都对追求性能而带来的数据冲突问题作出了解决，虽然具体做法不同但思想都是想通的。</p><p>这时我又想起了大学老师对我们说过的话：计算机这个东西在硬件和软件方面是相通的，双方的思想都可以拿来互相借鉴，想通了就很简单。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-Lock(4)</title>
      <link href="/2017/12/13/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-Lock/"/>
      <url>/2017/12/13/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-Lock/</url>
      
        <content type="html"><![CDATA[<p>我们可以先来看看有哪些类实现了Lock接口，有我们很熟悉的ReentrantLock、ReadLock、WriteLock、ConcurrentHashMap中的Segment内部类以及在JAVA8中新加入的StampedLock，接下来一一分析一下这些锁的实现。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmf9asltb1j30ny05c40l.jpg" alt=""></p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>可重入锁也是JUC中的一位元老级的人物了。可重入锁，顾名思义就是就是支持一个线程对资源的重复加锁，此外可重入锁还支持公平或非公平加锁。<br><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fmfb64413cj30bb0dfwfo.jpg" alt=""></p><p>ReentrantLock的类结构如图所示，一个内部抽象类Sync继承自AQS，作为一个同步器。NonfairSync和FairSync都继承Sync用于实现不同的加锁方法。ReentrantLock类中的方法都是通过调用内部类的方法实现的加锁与释放。因为AQS是用来构建锁或其他同步器的基本框架。分析ReentrantLock的核心就是加锁的方法，根据代码，公平锁和非公锁都实现各自的Lock和tryAcquire方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//非公平锁</div><div class="line"> static final class NonfairSync extends Sync &#123;</div><div class="line">        final void lock() &#123;</div><div class="line">            if (compareAndSetState(0, 1))</div><div class="line">                setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">            else</div><div class="line">                acquire(1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            return nonfairTryAcquire(acquires);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//公平锁</div><div class="line">    static final class FairSync extends Sync &#123;</div><div class="line"></div><div class="line">        final void lock() &#123;</div><div class="line">            acquire(1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (!hasQueuedPredecessors() &amp;&amp;</div><div class="line">                    compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0)</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h4 id="不同的加锁方式"><a href="#不同的加锁方式" class="headerlink" title="不同的加锁方式"></a>不同的加锁方式</h4><p>假设有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status–.锁会记录当前持有的线程。当A线程拥有锁的时候，status&gt;0. B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。如果A线程恰好释放，–status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁，C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是<strong><em><em>非公平锁</em></em></strong>。B在C之前尝试获取锁，而最终是C抢到了锁。</p><p><strong><em><em>公平锁</em></em></strong>：C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁。</p><h4 id="可重入的实现原理"><a href="#可重入的实现原理" class="headerlink" title="可重入的实现原理:"></a>可重入的实现原理:</h4><p>两个类实现的tryAquire()方法也是不同的。非公平锁由于是可重入锁的默认状态，所以它的tryAquire方法就是父类Sync的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">            final Thread current = Thread.currentThread();</div><div class="line">            int c = getState();</div><div class="line">            if (c == 0) &#123;</div><div class="line">                if (compareAndSetState(0, acquires)) &#123;</div><div class="line">                    setExclusiveOwnerThread(current);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">                int nextc = c + acquires;</div><div class="line">                if (nextc &lt; 0) // overflow</div><div class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">                setState(nextc);</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>通过判断当前线程是否获是取得锁的线程，来决定操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true。<br>公平锁与非公平锁实现此方法的差别就在于hasQueuedPredecessors()方法，该方法表示加入了同步队列的当前节点，是否还有前驱节点，如果返回true，表示它不是头结点，不能取到锁，继续等待，只有等到前驱节点释放的时候它才可以获取锁。</p><p>既然重入锁时会增加同步状态值，那么释放锁时就必须将同步状态值减为0才可以算作释放锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    int c = getState() - releases;</div><div class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        throw new IllegalMonitorStateException();</div><div class="line">    boolean free = false;</div><div class="line">    if (c == 0) &#123;</div><div class="line">        free = true;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    return free;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果锁被获取了n次，那么前n-1次release都会返回false。同步状态值为0时，设置占有线程为null，并返回true，释放锁。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>一般我们都会称这个锁为读写锁，从名字也可以看出，读写锁也是支持重入的，默认支持非公平。读写锁的特性为通过分离读锁和写锁，使得并发性有很大的提高。读锁在同一时刻允许多个线程访问，但有写锁线程访问时，所有的读线程和其他写线程都被阻塞。读写锁的结果如图所示:<br><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmfd7i92n3j30c306qwfc.jpg" alt=""></p><p>它的实现同样依赖于Sync自定义同步器，由于读锁和写锁要分开计数，那么在只有一个状态值的情况下怎么计算读写锁的数量呢。由于java跨平台的特性，int类型的状态值始终是32位，于是设计者将状态值的低16位标识写状态，高16位标识读状态，如00..0011 00..0011表示读状态3，写状态3表示重入了三次读锁，重入了三次写锁。我们还是重点关注它的获取锁的代码。</p><h4 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1️⃣</div><div class="line">  public void lock() &#123;</div><div class="line">       sync.acquire(1);</div><div class="line">  &#125;</div><div class="line">2️⃣</div><div class="line"> public final void acquire(int arg) &#123;</div><div class="line">     if (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">3️⃣</div><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       int c = getState();</div><div class="line">       int w = exclusiveCount(c);</div><div class="line">       if (c != 0) &#123;</div><div class="line">      // (Note: if c != 0 and w == 0 then shared count != 0)</div><div class="line">       if (w == 0 || current != getExclusiveOwnerThread())</div><div class="line">          return false;</div><div class="line">       if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class="line">          throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">          // Reentrant acquire</div><div class="line">       setState(c + acquires);</div><div class="line">         return true;</div><div class="line">      &#125;</div><div class="line">     if (writerShouldBlock() ||</div><div class="line">        !compareAndSetState(c, c + acquires))</div><div class="line">          return false;</div><div class="line">     setExclusiveOwnerThread(current);</div><div class="line">         return true;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>首先是WriteLock内部类调用了Sync的acquire方法，acquire方法其实是一个自旋等待的过程。关键在于tryAcquire方法，该方法有一个if判断当前是否有读线程存在，如果存在则不能加写锁，因为读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下加写锁，那读锁程序无法感知到写锁的存在，读出的数据就可能是错的。因此加写锁时读锁必须全部释放，已经获取到写锁是阻塞其他全部线程。</p><h4 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">protected final int tryAcquireShared(int unused) &#123;</div><div class="line">    Thread current = Thread.currentThread();</div><div class="line">    int c = getState();</div><div class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</div><div class="line">        getExclusiveOwnerThread() != current)</div><div class="line">        return -1;</div><div class="line">    int r = sharedCount(c);</div><div class="line">    if (!readerShouldBlock() &amp;&amp;</div><div class="line">        r &lt; MAX_COUNT &amp;&amp;</div><div class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class="line">        if (r == 0) &#123;</div><div class="line">            firstReader = current;</div><div class="line">            firstReaderHoldCount = 1;</div><div class="line">        &#125; else if (firstReader == current) &#123;</div><div class="line">            firstReaderHoldCount++;</div><div class="line">        &#125; else &#123;</div><div class="line">            HoldCounter rh = cachedHoldCounter;</div><div class="line">            if (rh == null || rh.tid != getThreadId(current))</div><div class="line">                cachedHoldCounter = rh = readHolds.get();</div><div class="line">            else if (rh.count == 0)</div><div class="line">                readHolds.set(rh);</div><div class="line">            rh.count++;</div><div class="line">        &#125;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return fullTryAcquireShared(current);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段代码的主要逻辑首先获取了当前读锁的重入次数，当没有写锁在执行并且状态值&lt;MAX_COUNT时以CAS的方式设置状态值，如果没有获取到读锁，就加入到一个链中循环获取。</p><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p>读写锁支持对写锁的降级操作，意思是当前线程持有写锁，先获取到读锁，随后释放写锁的过程。分段进行锁的释放则不属于锁降级,记录一段锁降级操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public void processData()&#123;</div><div class="line">       //读锁获取</div><div class="line">       readLock.lock();</div><div class="line"></div><div class="line">       if(!update)&#123;</div><div class="line">           //必须先释放读锁</div><div class="line">           readLock.unlock();</div><div class="line"></div><div class="line">           //锁降级从获取写锁开始</div><div class="line">          writeLock.lock();</div><div class="line">          try &#123;</div><div class="line">                   if(!update)&#123;</div><div class="line">                      //准备数据流程（略）</div><div class="line">                       update=true;</div><div class="line">                   &#125;</div><div class="line">                   //获取读锁。在写锁持有期间获取读锁</div><div class="line">                   //此处获取读锁，是为了防止，当释放写锁后，又有一个线程T获取锁，对数据进行改变，而当前线程下面对改变的数据无法感知。</div><div class="line">                   //如果获取了读锁，则线程T则被阻塞，直到当前线程释放了读锁，那个T线程才有可能获取写锁。</div><div class="line">                   readLock.lock();</div><div class="line">               &#125;finally&#123;</div><div class="line">                   //释放写锁</div><div class="line">                   writeLock.unlock();</div><div class="line">               &#125;</div><div class="line">           //锁降级完成</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       try &#123;</div><div class="line">           //使用数据的流程</div><div class="line">       &#125; finally&#123;</div><div class="line">           //释放读锁</div><div class="line">           readLock.unlock();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fmffawoo85j30ar04kwer.jpg" alt=""></p><p>StampedLock是JAVA8中新加入的一种锁,旨在优化ReentrantReadWriteLock在读线程正在进行时会阻塞写线程的持锁。其中心思想是:在读锁存在是不应该一直阻塞写锁，而是应该让写线程写入数据，同时读线程重新读。因为在使用读写锁的场合，大部分的时间都是读线程在读取数据，有可能造成写线程的饥饿(Starvation)。由于现在参考资料较少:还是先翻译一下Doug Lea的注释吧。</p><hr><p>StampedLock(标记锁，以下简称SL)具有三种读写模式。SL的状态由一个version和一个mode组成。获取锁的方法会返回一个stamp 获取锁的方法会返回一个stamp， 这个stamp表示和控制锁状态的获取。若返回值为0则表示加锁失败，锁的释放和降级操作需要stamp作为参数，若参数不匹配则返回失败。下面介绍三种读写模式:</p><h4 id="写模式"><a href="#写模式" class="headerlink" title="写模式"></a>写模式</h4><p><strong><em>writeLock</em></strong>方法会因为独占式访问而阻塞后续进程,该方法返回一个stamp用于在<strong><em>UnlockWrite</em></strong>方法中释放锁。定时和非定时的tryWriteLock方法同样提供这种机制。当写线程持锁，不可以获取读锁，并且所有的乐观读的验证也会失败。</p><h4 id="读模式"><a href="#读模式" class="headerlink" title="读模式"></a>读模式</h4><p><strong><em>readLock</em></strong>方法会可能会阻塞非独占式的访问，返回一个stamp用于<strong><em>unlockRead</em></strong>方法。计时和非计时的<strong><em>tryReadLock</em></strong>方法同样支持这种机制</p><h4 id="乐观读模式"><a href="#乐观读模式" class="headerlink" title="乐观读模式"></a>乐观读模式</h4><p><strong><em>tryOptimisticRead</em></strong>方法只有在当前线程没有在写模式下，才会返回一个非零的stamp值。<strong><em>validate</em></strong>方法会返回true，当获取到stamp之后锁没有在写模式下被获取。这种模式可以说是一种非常脆弱的读锁，可以随时被写锁打破。  乐观读锁用在只读代码的片段中可以减少争用并提高吞吐量。但由于这种模式天生脆弱，所以使用的前提是你足够了解它，因为乐观读可能是非连续的。</p><p>一个官方的Demo关于乐观锁的部分 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 乐观读锁（tryOptimisticRead）</div><div class="line">    double distanceFromOrigin() &#123;</div><div class="line"></div><div class="line">        // 尝试获取乐观读锁（1）</div><div class="line">        long stamp = sl.tryOptimisticRead();</div><div class="line">        // 将全部变量拷贝到方法体栈内（2）</div><div class="line">        double currentX = x, currentY = y;</div><div class="line">        // 检查在（1）获取到读锁票据后，锁有没被其他写线程排它性抢占（3）</div><div class="line">        if (!sl.validate(stamp)) &#123;</div><div class="line">            // 如果被抢占则获取一个共享读锁（悲观获取）（4）</div><div class="line">            stamp = sl.readLock();</div><div class="line">            try &#123;</div><div class="line">                // 将全部变量拷贝到方法体栈内（5）</div><div class="line">                currentX = x;</div><div class="line">                currentY = y;</div><div class="line">            &#125; finally &#123;</div><div class="line">                // 释放共享读锁（6）</div><div class="line">                sl.unlockRead(stamp);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 返回计算结果（7）</div><div class="line">        return Math.sqrt(currentX * currentX + currentY * currentY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">作者：今天你不奋斗明天你就落后</div><div class="line">链接：http://www.jianshu.com/p/b3e9539ab7ae</div></pre></td></tr></table></figure></p><p>代码（1）首先尝试获取乐观读锁，如果当前没有其它线程获取到了写锁，那么（1）会返回一个非0的stamp用来表示版本信息，代码（2）拷贝变量到本地方法栈里面，代码（3）检查在（1）获取到的票据是否还有效，之所以还要在此校验是因为代码（1）获取读锁时候并没有通过CAS操作修改锁的状态而是简单的通过与或操作返回了一个版本信息，这里校验是看在在获取版本信息到现在的时间段里面是否有其他线程持有了写锁，如果有则之前获取的版本信息就无效了。这里如果校验成功则执行（7）使用本地方法栈里面的值进行计算然后返回。需要注意的是在代码（3)校验成功后，代码（7）计算中其他线程可能获取到了写锁并且修改了x,y的值，而当前线程执行代码（7）进行计算时候采用的才是对修改前值的拷贝，也就是操作的值是对之前值的一个拷贝，并不是新的值。另外还有个问题，代码（2)和（3）能否互换，答案是不能，假设位置换了，那么首先执行validate，假如验证通过了，要拷贝x,y值到本地方法栈，而在拷贝的过程中很有可能其他线程已经修改了x,y中的一个，这就造成了数据的不一致性了。那么你可能会问，那不交换(2)和（3）时候在拷贝x,y值到本地方法栈里面时候也会存在其他线程修改了x,y中的一个值那，这个确实会存在，但是，别忘了拷贝后还有一道validate,如果这时候有线程修改了x,y中的值，那么肯定是有线程在调用validate前sl.tryOptimisticRead后获取了写锁，那么validate时候就会失败。现在应该明白了吧，这也是乐观读设计的精妙之处也是使用时候容易出问题的地方。下面继续分析validate失败后会执行代码（4）获取悲观读锁，如果这时候其他线程持有写锁则代码（4）会导致的当前线程阻塞直到其它线程释放了写锁。获取到读锁后，代码（5）拷贝变量到本地方法栈，然后就是代码（6）释放了锁，拷贝的时候由于加了读锁在拷贝期间其它线程获取写锁时候会被阻塞，这保证了数据的一致性。最后代码（7）使用方法栈里面数据计算返回，同理这里在计算时候使用的数据也可能不是最新的，其它写线程可能已经修改过原来的x,y值了。</p><p>总体来说，相对于ReentrantReadWriteLock，由于乐观读锁并不需要CAS设置状态，而只是简单的测试，因此在高并发条件下会有更好的性能。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-AQS(3)</title>
      <link href="/2017/12/09/JAVA%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-AQS/"/>
      <url>/2017/12/09/JAVA%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-AQS/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AQS是AbstractQueuedSynchronizer的缩写，是用来实现一个锁的底层框架。<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fma8k3ufacj30kf0e7n00.jpg" alt=""></p><p>为什么要了解AQS(队列同步器)呢？因为我们在并发编程的时候很可能用到锁，而AQS与锁的实现密切相关。可是在图中我们并没有看到AQS与Lock产生直接关联，这是因为在每个锁内部都封装了一个抽象类Sync，而sync继承自AQS，如ReentranLock：<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fma97wfi6tj30y10810w3.jpg" alt=""></p><p>AQS是JUC中Lock的实现关键，是实现锁或者自定义一个同步组件的基本框架，它使用了一个volatile int state作为同步状态，通过内置的FIFO队列(CLH)完成线程排队工作。AQS同事支持独占式获取同步状态，也支持共享式获取同步状态，以实现不同组件。Lock通过AQS框架，隐藏了具体的实现细节而与用户的交互使用接口，大大简化了锁的实现方式。它封装了线程、挂起唤醒的内部运作，我们只需要通过设置AQS的state值来控制他的线程挂起和唤醒的运作路径，就可以实现我们的同步器类了。</p><p>AQS提供的方法可分为三类:</p><ol><li>独占式获取/释放状态</li><li>共享式获取/释放状态</li><li>查询同步队列情况</li></ol><p>通过以下代码我们就可以简单实现一个互斥锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public class mutex &#123;</div><div class="line">    Sync sync = new Sync();</div><div class="line">    public void lock()&#123;</div><div class="line">        sync.tryAcquire(1);</div><div class="line">    &#125;</div><div class="line">    public void unlock()&#123;</div><div class="line">        sync.tryRelease(0);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static class Sync extends AbstractQueuedSynchronizer&#123;</div><div class="line">        @Override</div><div class="line">        protected boolean isHeldExclusively() &#123;</div><div class="line">            return getState() == 1;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected boolean tryAcquire(int arg) &#123;</div><div class="line">            if(compareAndSetState(0,1))&#123;</div><div class="line">                setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        protected boolean tryRelease(int arg) &#123;</div><div class="line">            if(getState()==0)&#123;</div><div class="line">                throw  new IllegalMonitorStateException(&quot;状态不符合预期&quot;);</div><div class="line">            &#125;</div><div class="line">            setExclusiveOwnerThread(null);</div><div class="line">            setState(0);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="AQS实现分析"><a href="#AQS实现分析" class="headerlink" title="AQS实现分析"></a>AQS实现分析</h3><p>AQS内部维护了一个双向队列，队列的没个节点是一个Node内部类，当线程获取同步状态失败时，就会被封装为一个Node。<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmaa96e2ogj30jp07xq46.jpg" alt=""></p><p>可以看到Node类有三个构造函数，参数包括Thread、node模式、等待状态。结合这个图我们就可以知道这个队列的基本形式了。等待进程被封装为Node并标记Node是共享模式还是独占模式，也可以设置它的等待状态。当前节点有前驱节点和后继节点，并有一个专门的变量保存他的下一个等待节点。</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmaab2x082j306j05yaah.jpg" alt=""></p><p>构成的AQS队列就是这样一种形式</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmaamazwopj30iq07zdga.jpg" alt=""></p><p>同步器包含一个头结点和一个尾节点，加入队列的过程必须保证线程安全，因为同时可能有多个线程获取同步状态失败而进入队列尾部，因此AQS提供了<strong><em><em>compareAndSetTail</em></em></strong>方法,而每次出队时只可能有一个线程获取到同步状态，因此出队的方法不需要保证线程安全。</p><h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><p>独占式获取同步状态代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    if (!tryAcquire(arg)&amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">       selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该方法首先完成了获取同步状态，构造加点，加入队列并在同步队列中自旋的工作。首先调用tryAcquire方法保证线程安全的获取同步状态，如果失败则构造EXCLUSIVE独占式节点，加入同步队列尾部。acqireQueued则是自旋等待锁的释放。如果该过程失败了，则调用selfInterrupt方法将自己中断。</p><h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>共享式获取同步状态代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public final void acquireShared(int arg) &#123;</div><div class="line">    if (tryAcquireShared(arg) &lt; 0)</div><div class="line">        doAcquireShared(arg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void doAcquireShared(int arg) &#123;</div><div class="line">    final Node node = addWaiter(Node.SHARED);</div><div class="line">    boolean failed = true;</div><div class="line">    try &#123;</div><div class="line">        boolean interrupted = false;</div><div class="line">        for (;;) &#123;</div><div class="line">            final Node p = node.predecessor();</div><div class="line">            if (p == head) &#123;</div><div class="line">                int r = tryAcquireShared(arg);</div><div class="line">                if (r &gt;= 0) &#123;</div><div class="line">                    setHeadAndPropagate(node, r);</div><div class="line">                    p.next = null; // help GC</div><div class="line">                    if (interrupted)</div><div class="line">                        selfInterrupt();</div><div class="line">                    failed = false;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = true;</div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到方法的主体doAcpuireShared方法会包含一个死循环，也就是一个自旋的过程。只有当前节点是头节点的时候，才会去尝试获取同步状态，如果返回值＞0，表示获取成功退出自旋状态。所以在上面的方法acquireShared，<br>当返回值＜0的时候才会一直进入下面的方法尝试一直获取同步状态。</p><h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>当一个线程加入到CLH队列中时，如果不是头节点是需要判断该节点是否需要挂起；在释放锁后，需要唤醒该线程的继任节点。AQS使用了LockSupport类中的park方法实现了阻塞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private final boolean parkAndCheckInterrupt() &#123;</div><div class="line">    LockSupport.park(this);</div><div class="line">    return Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void park(Object blocker) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    setBlocker(t, blocker);</div><div class="line">    UNSAFE.park(false, 0L);</div><div class="line">    setBlocker(t, null);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可在进程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用。但是注意许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。可以看到park来自于UNSAFE类，UNSAFE中包含了大量的JNI方法，也就是说park和unpark方法是利用了C语言编写的方法，对操作系统底层进行的操作。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC-CAS(2)</title>
      <link href="/2017/12/08/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-CAS/"/>
      <url>/2017/12/08/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-CAS/</url>
      
        <content type="html"><![CDATA[<h3 id="Compare-And-Set"><a href="#Compare-And-Set" class="headerlink" title="Compare And Set"></a>Compare And Set</h3><p>CAS是java并发中最底层的一种技术支持，对内存中的共享数据的读写保证其原子操作。过程如下：首先CPU将内存中的将要被修改的数据与预期的值进行比较，如果这两个值相等，CPU则会将内存中数值替换为新值，否则不做操作。最后，CPU会将旧值返回。CAS的工作方式更多的是与硬件层面的CPU进行交互，而不在语言层面，所以很多资料都是点到为止：一种底层的原子性操作。</p><p>我们可以在AtomicBoolean.class中找到代码</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fm9fu944hej30m903zgm9.jpg" alt=""></p><p>可以看到这里有<strong>CAS</strong>操作，再进入到unsafe.class中，可以发现CAS操作都是native型的，即调用了JNI的方法。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fm9fxr2hc7j30m0043dgm.jpg" alt=""></p><p>所以当我们需要对一个数据进行原子操作的时候，java给我们提供了13个原子操作类:</p><ul><li>AtomicBoolean</li><li>AtomicIngeger</li><li>AtomicLong</li><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li><li>….</li></ul><h3 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h3><ol><li>ABA问题</li><li>循环开销大</li><li>无法保证对多个共享变量的原子操作</li></ol><h2 id="为什么是volatile和cas作底层"><a href="#为什么是volatile和cas作底层" class="headerlink" title="为什么是volatile和cas作底层"></a>为什么是volatile和cas作底层</h2><p>由于java的CAS同时具有volatile读和volatile写的内存语义，因此java之间线程通信目前有以下几种形式。</p><ol><li>A线程写volatile变量，B线程读这个volatile变量</li><li>A线程写volatile变量，B线程以cas更新volatile变量</li><li>A线程cas更新一个volatile变量，B线程cas更新这个volatile变量</li><li>A线程cas更新一个volatile变量，B线程读这个volatile变量</li></ol><p>JAVA的CAS会使用现代处理器上提供的高效机器级别的原子指令，这些指令以原子的形式对内存执行读写操作。同时volatile和CAS一起使用可以实现线程之间的通信，因此构成了JUC的基石。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUC--常用篇(1)</title>
      <link href="/2017/12/03/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-%E5%B8%B8%E7%94%A8%E7%AF%87/"/>
      <url>/2017/12/03/java%E5%B9%B6%E5%8F%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B4%A9%E6%BA%83-%E5%B8%B8%E7%94%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="关于并发的一些思考"><a href="#关于并发的一些思考" class="headerlink" title="关于并发的一些思考"></a>关于并发的一些思考</h3><p>最近看完了《java多线程编程核心技术》、《java并发编程艺术》两本书。第一本更偏向于线程基础技术，看完之后给人一种眼前明亮之感。啊，原来并发编程就是这些操作。当我看完第二本之后，就已经一脸茫然，忘记了第一本的内容 - -!。因为第二本的内容太丰富，涉及到并发的底层原理和框架。于是我又拿出来《java编程思想》找到了并发的一章来看，发现看完已经满脑浆糊了，所以还是要坚持写一下博文，理一下思路也好。</p><p>多线程，任何一个程序员都知道，但是实际工作中，大部分程序员面对的都是业务的CRUD和BUG定位，貌似没有太多机会接触并发。大家都知道程序运行的时候，最关键的是内存和CPU，而CPU运算的时候，是要从内存取值，当然现在很多时候是在L1/L2等Cache中取值，然后放入寄存器，参与运算，得到结果，先放入寄存器，再放入内存。程序执行的指令也放在寄存器，它记录当前程序执行的地址。</p><p>上面说到了，一个数值，进入CPU运算，经过了内存、cache、寄存器。看过jvm我们就知道，当多线程运算同一个值的时候，是每个线程拷贝了一份值的副本到自己的线程工作内存（这里还涉及到java的内存模型），当一个线程计算完毕（计算结果写入寄存器），还没有刷到主存，另一个线程从主存中取到的值还是旧值。所以一个很直观的问题就是如何保证每个线程拿到的数据是最新的，这就是同步机制。最常见的volatile和synchronized就是为了解决这个问题。</p><p>最简单的解决方案就是：共享变量同一时刻只允许有一个线程操作。这就保证了线程要么拿不到值，要么拿到最新的值。于是有了synchronized告诉jvm：这个地方是临界区，只有一把锁。那道锁的那个家伙才能开门进去，否则只能在门口等着。java中的锁，可以是this，方法，对象，类。锁的范围可以是代码块，方法甚至类。jvm会在锁和方法区之间建立联系。jvm生成一个对象会产生很多额外的信息，起码要有对象的内存地址或一个间接的指针，所以要标识一个对象被哪个线程占有并不困难。</p><p>上面的方法虽然可以解决问题，但是很简单粗暴，我们想要一种更灵活的方式。很多时候我们并不关心谁在操作对象，我们只关心这个值到底是多少。于是就有了volatile：保证可见性，不保证原子性。其实意思就是说被volatile修饰的这个对象是一个尊贵的java会员，你要找他必须到他的家（内存）去接它出来，你请它聊天吃饭之后还要把它送回家(内存)。所以这里略过了计算机的高速缓存，读写内存。所以可见性就是说这个值谁都可以看到。至于不保证原子性，就是说这个值谁都可以取来运算。至于说到volatile的效率嘛，肯定也是大打折扣的，因为操作内存很定要比缓存慢的多。就如同数据库，其实我们也是写入了缓存，后台线程刷到磁盘而已。其实从硬件到软件，设计的思想大都是相通的。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="再说sychronized"><a href="#再说sychronized" class="headerlink" title="再说sychronized"></a>再说sychronized</h3><p>举个栗子，多人上厕所。多线程和锁，一个是线程，一个是对象。一个在私有的线程栈中，一个在共享堆中。如何标识某个对象被某个线程锁定？线程开启一片栈帧，在其中存储对象锁记录，堆中对象有对象头（元数据、Runtime State、gc分代等等），可以标识被哪个线程锁定，实际上锁线程就是利用了对象头和monitor来实现锁机制。</p><p>所以在上厕所的例子中，人就是线程，厕所就是共享对象，锁就是对象头，monitor就是钥匙。</p><p>sychronized锁的是一个对象，或者是一个类的实例，或者是类本身。sychronized内部原理是通过对象内部一个叫监视器的东西来实现的。本质又是依赖于操作系统的mutex::Lock(一种互斥锁)来实现的。而操作系统实现线程切换需要从用户态转向核心态，这个成本非常高。这也是<br>我们为什么说sychronized效率低的原因。其实我们常用的HashMap内部就有很多的sychronized方法，这也就是我们说HashMap效率低的问题（关于HashMap可以衍生出很多问题，包括一些算法和红黑树，以后会慢慢写），如下给出了HashMap的put方法。</p><p><code>public synchronized V put(K key, V value) {}</code></p><p>在JDK5之后的版本一直在对sychronized进行优化，都是为了减少这种重量级锁的使用。如JDK6中引入的自旋锁，适应性自旋锁，锁消除，锁粗化，偏向锁等技术减少锁的消耗。以上内容等我想明白再细说吧。</p><p>既然对sychronized有这么多的怨言，当然就会出现可行的替代方案-Lock。简单来说就是把sychronized拆分成获得锁，释放锁的多个步骤。用更灵巧的方式进行同步，使用Lock会更灵活，粒度可以自由控制。当然也会带来更复杂的参数和学习成本。😢</p><p>介绍一种反汇编的指令： javap   xxx.class<br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1flwmbc1dy9j30kw0onwhp.jpg" alt=""></p><p>通过javap可以更清晰的看到底层实现的细节,上图就展示了sychronized的底层代码。</p><h3 id="再说volatile"><a href="#再说volatile" class="headerlink" title="再说volatile"></a>再说volatile</h3><p>如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条<strong><em><em>Lock</em></em></strong>前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p><p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p><p>volatile关键字的另一种用途是保证long和double的原子性操作。其实是利用了某些cpu的高速缓存是64字节宽度，并且不支持填充缓存行的机制。这种应用场景应用相对较少且并不具有普适性，就不在过多介绍。</p><h3 id="创建多线程的方式"><a href="#创建多线程的方式" class="headerlink" title="创建多线程的方式"></a>创建多线程的方式</h3><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>匿名内部类</li><li>带返回值的线程(Callable/Future)</li><li>定时器</li><li>线程池</li><li>Lambda表达式</li></ol><p>其中第七种是从java8才开始的，其它六种应该很常见，记录一下第七种。<br><code>new Thread(() -&gt; {            Sysout.out.println(&quot;I am a new Thread&quot;);        }).start();</code></p><p>最近也在学习lambda表达式的写法，真的是一种让人学会了就一直想秀的语法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>写了一些比较基础的东西，发现再深入一点可能就讲不清楚了。需要在花上半个月再好好看一遍，贴一张书中的图，看完整本书再看这个图就觉得清晰了很多。计划从下往上总结吧。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fm3i98scrkj30gx0ch3zu.jpg" alt=""></p><p>回头看了一下才发现，大多数内容是加锁。但其实有一点我们要清楚，使用多线程的目的是完成业务而不是为了和锁纠缠不清，加锁只是不得已而为之。</p>]]></content>
      
      
      <categories>
          
          <category> java并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>表面理解jvm-内存</title>
      <link href="/2017/11/22/%E8%A1%A8%E9%9D%A2%E7%90%86%E8%A7%A3jvm-%E5%86%85%E5%AD%98/"/>
      <url>/2017/11/22/%E8%A1%A8%E9%9D%A2%E7%90%86%E8%A7%A3jvm-%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>最近看完了《深入理解java虚拟机》这本书，记录一下所学所思，留作以后复习。</p><h3 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h3><p>先来说说虚拟机，我们都知道Java程序运行在虚拟机上，虚拟机负责和操作系统打交道，最终通过二进制指令操作电子电路运行，完成数据的读取，运算，输出。<br>虚拟机在加载.class文件的时候会在内存开辟一块区域”方法区”,专门用来存储累的基本信息，同时在”堆”区生成这个类的Class对象，作为类的一个镜像，为反射机制提供一种可能。Java是一门面向对象的语言，程序运行过程中伴随着对象的生成与死亡，有的是临时对象短暂存活，有的是壮年而亡，而有的长命百岁。所以虚拟机就不停地申请内存，回收内存。对象的生成方法很多，对象的回收方法也很多，例如GC、标记清除/整理等。</p><p>垃圾回收首先要确定的是什么是垃圾，什么时候回收，在哪里回收，怎么回收。不同的对象可能需要不同的回收策略。一个很容易想到的方法就是在后台启动一个线程，每隔一段时间扫描一次内存，清除垃圾，如此往复。</p><p>实际情况往往非常复杂，效率、安全性、对当前程序的影响都要考虑进去。于是人们发现，对象的生命周期不同，使用一种GC方法效率很差。于是就有了Hotspot的方案，堆区根据不同的生命周期，分为eden、to survivor、from survivor以及非堆的元数据区(java8之前的永久区)。<br> 每个区采用了不同的清理算法。于是便出现了最初的<code>串行收集器</code>。</p><p>同时，为了最大程度的利用CPU的多核资源，出现了<code>并行收集器</code>，即多个线程一起收集垃圾。</p><p>为了降低垃圾收集对原有程序的影响,如STW,一种全局暂停的现象，<code>并发收集器</code>应运而生。</p><p>到此为止，便可以引出jvm优化中最重要的两部分，jvm内存怎么划分，选择哪一种垃圾收集器，就是我们常说的jvm调优。这就考验一个开发人员对业务系统的理解和眼光，确定优化方向并调整参数。</p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h3 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h3><p>首先要分清楚的一点是jvm内存模型 != java内存模型(JMM)</p><p>自己画了一张思路的整理图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flqy10c5vtj30ub0lwn0f.jpg" alt="自己画的思路图"></p><p>整理一些零碎的东西：</p><ol><li>程序计数器是此内存区唯一一个没有OOM情况的区域。</li><li>方法区有个别名叫做非堆，用于存储加载的类的信息，在hotspot虚拟上更多的叫做“永久代”,在java8中已经改名为元数据区(MetaSpace)，该区域也可以选择不进行垃圾回收。</li><li>新生对象优先被分配到Eden区</li><li>大对象直接被分到老年代，常见的如长字符串以及数组</li><li>长期存活的对象直接进入老年代。一次Minor GC年龄增长一岁，默认15岁进入老年代。可以调节-XX：MaxTenuringThreshold参数来改变</li><li><p>在survivor空间中年龄相同的所有对象的大小总和大于survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代(这一条读了很多遍才明白)</p><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>当我们使用new创建一个对象时，大概发生了这样一些事情。首先类加载器检查这个类有没有被加载过，如果没有则需要加载-&gt;解析-&gt;初始化。之后虚拟机为它分配内存，就是将一块确定大小的内存划分出来。这时会遇到两个问题：</p></li><li><p>内存是否规整<br>内存是否规整取决于所使用的gc器，如Serial，ParNew等带有整理功能的收集器，就是规整的，在分配内存时只要将标志占用或空闲的指针移动就可以了。<br>如果使用CMS这种基于mark-sweep的算法gc器，则不是规整的，需要利用一张”空闲列表“查找空闲的区块来分配内存。</p></li><li>频繁创建对象<br>对象的频繁创建可能造成前一个对象的指针没有来得及修改，后一个对象便占用了前一个对象的位置。解决方法有两种：一是CAS(compare and sweep一种乐观锁)+失败重试保证更新的原子性，也是虚拟机实际采用的一种方法。二是TLAB（本地线程分配缓冲）,哪个线程需要分配内存就在哪个线程的TLAB上进行分配，可以使用<code>-XX：+UseTLAB</code>开启，个人认为这个参数可以在高并发场景下开启，适合在eden区使用。</li></ol><h3 id="HotSpot的实现方式"><a href="#HotSpot的实现方式" class="headerlink" title="HotSpot的实现方式"></a>HotSpot的实现方式</h3><p>当判断一个对象是否应该被回收时，java采用了一种可达性分析的方法来判断。要做到这点就需要得到所有的GC Roots节点，从GC Root来遍历。如果我们对栈全部扫描一遍这是相当浪费时间和资源的事情，于是我们可以在某个位置把栈上的引用位置记录下来，这样在gc时便不用全盘扫描。在Hotspot中这种结构就叫<code>OopMap</code>,记录了在该类型的对象内什么偏移量上是什么类型的数据。但是我们并不能在任何时候都生成OopMap，只会在称之为<code>安全点</code>的地方生成：</p><ol><li>循环的末尾</li><li>方法返回前</li><li>可能抛出异常的地方</li></ol><p>另一个需要考虑的问题是如何在GC发生时如何保证所有线程走到最近的安全点再停下来，目前最广泛的做法就是<code>主动式中断</code>，设置一个标志，让各个线程主动轮询这个标志，如果标志位true就中断。<br>这时又会有问题，如果程序不能继续执行呢，例如碰到了sleep情况，jvm不会等到线程被重新分配CPU时间，这时就需要<code>安全区来</code>解决。在安全区的任意地点GC都是安全的，当线程进入安全区，首先会标识自己，如果这段时间jvm发起了GC，则不管标记安全区的线程。当线程离开安全区，它要自己检查是否完成了根节点枚举，如果完成了就可以继续执行，否则就要等待。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ol><li>串行收集器</li></ol><p>serial收集器 -XX:+UseSerialGC</p><ol><li>并行收集器</li></ol><p>ParNew收集器 -XX:+UseParNewGC<br>-XX:ParallelGCThreads 限制线程数量</p><p>Parallel收集器 -XX:+UseParallelGC</p><ol><li>并发收集器</li></ol><p>CMS收集器 -XX:+UseConcMarkSweepGC<br>-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长。</p><p>-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理<br>-XX:ParallelCMSThreads  设定CMS的线程数量</p><p>G1收集器：据说会在java9上设置为默认的垃圾收集器，但是最近java9已经更新了，并没有相关的消息。G1的优点就是调优简单，只需要调节最大堆内存和最大暂停时间，另外就是取消了年轻代和老年代的物理划分。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1flr40x4murj30xw0oegqi.jpg" alt="整理一张来自网络的图"></p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringMvc浅谈</title>
      <link href="/2017/11/11/SpringMvc%E6%B5%85%E8%B0%88/"/>
      <url>/2017/11/11/SpringMvc%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="springmvc在哪里"><a href="#springmvc在哪里" class="headerlink" title="springmvc在哪里"></a>springmvc在哪里</h3><p>springmvc是spring体系的一部分，位于web部分。<br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fle36iwgwmj30fq0d7aak.jpg" alt=""></p><h3 id="springmvc的设计模式"><a href="#springmvc的设计模式" class="headerlink" title="springmvc的设计模式"></a>springmvc的设计模式</h3><p>先来看一个简化版:<br><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fle3d2iyonj30g5078wec.jpg" alt=""><br>用户请求到达控制器，控制器并没有处理业务逻辑的能力，于是把请求交给后台的一个model做处理，并将处理的结果返回给控制器。当控制器拿到数据后，就要找到视图并做渲染，并将渲染好的结果返回给用户，这就是一个通用的mvc设计模式。</p><excerpt in="" index="" |="" 首页摘要=""><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><blockquote><p> spirngmvc架构：</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fle4abaf20j30q00d2t91.jpg" alt=""><br>可以看到这个架构的入口就是DispatcherServlet，其本质也是一个servlet，同时这也显示出了它与struts2的区别之一，Struts2的入口是一个过滤器。DispatcherServlet也没有处理事务的能力，仅作为一个数据的分发中心，将数据交给后面的过程来处理。DispatcherServlet通过HandlerMapping来查找Handler，HandlerMapping会返回两部分内容，其一是handler对象，也就是后台模型对象，还有一部分是拦截器数组。前端控制器拿到这些返回数据时，其实就应该来执行handler对象，因为执行handler对象就可以处理具体的业务逻辑。但是springmvc并没有这样做，它将数据利用HandlerAdapter适配器进行包装，也就到了图中的Handler部分。Handler处理过后返回一个ModelAndView对象，包括两部分：Model和view，Model就是数据，view就是视图名称，而不是视图对象。<br>这时前端控制器既有数据，又有视图名称，这时通过视图解析器返回真正的视图对象，最后将视图对象进行渲染并返回给用户。</p><blockquote><p>springmvc为什么要设计适配器？没有行不行？</p></blockquote><p>首先要明确的是在springmvc框架中controller的类型有很多种，比较常见的是<strong><em>@controller</em></strong>类型和<strong><em>实现Handler接口</em></strong>的类型，如果没有适配器，前端控制器就需要做一个类型判断，每种类型需要做哪些不同的处理。这时判断逻辑就会写死在代码中，并不符合springmvc的可扩展行的设计，一旦用户需要自己创建一个类型，那么就需要修改spring源码，这显然是不可取的。但有了适配器问题就方便了很多，每种类型只需要定义一种适配器即可。</p><blockquote><p>springmvc为什么要设计视图解析器？没有行不行？</p></blockquote><p>其实答案和上一个问题一样，当然都是可以的，只是这样需要在前端控制器加入逻辑判断，并不优雅也不易扩展。</p></excerpt>]]></content>
      
      
      <categories>
          
          <category> springmvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springmvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis持久化</title>
      <link href="/2017/11/10/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2017/11/10/redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Redis的强大功能很大程度上是由于其将所有数据存储在内存中，为了使redis重启后数据不丢失，需要将数据以某种形式保存在硬盘中。</p><p>Redis支持两种持久化方式，RDB和AOF。可以单独使用一种或两种结合。redis默认的持久化方式是RDB。</p><p>RDB通过快照完成，当符合一定条件时redis会自动将内存中的数据进行快照并保存在硬盘上。参数有两个：<strong>时间和改动键的个数</strong>。当指定时间内更改键的个数大于指定值就会快照,默认配置如下，单位为秒。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1flcrw1og6bj304z02na9u.jpg" alt="rdb默认配置"></p><p>可以通过SAVE和BGSAVE指令来手动进行快照。</p><ul><li>SAVE由主进程进行快照，会阻塞其他请求。</li><li>BGSAVE通过fork一个子进程进行快照。</li></ul><h3 id="RDB快照过程"><a href="#RDB快照过程" class="headerlink" title="RDB快照过程"></a>RDB快照过程</h3><ol><li>redis使用fork函数复制一份当前进程的副本。</li><li>父进程继续接受后续指令，子进程还是将内存中的数据写入硬盘中的临时文件。</li><li>子进程写入完成数据后用临时文件替换就得RDB文件。</li></ol><p>可以配置<strong><em>rdbcompression yes</em></strong>来选择是否对rdb进行压缩。<br>压缩的好处显而易见就是减少资源的消耗。缺点就是消耗更多的cpu资源。而选择不压缩就相反。</p><p><excerpt in="" index="" |="" 首页摘要=""><br>s <a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="AOF持久化方式"><a href="#AOF持久化方式" class="headerlink" title="AOF持久化方式"></a>AOF持久化方式</h3><p>策略是将发送到redis服务端的每条命令都记录下来，保存到aof文件，其实aof就是一种日志策略，只要重新执行每一条记录下的指令，就可以恢复这个过程中的数据。<br>通过修改配置为yes就可以启动aof的持久化方式。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1flcsenbkf8j305101iq2p.jpg" alt=""></p><p>但是使用AOF方式可能会记录很多中间的过程，这或许对于我们所需的最终结果是没有什么帮助的。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set abc 1</div><div class="line">set abc 2</div></pre></td></tr></table></figure></p><p>reids会记录这两条命令，但我们只需要abc 2就可以了。</p><p>redis提供了<strong><em>BGREWRITEAOF</em></strong>指令来优化AOF文件，目的就是去除中间的执行过程。重写策略提供了一些参数：<br><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1flcsnvtqvsj30a101xdfn.jpg" alt=""></p><ol><li>第一参数指定了重写百分比。例如现在的aof文件大小为64MB，那么下一次重写就是128mb的时候也就是再增加100%的64MB</li><li>第二个参数指定了aof文件最小为64MB的时候才进行重写。</li></ol><h3 id="写入硬盘"><a href="#写入硬盘" class="headerlink" title="写入硬盘"></a>写入硬盘</h3><p>文件写入默认情况下先写入系统缓存，系统每根据策略同步，才是真正写入硬盘中，如果这期间服务器宕机，数据也是会丢失的，redis提供了一些配置来修改同步策略。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1flcsu6cyb5j307102adfn.jpg" alt=""></p><ol><li>每次同步 安全但是最慢</li><li>每秒同步 默认策略</li><li>不主动同步，由操作系统决定，同步周期可能达到30s  最快但是不安全</li></ol></the>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java对象:引用||传递</title>
      <link href="/2017/11/08/java%E5%AF%B9%E8%B1%A1-%E5%BC%95%E7%94%A8-%E4%BC%A0%E9%80%92/"/>
      <url>/2017/11/08/java%E5%AF%B9%E8%B1%A1-%E5%BC%95%E7%94%A8-%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。</p></blockquote><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>在java中有八种基本数据类型，分别是byte、short、int、long、float、double、boolean、char。这八种基本类型的数据，值就保存咋变量中。除去以上八种基本数据类型，其余类型包括自定义的类，都属于引用类型，变量中保存的是引用对象的地址，我们也称为引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int x=1;</div><div class="line">int y=x;</div><div class="line">String a = &quot;nihao&quot;;</div><div class="line">String b = a;</div></pre></td></tr></table></figure></p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1flap6nqupej30cp09c3yc.jpg" alt=""></p><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""></the></li></ul><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class main &#123;</div><div class="line">    private  static  void add(int a)&#123;</div><div class="line">        a++;</div><div class="line">        System.out.println(a+&quot;--add&quot;);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int a = 1;</div><div class="line">        add(a);</div><div class="line">        System.out.println(a+&quot;--origin&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2--add</div><div class="line">1--origin</div></pre></td></tr></table></figure></p><p>果然对于int这种基本类型，传递的是值而不是引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class main &#123;</div><div class="line">    private  static  void add(String a)&#123;</div><div class="line">        a = a+&quot;++++&quot;;</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String a = &quot;hello&quot;;</div><div class="line">        add(a);</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">out:</div><div class="line">hello++++</div><div class="line">hello</div></pre></td></tr></table></figure><p>再测试一下String类型，String 不属于基本类型，出乎我意料的是以为String会是引用传递，但发现string竟然是值传递。再测试一下自定义的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class main &#123;</div><div class="line">    private  static  void add(student a)&#123;</div><div class="line">        a.setName(&quot;gyj&quot;);</div><div class="line">        System.out.println(a.toString());</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        student s = new student();</div><div class="line">        s.setGender(&quot;男&quot;);</div><div class="line">        s.setName(&quot;sc&quot;);</div><div class="line">        add(s);</div><div class="line">        System.out.println(s.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">out:</div><div class="line">student&#123;name=&apos;gyj&apos;, gender=&apos;男&apos;&#125;</div><div class="line">student&#123;name=&apos;gyj&apos;, gender=&apos;男&apos;&#125;</div></pre></td></tr></table></figure><p>果然自定义的类型是使用引用传递，通过查找资料得出以下结论。</p><ol><li>对象就是传引用</li><li>原始类型就是传值</li><li>String，Integer, Double等immutable类型因为没有提供自身修改的函数，每次操作都是新生成一个对象，所以要特殊对待。可以认为是传值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis解决分布式锁</title>
      <link href="/2017/11/01/redis%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2017/11/01/redis%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>废话不多说，首先分享一个业务场景-抢购。一个典型的高并发问题，所需的最关键字段就是库存，在高并发的情况下每次都去数据库查询显然是不合适的，因此把库存信息存入Redis中，利用redis的锁机制来控制并发访问，是一个不错的解决方案。</p><p>首先是一段业务代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@Transactional</div><div class="line">public void orderProductMockDiffUser(String productId)&#123;</div><div class="line">    //1.查库存</div><div class="line">    int stockNum  = stock.get(productId);</div><div class="line">    if(stocknum == 0)&#123;</div><div class="line">        throw new SellException(ProductStatusEnum.STOCK_EMPTY);</div><div class="line">        //这里抛出的异常要是运行时异常，否则无法进行数据回滚，这也是spring中比较基础的</div><div class="line">    &#125;else&#123;</div><div class="line">        //2.下单</div><div class="line">        orders.put(KeyUtil.genUniqueKey(),productId);//生成随机用户id模拟高并发</div><div class="line">        sotckNum = stockNum-1;</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(100);</div><div class="line">        &#125; catch (InterruptedExcption e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        stock.put(productId,stockNum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有一种比较简单的解决方案，就是<strong><em>synchronized</em></strong>关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public synchronized void orderProductMockDiffUser(String productId)</div></pre></td></tr></table></figure></p><p>这就是java自带的一种锁机制，简单的对函数加锁和释放锁。但问题是这个实在是太慢了，感兴趣的可以可以写个接口用apache ab压测一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab -n 500 -c 100 http://localhost:8080/xxxxxxx</div></pre></td></tr></table></figure><p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p><ul><li><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><br>下面就是redis分布式锁的解决方法。首先要了解两个redis指令<br>SETNX 和 GETSET，可以在<a href="http://redis.cn/" target="_blank" rel="external">redis中文网</a>上找到详细的介绍。<br>SETNX就是set if not exist的缩写，如果不存在就返回保存value并返回1，如果存在就返回0。<br>GETSET其实就是两个指令GET和SET，首先会GET到当前key的值并返回，然后在设置当前Key为要设置Value。</the></li></ul><p>首先我们先新建一个RedisLock类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">@Slf4j</div><div class="line">@Component</div><div class="line">public class RedisService &#123;</div><div class="line">    @Autowired</div><div class="line">    private StringRedisTemplate stringRedisTemplate;</div><div class="line"></div><div class="line"></div><div class="line">    /***</div><div class="line">     * 加锁</div><div class="line">     * @param key</div><div class="line">     * @param value 当前时间+超时时间</div><div class="line">     * @return 锁住返回true</div><div class="line">     */</div><div class="line">    public boolean lock(String key,String value)&#123;</div><div class="line">        if(stringRedisTemplate.opsForValue().setIfAbsent(key,value))&#123;//setNX 返回boolean</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        //如果锁超时 ***</div><div class="line">        String currentValue = stringRedisTemplate.opsForValue().get(key);</div><div class="line">        if(!StringUtils.isEmpty(currentValue) &amp;&amp; Long.parseLong(currentValue)&lt;System.currentTimeMillis())&#123;</div><div class="line">            //获取上一个锁的时间</div><div class="line">            String oldvalue  = stringRedisTemplate.opsForValue().getAndSet(key,value);</div><div class="line">            if(!StringUtils.isEmpty(oldvalue)&amp;&amp;oldvalue.equals(currentValue))&#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    /***</div><div class="line">     * 解锁</div><div class="line">     * @param key</div><div class="line">     * @param value</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public void unlock(String key,String value)&#123;</div><div class="line">        try &#123;</div><div class="line">            String currentValue = stringRedisTemplate.opsForValue().get(key);</div><div class="line">            if(!StringUtils.isEmpty(currentValue)&amp;&amp;currentValue.equals(value))&#123;</div><div class="line">                stringRedisTemplate.opsForValue().getOperations().delete(key);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;解锁异常&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个项目是springboot的项目。首先要加入redis的pom依赖，该类只有两个功能，加锁和解锁，解锁比较简单，就是删除当前key的键值对。我们主要来说一说加锁这个功能。<br>首先，锁的value值是当前时间加上过期时间的时间戳，Long类型。首先看到用setiFAbsent方法也就是对应的SETNX，在没有线程获得锁的情况下可以直接拿到锁，并返回true也就是加锁，最后没有获得锁的线程会返回false。 最重要的是中间对于锁超时的处理，如果没有这段代码，当秒杀方法发生异常的时候，后续的线程都无法得到锁，也就陷入了一个死锁的情况。我们可以假设CurrentValue为A，并且在执行过程中抛出了异常，这时进入了两个value为B的线程来争夺这个锁，也就是走到了注释<em>*</em>的地方。currentValue==A，这时某一个线程执行到了getAndSet(key,value)函数(某一时刻一定只有一个线程执行这个方法，其他要等待)。这时oldvalue也就是之前的value等于A，在方法执行过后，oldvalue会被设置为当前的value也就是B。这时继续执行，由于oldValue==currentValue所以该线程获取到锁。而另一个线程获取的oldvalue是B，而currentValue是A，所以他就获取不到锁啦。多线程还是有些乱的，需要好好想一想。<br>接下来就是在业务代码中加锁啦：首要要@Autowired注入刚刚RedisLock类，不要忘记对这个类加一个@Component注解否则无法注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private static final int TIMEOUT= 10*1000;</div><div class="line">@Transactional</div><div class="line">public void orderProductMockDiffUser(String productId)&#123;</div><div class="line">     long time = System.currentTimeMillions()+TIMEOUT;</div><div class="line">   if(!redislock.lock(productId,String.valueOf(time))&#123;</div><div class="line">    throw new SellException(101,&quot;换个姿势再试试&quot;)</div><div class="line">    &#125;</div><div class="line">    //1.查库存</div><div class="line">    int stockNum  = stock.get(productId);</div><div class="line">    if(stocknum == 0)&#123;</div><div class="line">        throw new SellException(ProductStatusEnum.STOCK_EMPTY);</div><div class="line">        //这里抛出的异常要是运行时异常，否则无法进行数据回滚，这也是spring中比较基础的</div><div class="line">    &#125;else&#123;</div><div class="line">        //2.下单</div><div class="line">        orders.put(KeyUtil.genUniqueKey(),productId);//生成随机用户id模拟高并发</div><div class="line">        sotckNum = stockNum-1;</div><div class="line">        try&#123;</div><div class="line">            Thread.sleep(100);</div><div class="line">        &#125; catch (InterruptedExcption e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        stock.put(productId,stockNum);</div><div class="line">    &#125;</div><div class="line">    redisLock.unlock(productId,String.valueOf(time));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大功告成了！比synchronized快了不知道多少倍，再也不会被老板骂了!</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
