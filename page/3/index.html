<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="多喝热水">
<meta property="og:type" content="website">
<meta property="og:title" content="ShuChang&#39;s Blog">
<meta property="og:url" content="http://www.shuchang.sc.com/page/3/index.html">
<meta property="og:site_name" content="ShuChang&#39;s Blog">
<meta property="og:description" content="多喝热水">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShuChang&#39;s Blog">
<meta name="twitter:description" content="多喝热水">






  <link rel="canonical" href="http://www.shuchang.sc.com/page/3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ShuChang's Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShuChang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">剑来!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">26</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">20</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">96</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/08/JMS-6-Message高级特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/08/JMS-6-Message高级特性/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(6) Message高级特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 12:09:46" itemprop="dateCreated datePublished" datetime="2018-12-08T12:09:46+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:33" itemprop="dateModified" datetime="2018-12-26T09:46:33+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="延时投递与定时投递"><a href="#延时投递与定时投递" class="headerlink" title="延时投递与定时投递"></a>延时投递与定时投递</h2><p>AMQ提供了对消息的定时调度机制,只需要把调度信息设置在message中即可。</p>
<p>首先要在xml中开启设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schedulerSupport=&quot;true&quot;</div></pre></td></tr></table></figure>
<ul>
<li>一共四个属性:</li>
</ul>
<ol>
<li>AMQ_SCHUDULED_DELAY: 延迟投递的时间</li>
<li>AMQ_SCHUDULED_PERIOD: 延迟投递时间间隔</li>
<li>AMQ_SCHUDULED_REPEAT: 重复次数</li>
<li>AMQ_SCHUDULED_CRON: cron表达式</li>
</ol>
<ul>
<li>AMQ也提供了封装的消息类型:org.apache.activemq.scheduledMessage</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jmsTemplate.send(new MessageCreator() &#123;</div><div class="line">                @Override</div><div class="line">                public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                    TextMessage textMessage = session.createTextMessage();</div><div class="line">                    //设置延时投递 60s</div><div class="line">                    textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY,60*1000);</div><div class="line">                    //重复3次</div><div class="line">                    textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT,3);</div><div class="line">                    return textMessage;</div><div class="line">                &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Blob-Message"><a href="#Blob-Message" class="headerlink" title="Blob Message"></a>Blob Message</h2><p>BlobMessage是用来传递较大的二进制信息,在AMQ的新版本中,默认是关闭的,因为这种方式可能造成安全漏洞。</p>
<p>可以在发送端的url上进行设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://192.168.1.1:61619?jms.blobTransferPolicy.uploadUrl=http://xx.xx.xx.xx/nsfvol/fhms/</div></pre></td></tr></table></figure>
<p>sending blobmessage的方式:</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzba3faj1j31880dm3zo.jpg" alt=""></p>
<p>可以看到这里有三种发送blob Message的方式: url、File 或者 Inputstream,这里需要注意的是由于blobMessage是AMQ提供的扩展,所以要将jms的session强转为Amq的session。</p>
<p>文件接收方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@JmsListener(destination = &quot;file&quot;)</div><div class="line">    public void fileQ(Message message) throws IOException, JMSException &#123;</div><div class="line">        if(message instanceof BlobMessage)&#123;</div><div class="line">            BlobMessage blobMessage = (BlobMessage) message;</div><div class="line">            InputStream inputStream = blobMessage.getInputStream();</div><div class="line">            byte[] data = new byte[inputStream.available()];</div><div class="line">            inputStream.read(data);</div><div class="line">            inputStream.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/07/JMS-5-AMQ-Message-Dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/07/JMS-5-AMQ-Message-Dispatch/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(5)-AMQ Message Dispatch</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 15:25:47" itemprop="dateCreated datePublished" datetime="2018-12-07T15:25:47+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:35" itemprop="dateModified" datetime="2018-12-26T09:46:35+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Message-Cursor"><a href="#Message-Cursor" class="headerlink" title="Message Cursor"></a>Message Cursor</h2><p>AMQ发送持久化消息的典型处理方式为,当消费者准备就绪,broker把存储的消息按批次发送给消费者,发送完成后,指针向后移动。这时一种比较理想的方式。在AMQ 5.0版本之后,消息发送开始采用一种混合模式,当消费者活跃时,直接将持久消息发送给消费者,当消费者不活跃时,采用cursor来处理发送消息。</p>
<blockquote>
<p>当消费者活跃,处理能力比较强时,消息的直接发送到消费端</p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxy9mb9u2lj30pu0dgjr9.jpg" alt=""></p>
<blockquote>
<p>当消息产生积压,消费者再度活跃时,或者消费者的消费速度比生产速度慢时,消息从pending cursor取出,发送到消费队列。</p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxy9tgmrq3j30qi0bqdfq.jpg" alt=""></p>
<p>Message Cursor有三种类型:</p>
<ol>
<li>Store-based</li>
</ol>
<p>AMQ 5.0之后的默认类型,支持持久化和非持久化,内嵌了file-based。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxyazo6b1wj31100k2jri.jpg" alt=""></p>
<ol>
<li>VM</li>
</ol>
<p>这种方式的消息存储在内存中,这种方式处理很快,但是当出现消费端慢消费就可能出现问题。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxybs0h8uzj30vk09u747.jpg" alt=""></p>
<ol>
<li>File-based</li>
</ol>
<p>当内存达到限制,消息就会被存储到文件系统的临时文件中</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxybvbvzfyj30p80iqt8o.jpg" alt=""></p>
<h2 id="分发策略"><a href="#分发策略" class="headerlink" title="分发策略"></a>分发策略</h2><ol>
<li>严格顺序分发</li>
</ol>
<p>AMQ会保证topic consumer以相同的顺序接收来自同一个producer的消息,但有时也需要保证消费者能以相同的顺序消费来自不同topic producer的消息。例如生产者p1 p2 通过topic关联了c1 c2,p1生产了消息1,2,3而p2生产消息4,5,6。这时c1的消费顺序是123456,而c2的消费顺序是456123。如果我们需要严格保证两个c的消费顺序,这时就会需要严格顺序分发。</p>
<p>保证严格顺序的一个负面效果就是性能会降低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;policyEntry topic=&quot;Orders.&gt;&quot;&gt;</div><div class="line">    &lt;dispatchPolicy&gt;</div><div class="line">        &lt;strictOrderDispatchPolicy/&gt;</div><div class="line">    &lt;/dispatchPolicy&gt;</div><div class="line">&lt;/policyEntry&gt;</div></pre></td></tr></table></figure>
<ol>
<li>轮询分发策略</li>
</ol>
<p>在某些情况下,消息的数量比较少,但每次处理消息的时间会比较长,那么在默认的prefetch参数和dispatch policy下,这些消息会倾向于发送到某个consumer上,就会因为负载不均导致处理时间增加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;policyEntry topic=&quot;Orders.&gt;&quot;&gt;</div><div class="line">    &lt;dispatchPolicy&gt;</div><div class="line">        &lt;roundRobinDispatchPolicy/&gt;</div><div class="line">    &lt;/dispatchPolicy&gt;</div><div class="line">&lt;/policyEntry&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/07/JMS-4-AMQ-Destination特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/07/JMS-4-AMQ-Destination特性/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(4)-AMQ Destination特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 10:18:25" itemprop="dateCreated datePublished" datetime="2018-12-07T10:18:25+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:39" itemprop="dateModified" datetime="2018-12-26T09:46:39+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="wildcards"><a href="#wildcards" class="headerlink" title="wildcards"></a>wildcards</h2><p>wildcards用来支持名字分层体系,它不属于JMS规范,是AMQ的一个扩展。</p>
<p>AMQ支持三种wildcards:</p>
<ol>
<li><p>‘.’, 路径上名字的分隔符</p>
</li>
<li><p>‘*’, 常见的通配符,匹配路径上的所有</p>
</li>
<li><p>‘&gt;’,递归匹配以这个名字开头的dest</p>
</li>
</ol>
<p>例如下面两个dest:</p>
<p>PRICE.STOCK.CN.WANDA<br>PRICE.STOCK.AM.ALIBABA</p>
<ol>
<li>PRICE.&gt; 匹配所有的价格变动</li>
<li>PRICE.STOCK.&gt;匹配所有的股价变动</li>
<li>PRICE.STOCK.CN.* 匹配所有A股变动</li>
<li>PRICE.STOCK.*.ALIBABA 匹配与阿里相关的股价变动</li>
</ol>
<h2 id="组合队列-composite-destination"><a href="#组合队列-composite-destination" class="headerlink" title="组合队列 composite destination"></a>组合队列 composite destination</h2><p>组合队列允许用一个虚拟的dest代表多个dest,这样就可以通过组合队列在一个操作中同时向多个queue发送消息。</p>
<p>不同队列名用’,’隔开。如果有topic有ptp,则需要写明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">public Queue queue()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;queue.a,queue.b&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public Queue queue2()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;queue://queue.a,topic://topic.a&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="delete-inactive-destination"><a href="#delete-inactive-destination" class="headerlink" title="delete inactive destination"></a>delete inactive destination</h2><p>上面的组合队列可以很大程度上方便使用,但是可能会造成创建过多的队列,那么就需要一种功能能够自动删除无用的队列。当然也可以通过控制台或者jms远程删除。</p>
<p>这种方式需要在配置文件进行配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; schedulePeriodForDestinationPurge=&quot;10000&quot;&gt;</div><div class="line"></div><div class="line">&lt;destinationPolicy&gt;</div><div class="line">    &lt;policyMap&gt;</div><div class="line">        &lt;policyEntries&gt;</div><div class="line">                &lt;policyEntry topic=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimeoutBeforeGC=&quot;30000&quot;&gt;</div><div class="line">                &lt;/policyEntry&gt;</div><div class="line">        &lt;/policyEntries&gt;</div><div class="line">    &lt;/policyMap&gt;</div><div class="line">&lt;/destinationPolicy&gt;</div><div class="line"></div><div class="line">&lt;/destinationPolicy&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>schedulePeriodForDestinationPurge 设置检查间隔,单位ms</p>
<p>inactiveTimeoutBeforeGC 表示空闲多久会被删除,单位ms</p>
<p>gcInactiveDestinations=true 删除不活动的队列</p>
<h2 id="Destination-options"><a href="#Destination-options" class="headerlink" title="Destination options"></a>Destination options</h2><p>这个特性是AMQ在JMS规范之外提供的特性,以一种url的方式可以对队列进行一些配置。</p>
<ol>
<li><p>consumer.prefechSize: consumer一次可以拉取的最大消息数量</p>
</li>
<li><p>consumer.maximumPendingMessageLimit: 当存在慢消费的情况时,非持久化的topic允许丢弃消息的最大值</p>
</li>
<li><p>consumer.retroactive: 是否为回溯消费者</p>
</li>
<li><p>consumer.dispatchAsync: 是否异步分发,默认为true</p>
</li>
<li><p>consumer.exclusive: 是否为独占消费者,默认false</p>
</li>
<li><p>consumer.priority: 消费者优先级,默认为0</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Queue queue3()&#123;</div><div class="line">        return new ActiveMQQueue(&quot;queue.c?consumer.priority=false&amp;consumer.prefechSize=10&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Visual-Destitation"><a href="#Visual-Destitation" class="headerlink" title="Visual Destitation"></a>Visual Destitation</h2><p>虚拟dest创建的是逻辑dest,客户端和消费端通过它来生产和消费消息,并把它映射到物理dest。AMQ支持两种方式:</p>
<ol>
<li><p>visual topic 虚拟主题</p>
</li>
<li><p>composite destination 组合</p>
</li>
</ol>
<p>虚拟dest的作用体现在哪里呢?</p>
<p>在AMQ,topic只有在持久订阅下才是持久化的,它的每个订阅者都会收到所有的消息。但它存在两个问题:</p>
<ol>
<li><p>同一个应用只能用一个listener去监听topic,而不能使用多个,通过负载均衡来处理消息(当消费端部署了多个节点,那么每个节点都会消费一遍这个消息,而我们理想的情况是a节点处理n条,b节点处理m条)。虽然PTP模式可以解决这个问题,但明显会创建过多的Queue。所以,又要订阅发布,又要消息分组,JMS本身是不支持的。</p>
</li>
<li><p>同一个应用内,消费者failover问题。由于只能有单个持久订阅者,如果这个订阅者离线,那么消息就无法处理,系统健壮性不足。</p>
</li>
</ol>
<p>为了解决这个问题,AMQ提出了visual topic</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Topic topic()&#123;</div><div class="line">        return new ActiveMQTopic(&quot;VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于消费者来说,只需要创建正常的topic,然后以’VirtualTopic’开头。</p>
<p>对于消费端来说,需要将自己视为一个队列,不同的应用使用不同的队列名,即可表示自己是一个消费端的负载均衡。队列名必须以‘Consume’开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Queue queue4()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;Consumer.A.VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public Queue queue5()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;Consumer.B.VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Mirrored-Queues"><a href="#Mirrored-Queues" class="headerlink" title="Mirrored Queues"></a>Mirrored Queues</h2><p>AMQ中每个Queue中的消息只能被一个consumer消费。但有时候你可能希望监视消息流。因此AMQ提供了mirrored queue机制,broker会把发送到某个queue的消息转发到一个名称类似的topic,监视程序只需要监听这个mirrored queue topic。</p>
<p>首先要对broker进行配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;$&#123;activemq.data&#125;  useMirroredQueues=&quot;true&quot;&gt;</div></pre></td></tr></table></figure>
<p>如果不进行其他配置,默认的mirror topic前缀是 ‘VirtualTopic.Mirror.’,当然也支持自定义格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;destinationInterceptors&gt;</div><div class="line">    &lt;mirroredQueue copyMessage=&quot;true&quot; postPrefix=&quot;.mirror&quot; prefix=&quot;mirror.&quot;&gt;</div><div class="line">&lt;/destinationInterceptors&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/06/JMS-3-JMS结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/06/JMS-3-JMS结构/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(3)-JMS API结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 15:53:11" itemprop="dateCreated datePublished" datetime="2018-12-06T15:53:11+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:43" itemprop="dateModified" datetime="2018-12-26T09:46:43+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxx3glglroj30n40hm0tm.jpg" alt=""></p>
<p>JMS API的结构还是比较简单的。</p>
<p>创建一个JMS的基本步骤是:</p>
<ol>
<li>创建JMS ConnectionFactory</li>
<li>通过ConnectionFactory创建一个Connection</li>
<li>通过Connection创建jms session</li>
<li>创建destination、producer、consumer</li>
<li>发送消息</li>
<li>关闭资源</li>
</ol>
<h2 id="JmsTempate"><a href="#JmsTempate" class="headerlink" title="JmsTempate"></a>JmsTempate</h2><p>在Springboot中一般使用JmsTempate进行操作,所以对照上面的过程,看一下template是如何进行封装的。</p>
<ol>
<li>引入Pom</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ol>
<li>code</li>
</ol>
<p>首先在启动类上添加注解@EnableJms,会启动一些JMS的自动配置,包括JmsTempate。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public JmsTemplate(ConnectionFactory connectionFactory) &#123;</div><div class="line">		this();</div><div class="line">		setConnectionFactory(connectionFactory);</div><div class="line">		afterPropertiesSet();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>JmsTemplate的构造函数中需要一个ConnectionFactory,因此会先实例化一个ConnectionFactory。也就对应了上面过程中的第一步。</p>
<p>当注入JmsTemplate我们就可以调用send方法进行消息发送,非常简单。但正是因为它封装的太好了,我们反而不容易了解它的具体实现细节,所以进入send方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void send(final Destination destination, final MessageCreator messageCreator) throws JmsException &#123;</div><div class="line">		execute(session -&gt; &#123;</div><div class="line">			doSend(session, destination, messageCreator);</div><div class="line">			return null;</div><div class="line">		&#125;, false);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>send方法调用了内部方法execute,而且我们看到一个关键参数名session,这里是一个lambda表达式,在session内封装了消息和destination,然后丢进execute方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; action, boolean startConnection) throws JmsException &#123;</div><div class="line">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</div><div class="line">		Connection conToClose = null;</div><div class="line">		Session sessionToClose = null;</div><div class="line">		try &#123;</div><div class="line">			Session sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(</div><div class="line">					obtainConnectionFactory(), this.transactionalResourceFactory, startConnection);</div><div class="line">			if (sessionToUse == null) &#123;</div><div class="line">				conToClose = createConnection();</div><div class="line">				sessionToClose = createSession(conToClose);</div><div class="line">				if (startConnection) &#123;</div><div class="line">					conToClose.start();</div><div class="line">				&#125;</div><div class="line">				sessionToUse = sessionToClose;</div><div class="line">			&#125;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&quot;Executing callback on JMS Session: &quot; + sessionToUse);</div><div class="line">			&#125;</div><div class="line">			return action.doInJms(sessionToUse);</div><div class="line">		&#125;</div><div class="line">		catch (JMSException ex) &#123;</div><div class="line">			throw convertJmsAccessException(ex);</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			JmsUtils.closeSession(sessionToClose);</div><div class="line">			ConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>execute方法创建connection,绑定session。调用doInJms方法将message发送到broker,然后释放资源。</p>
<p>这样粗略的看了一下消息的发送原理。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/06/JMS-2-可靠性保证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/06/JMS-2-可靠性保证/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(2)-可靠性保证与消息模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 14:57:26" itemprop="dateCreated datePublished" datetime="2018-12-06T14:57:26+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:47" itemprop="dateModified" datetime="2018-12-26T09:46:47+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>对于一个消息中间件来说,可靠性保证一直是一个重要主题。Jms消息的可靠性保证,通常包含三个阶段: 客户端接收消息/客户端处理消息/客户端ACK</p>
<p>在事务性会话中(jms session),当事务被提交,即发生自动确认。在非事务会话中,消息的确认取决于应答模式:包含三种应答模式:</p>
<ul>
<li>client 客户端手动确认</li>
<li>auto 自动确认</li>
<li>dups_ok 一种延迟确认的模式,个人理解是一种批量签收。可以减少开销,但是可能会造成重复的ack。如果没有仔细研究过原理,不建议使用</li>
</ul>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>JMS消息持久化有两种方式:</p>
<p>PERSISTENT: 持久化模式,消息不会因为broker宕机而丢失,默认模式</p>
<p>NO_PERSISTENT: broker宕机,消息丢失</p>
<p>ActiveMQ内部消息存储默认使用了KahaDB,同时开支持的方式有AMQ,JDBC,Memory。可以在activemq.xml中对KahaDB进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">    &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot;/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure>
<p>可用属性:</p>
<ol>
<li><p>indexWriteBatchSize: 批量写入磁盘索引的数量,默认1000</p>
</li>
<li><p>indexCacheSize: 内存中缓存索引的page数量,默认1000</p>
</li>
<li><p>enableIndexWriteAsync: 是否异步写出索引,默认false</p>
</li>
<li><p>journalMaxFileLength: 设置每个消息datalog大小,默认32MB</p>
</li>
<li><p>enableJournalDiskSyncs: 如果没有加事务,是否需要写入磁盘。JMS持久化时需要设置为false</p>
</li>
<li><p>cleanUpInterval: 清理过期消息,默认30000</p>
</li>
<li><p>archiveDataLogs: 对于需要删除的文件,不做删除,而是进行压缩。默认为false</p>
</li>
<li><p>directoryArchive: 压缩文件的存放位置</p>
</li>
</ol>
<h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><p>可以设置消息的过期时间,默认是永不过期。</p>
<h2 id="临时目的地"><a href="#临时目的地" class="headerlink" title="临时目的地"></a>临时目的地</h2><p>jms session可以创建临时的queue或者topic,当创建临时目的地的连接断开,临时目的地也就删除。只有创建临时目的地连接的消费者才可以消费这里的信息。</p>
<h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>在JMS客户端中,可以使用本地事务来组合消息的接收和发送,最后使用commit提交或者使用rollback进行回滚。事务提交表示发送者的消息都已经发送,消费者消息都已确认。事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交。</p>
<p>需要注意的是,如果业务是一个请求/回复模式,发送一个消息,同时希望在事务中等待消息的回复,那么程序会被挂起,因为直到事务提交,发送操作才会真正执行。</p>
<p>消息的生产和消费不能再同一个事务中。</p>
<h2 id="消息模型-PTP"><a href="#消息模型-PTP" class="headerlink" title="消息模型-PTP"></a>消息模型-PTP</h2><p>PTP就是一种点对点的模型,一个消费者一个生产者,是一种单播模式。</p>
<p>当session关闭时,如果有一些消息已经收到,但还没有签收,那么当客户端再次连接上时,这些消息还会被再次接收。</p>
<p>如果消费端设置了选择器,那么不符合条件的消息会留在队列中,不会被接收。</p>
<p>队列可以持久保存消息知道消费端收到消息,充分体现异步传输的优势</p>
<h2 id="消息模型-pub-sub"><a href="#消息模型-pub-sub" class="headerlink" title="消息模型-pub/sub"></a>消息模型-pub/sub</h2><p>发布订阅模式,生产者制定一个主题,多个消费端可以订阅这个主题来收到消息,是一种广播模式。</p>
<ol>
<li><p>消息订阅分为持久订阅和非持久订阅:非持久订阅当客户端处于非激活状态时,消息将会消失,永远不能接收到。<br>持久模式则是消费端向JMS注册自身,当消费端宕机,broker会保存这个主题的消息,当消费端上线时,可以得到离线时漏掉的消息。</p>
</li>
<li><p>非持久模式下不能重新派送一个未签收的消息,所以需要设置为持久化模式。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/06/jms-消息结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/06/jms-消息结构/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(1)-消息基础</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 14:12:58" itemprop="dateCreated datePublished" datetime="2018-12-06T14:12:58+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:25" itemprop="dateModified" datetime="2018-12-26T09:46:25+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>JMS即java message service,是一个java面向消息中间件提出的标准化接口。类似于jdbc于mysql-connector的关系。ActiveMQ是apache出的一个消息中间件,实现了JMS协议。目前AMQ的版本为5.x,社区不太活跃,因为AMQ目前的主要精力投入在下一代MQ的开发-appllo上。</p>
<p>常见MQ的选型,供参考:</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxz85ye41hj30py0nqq66.jpg" alt=""></p>
<h2 id="JMS消息结构"><a href="#JMS消息结构" class="headerlink" title="JMS消息结构"></a>JMS消息结构</h2><p>JMS消息由以下部分组成: 消息头 消息体 属性</p>
<p>消息头包含识别信息和路由信息:</p>
<ol>
<li>JMSDestatination: 路由地址,由sender设置</li>
<li>JMSDeliveryMode: 传送模式。两种: 持久模式和非持久化模式,持久模式消息会被传送”仅仅一次”。也就是说当broker宕机,消息不会丢失,当broker恢复后会再次发送消息。非持久消息保证传输最多一次,当机器宕机,数据将永远消失。</li>
<li>JMSExpiration: 消息过期时间,消息在过期时间内没有被消费,则会删除。</li>
<li>JMSPriority: 消息优先级,从0-9,0-4是普通消息,5-9是加急消息。JMS提供的保障的是加急消息先于普通消息送达,其他尽量保证,默认为4</li>
<li>JMSMessageID: 每个消息的唯一识别,可以手动设置为业务id,否则会自动生成。</li>
<li>JMSCorrelationID: 用来连接到另外一个消息,典型的应用是将回复消息链接到原消息,也就是有应答的场景。</li>
<li>JMSReplyTo: 提供本消息回复消息的目的地址</li>
<li>JMSType: 消息类型识别符</li>
<li>JMSRedelivered: 如果客户端收到一个设置了JMSRedelivered属性的消息,表示客户端之前接受过这个消息,但是没有ack。如果触发了消息重新发送,JMSRedelivered=true,否则false。</li>
</ol>
<p>JMS消息体提供了5种消息体:</p>
<ul>
<li>TextMessage</li>
<li>MapMessage</li>
<li>BytesMessage</li>
<li>StreamMessage</li>
<li>ObjectMessage</li>
</ul>
<p>JMS提供三种消息属性:</p>
<ol>
<li>应用程序添加的属性: Message.setStringProperty(k,v)</li>
<li>JMS定义的属性: connection.getMetaData().getJMSXPropertyNames() 获取jms定义的属性</li>
<li>三方插件提供的特殊属性</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/05/k8s学习总结5-调度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/05/k8s学习总结5-调度/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">k8s学习总结5-调度</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-05 16:05:02" itemprop="dateCreated datePublished" datetime="2018-12-05T16:05:02+08:00">2018-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-06 19:37:28" itemprop="dateModified" datetime="2018-12-06T19:37:28+08:00">2018-12-06</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/K8S/" itemprop="url" rel="index"><span itemprop="name">K8S</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/K8S/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>K8S调度器的主要任务就是为Pod寻找一个合适的Node。</p>
<h2 id="默认调度器"><a href="#默认调度器" class="headerlink" title="默认调度器"></a>默认调度器</h2><p>K8S提供了默认调度器,它的主要流程是:根据Predicate算法检查每个Node。然后再调用Priority算法给Node打分。最终调度结果就是选择分数最高的那个Node。</p>
<p>K8S调度算法的流程如下:</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxvz4mqinzj312u0nowfp.jpg" alt=""></p>
<p>主要是两个循环过程:</p>
<p>第一个循环informer负责监听etcd中Pod、Node、Service等需要调度的组件。一旦发现informer就将它放入一个优先级队列。</p>
<p>第二个循环是Scheduling Path,不断从优先队列中取出一个Pod,使用Predicate算法过滤出一组Node,Node的信息从Cache中获取。选出一个合适的Node之后,调度器就会进行绑定操作,将Pod的nodeName填写为筛选出的Node名称。</p>
<h2 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h2><p>K8S中Predicates算法默认提供四种调度策略:</p>
<h3 id="GeneralPredicates"><a href="#GeneralPredicates" class="headerlink" title="GeneralPredicates"></a>GeneralPredicates</h3><p>这是第一组过滤策略,也是最基础的调度规则。目的就是根据yaml配置文件检查硬件资源是否充足,端口是否冲突。由于调度策略采用了无锁化设计,所以当一个Pod被调度到Node上时,Node会再次执行一遍这个策略。</p>
<h3 id="Volume相关过滤"><a href="#Volume相关过滤" class="headerlink" title="Volume相关过滤"></a>Volume相关过滤</h3><p>这组规则主要对Volume进行过滤。</p>
<p>首先是NoDiskconflict,检查Pod声明挂载的volume是否存在冲突。</p>
<p>接着是MaxPDVolumeCountPredicate,判断节点某种volume类型是否超过上限。</p>
<p>接着是VolumeBindingPredicate,主要作用是判断节点亲和性。</p>
<h3 id="宿主机相关过滤规则"><a href="#宿主机相关过滤规则" class="headerlink" title="宿主机相关过滤规则"></a>宿主机相关过滤规则</h3><p>这组规则是判断Pod是否满足Node的某些条件。</p>
<p>例如配置了PodToleratesNodeTaints字段,只有当Pod的Toleration和Node的taint字段相匹配,才能调度到该节点。</p>
<h3 id="Pod相关过滤规则"><a href="#Pod相关过滤规则" class="headerlink" title="Pod相关过滤规则"></a>Pod相关过滤规则</h3><p>这组检查和GeneralPredicates有很多重合,比较特殊的一点是PodAffinityPredicate。用来检查Node上Pod之间的亲密和反亲密关系。</p>
<p>上面这四种类型的 Predicates，就构成了调度器确定一个Node可以运行待调度Pod的基本策略。</p>
<h2 id="Priorites"><a href="#Priorites" class="headerlink" title="Priorites"></a>Priorites</h2><p>Proorites根据算法对选出的Node打分,最常用的是LeastRequestedPriority</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">score = (cpu((capacity-sum(requested))10/capacity) + memory((capacity-sum(requested))10/capacity))/2</div></pre></td></tr></table></figure>
<p>其实就是选择内存和CPU最多的主机,除此之外还有NodeAffinityPriority,TaintTolerationPriority以及InterPodAffinityPriority。</p>
<h2 id="优先级与抢占机制"><a href="#优先级与抢占机制" class="headerlink" title="优先级与抢占机制"></a>优先级与抢占机制</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>首先要明确的是,优先级与抢占解决的是Pod调度失败的问题。</p>
<p>通常情况下,调度失败的Pod会被搁置,直到出现满足条件的Node才能再次调度。但是如果这个Pod是一个优先级非常高的系统,我们希望能通过减少一部分优先度低的Pod,给优先级高的Pod空出位置。</p>
<p>在K8S 1.10版本提供了优先级与抢占机制,首先要定义一个PriorityClass类型的yaml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: scheduling.k8s.io/v1beta1</div><div class="line">kind: PriorityClass</div><div class="line">metadata:</div><div class="line">  name: high-priority</div><div class="line">value: 1000000</div><div class="line">globalDefault: false</div><div class="line">description: &quot;This priority class should be used for high priority service pods only.&quot;</div></pre></td></tr></table></figure>
<p>这里定义了优先级为1000000的配置文件,globalDefault如果设置为true,就会将Pod的默认优先级定义为1000000,而实际默认是0。优先级最大为10亿,超过10亿为K8S内部的Pod。</p>
<p>定义过后就可以在Pod中使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Pod</div><div class="line">metadata:</div><div class="line">  name: nginx</div><div class="line">  labels:</div><div class="line">    env: test</div><div class="line">spec:</div><div class="line">  containers:</div><div class="line">  - name: nginx</div><div class="line">    image: nginx</div><div class="line">    imagePullPolicy: IfNotPresent</div><div class="line">  priorityClassName: high-priority</div></pre></td></tr></table></figure>
<p>经过配置之后,调度队列就会将这个Pod就会比优先级低的Pod提前出队。</p>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>抢占机制相比优先级要复杂的多。当一个高优先级的Pod调度失败之后,就会触发抢占机制。抢占的大概过程如下:</p>
<p>k8s选出优先级较低的Pod所在的Node节点,将抢占者的spec.nominatedNodeName填写为该Node,然后将该pod重新入队。如果在下个周期,这个Pod没有抢到node(出现了优先级更高的pod),将spec.nominatedNodeName去掉重新入队,如果抢占成功,则让被抢占节点优雅退出(delete api),将新pod部署。</p>
<p>接下来讲述一下详细原理,我们将这个Pod称为抢占者,旧的节点称为牺牲者:</p>
<p>抢占的重要设计就是在调度队列的实现里,实现了两个不同的队列。</p>
<ol>
<li><p>activeQ: 存放下个周期需要调度的Pod</p>
</li>
<li><p>unschedulableQ: 用于存放调度失败的Pod,当这个队列中的Pod被更新时,k8s将它重新放入activeq。</p>
</li>
</ol>
<p>在这里发生调度失败,也就是节点入队时会去触发寻找牺牲者的流程。</p>
<p>首先调度器检查这次调度失败的原因,用来确认抢占机制可以实现重新调度。</p>
<p>如果抢占可以发生,调度器将缓存的所有节点信息复制一份,然后利用副本去模拟一遍抢占过程。</p>
<p>模拟成功之后会选出一个最佳Node,接着调度器就会开始真正的抢占操作:</p>
<p>首先检查牺牲者列表,清理Pod的spec.nominatedNodeName字段</p>
<p>为抢占者设置spec.nominatedNodeName属性</p>
<p>开启协程,删除旧Pod,完成抢占</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/04/mysql之redo-log和undo-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/04/mysql之redo-log和undo-log/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">mysql之日志模块</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-04 18:30:18 / 修改时间：20:18:26" itemprop="dateCreated datePublished" datetime="2018-12-04T18:30:18+08:00">2018-12-04</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>平时在看一些mysql的文章时,不可避免看到过undolog,redolog,binlog等xxlog概念,这些概念都属于mysql的日志模块,这里对这些概念做一次总结。</p>
<h2 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h2><p>redolog也叫重做日志,是innodb特有的一种log,用于保证事务的持久性。在事务提交时,必须将该事务所有事务日志写到磁盘的redologfile 和 undologfile上。</p>
<p>我们知道mysql的数据会持久化到磁盘上,但是如果每次进行更新都写磁盘。磁盘要进行io操作找到这条记录并更改,成本很高。因此mysql就是用了redolog来提升效率。</p>
<p>具体来说,当有一条记录更新时,Innodb将数据循环写到redolog中,更新内存。当数据库空闲时或者redolog满,就会异步刷写到磁盘上。这种基于WAL(预写日志)的存储,都是crash-safe的,因为mysql可以通过redolog在crash之后恢复数据。redo log是在事务开始之后就开始逐步写入磁盘。</p>
<p>关于redolog比较重要的一个参数是innodb_flush_log_at_trx_commit</p>
<ul>
<li><p>innodb_flush_log_at_trx_commit=1,每次commit都会将日志从redo log buffer(用户空间)写到system buffer(内核空间),并fsync刷新到磁盘文件中。</p>
</li>
<li><p>innodb_flush_log_at_trx_commit=2,每次commit都会将日志从redo log buffer(用户空间)写到system buffer(内核空间),由系统决定什么时候fsync到磁盘。如果这时服务器宕机,则会丢失这部分数据。</p>
</li>
<li><p>innodb_flush_log_at_trx_commit=0,mysql每秒从redo log buffer,把数据写入到系统中去。数据库宕机则丢失一秒内的数据。</p>
</li>
</ul>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>binlog是mysql服务器级别的日志,也叫做归档日志,二进制日志。这是因为innodb并不是mysql原生的引擎,binlog只能用于归档,并没有提供crash-safe能力。</p>
<p>binlog在事务提交的时候产生,将事务中的语句按照一定的格式记录到binlog中。这里binlog的功能与redolog有些类似,但是精度也就是可靠性明显不同,redolog作用于事务层面,而binlog则主要用来做数据库备份,同步。另一个区别在于redolog是循环写的,不提供持久保存,而binlog提供归档的功能。</p>
<p>binlog有两种模式:row和statement:statement记录的是sql语句,row模式记录变更前后的内容,会记录两条。因此row模式更安全,但是会是log变大。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>由于redo log和binlog都会记录事务,那么这就对binlog和redolog的提交有要求。如果binlog和redolog的记录不一致,那么就会出现事务不一致的状况,这常常发生在主从复制的环境下。</p>
<p>MySQL通过两阶段提交过程来完成事务的一致性的,也即redo log和binlog的一致性的,先写redo log,处于prepare状态,再写binlog,写成功后进入commit状态。两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h2 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h2><p>undolog也叫回滚日志,保存了事务发生之前数据的版本,可以用来回滚,并提供MVCC。</p>
<p>当我们对数据进行更新操作就会产生undolog,可以把undolog可以理解为一个链表,保存了一个字段连续变化的过程。当我们进行修改时,会将数据备份到undolog,并在undlog中进行修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。undolog正式凭借此保证事务的原子性。</p>
<p>undolog另一个重要作用就是并发读写时支持mvcc(多版本并发控制)机制。当一行数据被写操作锁定时,读操作可以根据事务号到undolog中找到合适版本的数据,而不会写锁阻塞读操作,这就是一致性视图。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/11/29/jvm学习笔记-重载与重写/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/29/jvm学习笔记-重载与重写/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">jvm学习笔记-重载与重写</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-29 13:58:59 / 修改时间：19:23:16" itemprop="dateCreated datePublished" datetime="2018-11-29T13:58:59+08:00">2018-11-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><p>重载与重写是java中相当重要的一组概念,java利用重载和重写实现了多态,看下面一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">void invoke(Object obj, Object... args) &#123; ... &#125;</div><div class="line">void invoke(String s, Object obj, Object... args) &#123; ... &#125;</div><div class="line"></div><div class="line">invoke(null, 1);    // 调用第二个 invoke 方法</div><div class="line">invoke(null, 1, 2); // 调用第二个 invoke 方法</div></pre></td></tr></table></figure>
<p>在java中,如果一个类中存在相同名字的函数,并且参数也相同,那么它是无法通过编译的。那么就需要修改参数类型让他们不同,这种方法之间的关系,就是重载。</p>
<p>重载的方法在编译阶段就可以识别,有以下几个原则:</p>
<ol>
<li>首先在不进行自动装箱/拆箱的情况下调用方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void test(int i )&#123;</div><div class="line">    System.out.println(&quot;test int&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public void test(Integer i)&#123;</div><div class="line">    System.out.println(&quot;test integer&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    Rich r = new Rich();</div><div class="line">    r.test(1);  // 执行第一个</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在1不匹配的情况下,允许自动拆箱装箱,不优先选择带有可变长参数方法:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void test(int i,String hello)&#123;</div><div class="line">    System.out.println(&quot;test int&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public void test(Integer i,String ... hellos)&#123;</div><div class="line">    System.out.println(&quot;test integer&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    Rich r = new Rich();</div><div class="line">    r.test(1,&quot;1&quot;); //执行第一个</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在2不匹配的情况下,允许自动装箱拆箱/允许可变长参数</li>
</ol>
<p>除了同一个类中的方法,重载也可以作用于父类与子类之间,如果子类定义了与父类方法名称相同而参数类型不同,那么这两个方法也构成了重载。</p>
<p>那么如果子类定义了与父类非私有方法同名的方法,并且参数类型也相同,那么这时子类重写了父类的方法。方法的重写,正是多态的一种重要体现方式,它允许子类继承父类部分功能的同时,拥有自己独特的行为。</p>
<p><excerpt in="" index="" |="" 首页摘要=""><br>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/29/jvm学习笔记-重载与重写/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/11/27/表面理解jvm-类加载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/11/27/表面理解jvm-类加载/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">jvm学习笔记-类加载</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-27 08:07:39" itemprop="dateCreated datePublished" datetime="2018-11-27T08:07:39+08:00">2018-11-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-11-28 16:41:44" itemprop="dateModified" datetime="2018-11-28T16:41:44+08:00">2018-11-28</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h2><blockquote>
<p>当我们写好.java程序点击运行的时候发生了什么</p>
</blockquote>
<ol>
<li>当我们写好.java的源程序，使用javac命令把源程序编译成.class文件，编译后的.class文件(类字节码文件)包括以下内容:</li>
</ol>
<ul>
<li>以魔数Magic Number:0xCafeBabe开头</li>
<li>ConstantPool:符号表</li>
<li>FieldInfo:类成员变量表</li>
<li>方法描述</li>
<li>附加节点</li>
<li>…</li>
</ul>
<ol>
<li><p>有了.class文件我们就可以执行java命令运行java程序</p>
</li>
<li><p>首先JVM装载.class，也就是类加载器加载字节码。但是类加载器本身也是一个java类，所以它也需要被加载，幸运的是有一个类加载器是用c++编写的，叫做<code>Bootstrap类加载器</code>，属于虚拟机内核，用特定于操作系统的本地代码实现。Bootstrap类加载器负责加载javajava核心包中的类(rt.jar)，这些类的Class.getClassLoader()方法返回值会null，表示需要Bootstrap加载器来加载。JAVA核心包中还有两个类加载器:<code>ExtClassLoader</code>和<code>ApplicationClassLoader</code>。他们都用java语言编写，其中ExtClassLoader负责加载<java_home>/jre/lib/ext目录下的jar，ApplicationClassLoader负责加载应用程序的启动执行类，即当使用java命令去启动执行一个类时，JAVA虚拟机使用AppClassLoader加载这个类。所以这里有个小track就是把一些自己常用但是非java自带的jar放到ext目录下，这样就可以少写几个maven dependency。</java_home></p>
</li>
</ol>
<p><excerpt in="" index="" |="" 首页摘要=""></excerpt></p>
<ul>
<li>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/11/27/表面理解jvm-类加载/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
         
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/123.png"
                alt="Shuchang" />
            
              <p class="site-author-name" itemprop="name">Shuchang</p>
              <p class="site-description motion-element" itemprop="description">多喝热水</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">96</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitee.com/swiftsc" title="GitHub &rarr; https://gitee.com/swiftsc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/shuchang0403@gmail.com" title="E-Mail &rarr; shuchang0403@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">浙ICP备17049505号 </a>&copy; 2015 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuchang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    






  





  

  

  

  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
