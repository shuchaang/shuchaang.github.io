<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="多喝热水">
<meta property="og:type" content="website">
<meta property="og:title" content="ShuChang&#39;s Blog">
<meta property="og:url" content="http://www.shuchang.sc.com/page/3/index.html">
<meta property="og:site_name" content="ShuChang&#39;s Blog">
<meta property="og:description" content="多喝热水">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ShuChang&#39;s Blog">
<meta name="twitter:description" content="多喝热水">






  <link rel="canonical" href="http://www.shuchang.sc.com/page/3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ShuChang's Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ShuChang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">剑来!</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签<span class="badge">26</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类<span class="badge">20</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档<span class="badge">101</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2019/02/02/Socket网络编程-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/02/Socket网络编程-2/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">Socket网络编程-2</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-02 11:29:31" itemprop="dateCreated datePublished" datetime="2019-02-02T11:29:31+08:00">2019-02-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-03 23:05:36" itemprop="dateModified" datetime="2019-02-03T23:05:36+08:00">2019-02-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP初始化配置"><a href="#TCP初始化配置" class="headerlink" title="TCP初始化配置"></a>TCP初始化配置</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">private static Socket createSocket() throws IOException &#123;</div><div class="line">    //相当于无参构造函数</div><div class="line">    Socket socket = new Socket(Proxy.NO_PROXY);</div><div class="line"></div><div class="line">    //具有http代理的构造</div><div class="line">    Proxy proxy = new Proxy(Proxy.Type.HTTP,</div><div class="line">            new InetSocketAddress(InetAddress.getByName(&quot;www.baidu.com&quot;),8080));</div><div class="line">    socket = new Socket(proxy);</div><div class="line"></div><div class="line">    //直连模式</div><div class="line">    socket = new Socket(&quot;localhost&quot;,20000);</div><div class="line"></div><div class="line">    //指定本地端口 连接到20000端口的服务器,客户端使用20001端口</div><div class="line">    socket = new Socket(InetAddress.getLocalHost(),2000,InetAddress.getLocalHost(),</div><div class="line">            20001);</div><div class="line"></div><div class="line">    //作用同上</div><div class="line">    socket = new Socket();</div><div class="line">    socket.bind(new InetSocketAddress(InetAddress.getLocalHost(),20001));</div><div class="line">    socket.connect(new InetSocketAddress(InetAddress.getLocalHost(),20000));</div></pre></td></tr></table></figure>
<p>Socket有如上几种常见的初始化方式,推荐的做法是使用无参的构造函数,因为有参数的构造函数会在初始化之后就进入连接状态,在连接之后如果想进行一定的参数配置,那么这是无效的。</p>
<p>下面给出一些常见的socket配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">private static void initSocket(Socket socket) throws SocketException &#123;</div><div class="line">    // 设置读取超时时间为2s</div><div class="line">    socket.setSoTimeout(2000);</div><div class="line">    //是否复用未完全关闭的socket地址</div><div class="line">    socket.setReuseAddress(true);</div><div class="line">    //是否开启nagle算法,默认开启. 关闭后可以理解为允许批量ack,而不是对于每个数据包都需要ack</div><div class="line">    socket.setTcpNoDelay(false);</div><div class="line">    //长时间无响应时发送确认数据,默认2h</div><div class="line">    socket.setKeepAlive(true);</div><div class="line"></div><div class="line">    //表示对于close操作如何处理</div><div class="line">    //1. false,0 默认情况,关闭时立即返回,底层接管缓冲区,如果没有发送完,则继续</div><div class="line">    //2. true,0 关闭时立即返回,缓冲区数据抛弃,发送RST到对方,无需等待2MSL</div><div class="line">    //3.  true,xx 最长阻塞200ms,然后按照2处理</div><div class="line">    socket.setSoLinger(true,200);</div><div class="line"></div><div class="line">    //是否让业务层接收到紧急数据,默认关闭,建议关闭 可以调用socket.sendUrgentData(1)发送参数的后八位</div><div class="line">    socket.setOOBInline(false);</div><div class="line"></div><div class="line">    //设置缓冲区大小</div><div class="line">    socket.setReceiveBufferSize(64*1024*1024);</div><div class="line">    socket.setSendBufferSize(64*1024*1024);</div><div class="line"></div><div class="line">    //设置连接时间,延迟,带宽对于socket性能评估的权重,如更关心延迟,则可以调高第二个参数</div><div class="line">    socket.setPerformancePreferences(1,1,1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在经过自定义的配置之后,再进行socket的bind和connect操作比较合理。</p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static ServerSocket createSocket() throws IOException &#123;</div><div class="line">        ServerSocket ss = new ServerSocket();</div><div class="line">        //等待连接的队列容量为50</div><div class="line">        ss.bind(new InetSocketAddress(InetAddress.getLocalHost(),20001),50);</div><div class="line"></div><div class="line">        ss = new ServerSocket(20001,50);</div><div class="line"></div><div class="line">        return ss;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>服务端的socket初始化比较简单,同样推荐使用空的构造函数,以便进行后续配置。服务端socket提供了一个backlog参数,用来表示有多少连接可以加入等待队列,当有空闲时就会从队列中取出连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void initServerSocket(ServerSocket ss) throws SocketException &#123;</div><div class="line">        ss.setReuseAddress(true);</div><div class="line">        ss.setReceiveBufferSize(64*1024*1024);</div><div class="line">        ss.setSoTimeout(2000);</div><div class="line">        ss.setPerformancePreferences(1,1,1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>配置参数也比较简单,要注意的是,这里的bufferSize并不是serverSocket的bufferSize,而是accept的client的bufferSize。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2019/02/01/Socket网络编程-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/01/Socket网络编程-1/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">Socket网络编程-1</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-01 12:50:56" itemprop="dateCreated datePublished" datetime="2019-02-01T12:50:56+08:00">2019-02-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-02 11:29:51" itemprop="dateModified" datetime="2019-02-02T11:29:51+08:00">2019-02-02</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/socket/" itemprop="url" rel="index"><span itemprop="name">socket</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在研究Dubbo原理,想深入进去发现内部网络框架使用了Netty,而之前研究过很久Netty发现已经忘得差不多了。回头看了一下Netty,发现自己对底层的网络、Socket都不是很熟悉,所以这里从更底层的socket入手,后面再总结Dubbo。</p>
<h2 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzr71jnsy9j30rw0k875b.jpg" alt=""></p>
<p>这是大学教材上计网的第一课,OSI是一个非常理想化的模型,并没有在实际中应用。</p>
<p>最上层是应用层,也就是我们编写app所在的层级,下一层表示层就是用来将应用层的信息表示成数据层面的东西,例如将字符串转换为byte数组。会话层的主要功能是在两个节点间建立、维护和释放面向用户的连接,并对会话进行管理和控制,保证会话数据可靠传送。传输层的作用就是在必要的时候对消息进行分割,并保证有效性,向下交给网络层。网络层的作用就是控制子网的运行,例如对逻辑地址进行分组的传输,以及路由的选择。数据链路层更加底层,是对物理地址的一个寻找,并将原始比特流转换为逻辑的传输路线,物理层可以理解为比特流与电信号之间的转换。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fzr7djjmjsj30t60kwad1.jpg" alt=""></p>
<p>上图是一个tcp/ip模型与osi模型的映射关系以及一些常见的协议。</p>
<h2 id="Socket与TCP-UDP"><a href="#Socket与TCP-UDP" class="headerlink" title="Socket与TCP/UDP"></a>Socket与TCP/UDP</h2><p>Socket简单来说是一个端口+ip的结合描述协议(RFC793),是TCP/IP协议相关API的总称,是网络API的集合实现,涵盖了Datagram socket和stream socket。</p>
<p>TCP是面向连接的协议,通过三次握手建立连接,通讯完成后拆除连接。</p>
<p>UDP是面向无连接的通讯协议,数据包括源端口号和目标端口号,由于通讯不是端到端的,所以可以实现广播发送</p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>一个简单的socket通信编程demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public class Server &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket server = new ServerSocket(2000);</div><div class="line">        System.out.println(&quot;服务器启动&quot;);</div><div class="line"></div><div class="line">        //等待连接</div><div class="line">        for(;;)&#123;</div><div class="line">            Socket client = server.accept();</div><div class="line">            if(client!=null)&#123;</div><div class="line">                ClientHandle clientHandle = new ClientHandle(client);</div><div class="line">                clientHandle.start();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class ClientHandle extends Thread&#123;</div><div class="line">        private Socket socket;</div><div class="line">        private boolean flag = true;</div><div class="line"></div><div class="line">        ClientHandle(Socket socket)&#123;</div><div class="line">            this.socket = socket;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            System.out.println(&quot;客户端连接&quot;+socket.getPort());</div><div class="line">            try &#123;</div><div class="line">                    PrintStream socketOutput = new PrintStream(socket.getOutputStream());</div><div class="line">                    BufferedReader socketInput  = new BufferedReader(</div><div class="line">                            new InputStreamReader(socket.getInputStream()));</div><div class="line">                do&#123;</div><div class="line">                    String str = socketInput.readLine();</div><div class="line">                    if(str.equalsIgnoreCase(&quot;bye&quot;))&#123;</div><div class="line">                        socketOutput.println(str);</div><div class="line">                        flag=false;</div><div class="line">                    &#125;else&#123;</div><div class="line">                        System.out.println(str);</div><div class="line">                        socketOutput.println(&quot;reply &quot;+str);</div><div class="line">                    &#125;</div><div class="line">                &#125;while (flag);</div><div class="line">                socketInput.close();</div><div class="line">                socketOutput.close();</div><div class="line">            &#125;catch (Exception e)&#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;finally &#123;</div><div class="line">                try &#123;</div><div class="line">                    socket.close();</div><div class="line">                &#125; catch (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(&quot;客户端断开&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        Socket socket = new Socket();</div><div class="line">        socket.setSoTimeout(3000);</div><div class="line">        socket.connect(new InetSocketAddress(Inet4Address.getLocalHost(),2000));</div><div class="line">        System.out.println(&quot;连接完成&quot;);</div><div class="line">        try &#123;</div><div class="line">            todo(socket);</div><div class="line">        &#125;catch (Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        socket.close();</div><div class="line">        System.out.println(&quot;客户端退出&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void todo(Socket socket) throws IOException &#123;</div><div class="line">        InputStream in = System.in;</div><div class="line">        BufferedReader input = new BufferedReader(new InputStreamReader(in));</div><div class="line">        //得到socket输出流,打印</div><div class="line">        OutputStream outputStream = socket.getOutputStream();</div><div class="line">        PrintStream printStream = new PrintStream(outputStream);</div><div class="line"></div><div class="line">        InputStream inputStream = socket.getInputStream();</div><div class="line">        BufferedReader sbuff = new BufferedReader(new InputStreamReader(inputStream));</div><div class="line"></div><div class="line">        boolean  flag=true;</div><div class="line">        do &#123;</div><div class="line">            String str = input.readLine();</div><div class="line">            printStream.println(str);</div><div class="line"></div><div class="line">            String ret = sbuff.readLine();</div><div class="line">            if (&quot;bye&quot;.equalsIgnoreCase(ret)) &#123;</div><div class="line">                flag=false;</div><div class="line">            &#125;else&#123;</div><div class="line">                System.out.println(ret);</div><div class="line">            &#125;</div><div class="line">        &#125;while (flag);</div><div class="line">        sbuff.close();</div><div class="line">        inputStream.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面简单写了一个socket通信的demo,可以看到本身java调用socket进行连接是非常简单的,但是一旦涉及到这些IO读写就会变得很复杂,各种stream,reader之间相互转换,后面再对java io进行一下总结。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2019/01/02/ThreadLocal源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/02/ThreadLocal源码阅读/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">ThreadLocal源码阅读</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-02 12:28:49" itemprop="dateCreated datePublished" datetime="2019-01-02T12:28:49+08:00">2019-01-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-02-20 12:29:24" itemprop="dateModified" datetime="2019-02-20T12:29:24+08:00">2019-02-20</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ThreadLocal是开发中比较常用的一个工具,可以用来传递变量或者做数据隔离。那么ThreadLocal是如何实现线程隔离呢,可以通过set方法来看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">       Thread t = Thread.currentThread();</div><div class="line">       ThreadLocalMap map = getMap(t);</div><div class="line">       if (map != null)</div><div class="line">           map.set(this, value);</div><div class="line">       else</div><div class="line">           createMap(t, value);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   </div><div class="line">   ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">       return t.threadLocals;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>首先set方法获取了当前线程,然后获取当前线程的threadLocals变量,其中ThreadLocalMap类的定义是在ThreadLocal类中，真正的引用却是在Thread类中。得到map后如果不为null,则将当前threadLocal对象作为key,放入map,否则创建一个map再赋值。</p>
<p>刚开始看这里很让人费解的一个地方就是为什么要用ThreadLocal对象作为key呢？为什么不能直接以当前线程的ID作为key呢?</p>
<p>这里想了很久突然明白了,因为一个线程可以创建多个ThreadLocal去存储变量,那么如果我用线程ID去作为key,那么当有多个threadLocal的时候就不知道取哪一个了,所以使用threadLocal作为key,但其实还是取了threadLocal内部的一个hashcode作为唯一标示。</p>
<p>进入ThreadLocalMap源码,它的实现是一个Entry数组,Entry的key为ThreadLocal的弱引用,value为变量值。也就是说在这里如果使用threadLocal对象作为key,有一个好出就是当发生gc时,没有用的threadLocal会被回收,而如果使用线程ID,则这个threadLocal不会被回收。但是threadLocalMap对象并没有被回收,也就是说value是个强引用,key被回收后会形成一个key为null的Entry。</p>
<p>所以这时如果这个线程是个耗时非常长的业务,或者你在线程池中使用了threadLocal,那么这里就会一直存在内存占用,过多就形成了内存泄露。 </p>
<p>为了解决这个问题,map的get/set操作都会对无效的key进行清理,或者调用remove方法进行清理,所以这里依赖于程序员的良好习惯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line"></div><div class="line">            // We don&apos;t use a fast path as with get() because it is at</div><div class="line">            // least as common to use set() to create new entries as</div><div class="line">            // it is to replace existing ones, in which case, a fast</div><div class="line">            // path would fail more often than not.</div><div class="line"></div><div class="line">            Entry[] tab = table;</div><div class="line">            int len = tab.length;</div><div class="line">            int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">            for (Entry e = tab[i];</div><div class="line">                 e != null;</div><div class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">                ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">                if (k == key) &#123;</div><div class="line">                    e.value = value;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (k == null) &#123;</div><div class="line">                    replaceStaleEntry(key, value, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            tab[i] = new Entry(key, value);</div><div class="line">            int sz = ++size;</div><div class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">                rehash();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>那么key是否可以作为一个强引用呢?使用强引用会带来什么问题呢?</p>
<p>如果key使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。所以这里使用弱引用如果有良好的习惯,每次操作完remove,造成的问题会比强引用小。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/26/消息队列使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/26/消息队列使用总结/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">消息队列阶段性使用总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-26 09:43:29 / 修改时间：16:45:37" itemprop="dateCreated datePublished" datetime="2018-12-26T09:43:29+08:00">2018-12-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一年多来在工作中接触了Kafka、ActiveMQ,业余时间自己学习了RabbitMQ,基本上已经是市面上主流的几款MQ软件了,后面有时间会继续看一下RocketMQ。</p>
<p>MQ虽然可以用来对系统进行异步调用、解耦,提高用户体验和优化架构。但是MQ降低了系统的可用性,因为当系统进行MQ的改造后,MQ的故障会导致下游的服务不可用和分布式一致性问题。所以在技术上首先要保证MQ集群始终处于可用的状态。</p>
<h2 id="MQ集群方案"><a href="#MQ集群方案" class="headerlink" title="MQ集群方案"></a>MQ集群方案</h2><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>kafka的集群依赖于Zookeeper,因此首要保证ZK的可用性,可以使用3-5台(2n+1)。Zookeeper集群的工作是超过半数才能对外提供服务。</p>
<p>接着部署多台Kafka,注册到ZK上,Kafka会通过选举选出leader和follower以及replica机制提供集群高可用</p>
<h3 id="activeMQ"><a href="#activeMQ" class="headerlink" title="activeMQ"></a>activeMQ</h3><p>activemq提供了多种Master/slave模式的集群,公司使用Replicated LevelDB Store的集群方式,也是5.9版本后官方推荐的一种集群方式</p>
<p>Replicated LevelDB Store方案使用Zookeeper选举Master。要进行选举，则需要多数派的“参与者”。因为Replicated LevelDB Store中有多个Broker，从多个Broker中选举出一个成为Master，其他的则成为Slave。只有Master接收Client的连接，Slave负责连接到Master，并接收（同步方式、异步方式）Master上的数据。<br> 比如说：一共有3个Broker，一个Master，二个Slave。当新消息到达Master时，Master需要将消息同步到其中一台Slave之后，才能向Producer发送ACK确认此次消息成功发送。<br>而剩下的另一台Slave，则可以在后台以异步方式复制这个新消息。此外，还能容忍一台Slave宕机。（能容忍不超过大多数的Broker宕机）</p>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>常见的RabbitMQ集群有两种:</p>
<ol>
<li>普通模式</li>
</ol>
<p>对于Queue来说,消息只会存储在一个MQ节点上,当请求到达其他节点时,其他节点会来临时请求这个节点的消息。这样做避免了各个节点消息同步,节省了空间,但是当存储消息的节点挂掉,在恢复之前消息都会丢失。</p>
<ol>
<li>镜像模式</li>
</ol>
<p>把需要的队列做成镜像队列。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。</p>
<h2 id="消息生产保障"><a href="#消息生产保障" class="headerlink" title="消息生产保障"></a>消息生产保障</h2><p>一个非常常见的问题是,怎么保证投递出去的消息一定不会丢失？</p>
<p>个人认为,这个问题可以拆分为如何保证生产端消息投递成功,如何保证消费端一定收到消息这样两个问题:</p>
<h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><ol>
<li>rabbitmq在发送端提供了publish-confirm和publish-return机制。</li>
</ol>
<p>publish-return机制用来告诉生产者消息有没有被路由到正确的queue中,如果找到的正确的destination则会返回ack,否则返回unack。</p>
<p>publish-confirm能够在消息进入目标队列后返回一个ack或者unack告诉生产端,如果broker正确处理这条消息,会返回ack。如果broker内部处理时发生了异常,就会返回unack。</p>
<p>这就使得生产者知道消息是否正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出。confirm是一种异步的机制,发送者不必等待消息的确认。confirm机制可以视为一种发送端的事务机制,生产端通过回调消息来对消息进行重新处理。但是Confirm机制，无法进行回滚，就是一旦服务器崩溃，生产者无法得到Confirm信息，生产者其实本身也不知道该消息是否已经被持久化，只有继续重发来保证消息不丢失，但是如果原先已经持久化的消息，并不会被回滚，这样队列中就会存在两条相同的消息，系统需要支持去重。</p>
<ol>
<li>ActiveMQ</li>
</ol>
<p>Activemq应该是没有专门为生产端保证消息投递的确认机制,我在做这里的时候是根据抛出的JMSException来进行一些补偿处理,同样这里会遇到的问题是你并不确认这个消息是否真的到达了消息队列,当你进行补偿时可能造成了重复消息,这同样需要消费端支持消息去重。</p>
<ol>
<li>Kafka</li>
</ol>
<p>对于Kafka,注重的是高吞吐,一般涉及业务逻辑的消息都不会选择kafka,它提供了三种可靠性投递保证:</p>
<ul>
<li>生产端发送出去就算成功</li>
<li>Master-Slave模型，只有当Master和所有Slave都接收到消息时，才算投递成功，这种模型提供了最高的投递可靠性，但是损伤了性能</li>
<li>即只要Master确认收到消息就算投递成功</li>
</ul>
<p>实际使用中都会折中选择第三种方案</p>
<h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>对于消费端,大多数业务系统都会选择进行手动签收。当取到消息,进行正确处理并入库,才会对broker返回ack。</p>
<h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>仅仅依赖于上述消息队列提供的消息保证机制是不够的,因为MQ并不擅长做这个。对于业务要求比较严格的场景,每条消息都需要可追溯,也就需要对消息落库,并通过定时任务扫描状态异常的消息,进行重新发送或者人工干预。</p>
<p>对于吞吐率要求比较高的系统,落库的负担就太大,这时比较常用的一种方案就是延迟确认消息。在发送业务消息的同时发送一条延迟确认消息,确认消费端系统是否正确处理消息。这种方案在于提高了系统的吞吐量但是可能造成一段时间内业务状态不一致。</p>
<h2 id="如何保证消息不重复"><a href="#如何保证消息不重复" class="headerlink" title="如何保证消息不重复"></a>如何保证消息不重复</h2><p>虽然这时我们解决了消息投递问题,但是它又引入了消息重复的问题。消息重复投递的原因可能在broker,也可能在生产端和消费端。那么我们可以把问题简化为如何保证消费端消费消息的幂等性,那么这时就可以忽略broker和生产者带来的问题。</p>
<p>首先每个消息都会有一个MessageID,这应该是全局唯一的。消费端要做的就是将存储MessageId以及这条消息的处理状态。当消息来的时候首先要在消息表对比是否已经成功处理这条消息,成功处理则将这条消息丢弃。这里消费端需要注意控制并发,因为重复消息可能同时到达,在并发消费。在查询时可以限制时间范围,因为一般重复消息间隔时间不会太久。</p>
<h2 id="消息顺序消费保证"><a href="#消息顺序消费保证" class="headerlink" title="消息顺序消费保证"></a>消息顺序消费保证</h2><ol>
<li>rabbitmq/activemq 保证消息顺序是通过独占队列(exclusive)来保证,这样虽然可以严格保证消息顺序,但是无法进行扩展,吞吐率低。对于QPS高的系统确实是无法承受的。更好的处理方式就是不处理,因为MQ并不是设计来做这些的。所以消费端就需要对消息顺序做处理。生产端在消息中附加额外的信息,版本号 &amp; 状态机 &amp; msgid &amp; parent_msgid，通过 parent_msgid 判断消息的顺序（需要全局存储，记录消息的执行状态）</li>
</ol>
<ol>
<li>如果要Kafka本身保证顺序消费,就失去了使用Kafka的意义。这种场景不应该选择kafka。只能将处理逻辑放到应用中。</li>
</ol>
<h2 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h2><p>关键还是在消费端进行配置,有两个关键参数:concurrentConsumerCount 和 prefetchCount。可以适当提高这两个参数。</p>
<h2 id="各个MQ的缺陷"><a href="#各个MQ的缺陷" class="headerlink" title="各个MQ的缺陷"></a>各个MQ的缺陷</h2><p>相比于知道各个MQ的优势,知道它们的劣势更加重要,因为在选型的时候首先要将不能满足要求的进行排除</p>
<h3 id="AMQ"><a href="#AMQ" class="headerlink" title="AMQ"></a>AMQ</h3><p>AMQ的消息模型比较简单,只支持PTP和topic两种模式。对于消息分组的场景支持比较弱(依赖于消费端的选择器),权限精度不高,社区不活跃可用插件比较少,控制台功能比较简单。</p>
<p>据说会有消息丢失等问题,但是我没遇到过。</p>
<h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>相比于AMQ有更高的性能,相比于Kafka支持更多的场景。在产生消息堆积时性能会有大幅度下降,使用erlang开发,进行修改或二次开发比较困难。是大多数互联网公司的选择。</p>
<h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><p>速度快,吞吐量高,适合处理大量数据,如日志场景。Kafka的核心概念就是partition,consumer消费是通过绑定partition来消费的。如果consumer数量大于partition数量就会浪费,所以最佳就是consumer和partition成比例关系。这种静态的绑定会导致扩缩容的麻烦,也就是当流量高峰时,仅仅增加consumer不能解决问题,还要增加partition。但是partition增加后又不能再减少,最后导致rebalance。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/08/JMS-7-Consumer高级特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/08/JMS-7-Consumer高级特性/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(7) Consumer高级特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 14:31:51" itemprop="dateCreated datePublished" datetime="2018-12-08T14:31:51+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:29" itemprop="dateModified" datetime="2018-12-26T09:46:29+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="独占消费者"><a href="#独占消费者" class="headerlink" title="独占消费者"></a>独占消费者</h2><p>Queue中的消息是按照顺序分发到consumer。然而当你有多个consumer的时候,这个顺序就无法进行保证。可以通过设置消息独占来保证顺序消费问题,这样broker会在consumer中选择一个进行发送,如果发送期间consumer挂掉,broker会自动切换到其他consumer上进行发送。</p>
<p>创建独占消费者方式如下,还可以配合优先级进行优化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Queue queue6()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;ex.q?consumer.exclusive=true&amp;consumer.priority=10&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Message-Group"><a href="#Message-Group" class="headerlink" title="Message Group"></a>Message Group</h2><p>Message Group可以看成一种并发的exclusive consumer。JMS消息属性JMSXGroupID用来区分message group。Message Group特性保证所有具有相同JMSXGroupID的消息会被分发到相同的consumer。</p>
<p>除此之外,Message Group也是一种负载均衡机制,在一个消息被分发到consumer之前,会去检查消息JMSXGroupID,如果存在,broker会寻找相同JMSXGroupID的consumer。如果没有,broker会选择一个consumer,并将它关联到这个Message Group。此后这个consumer 都会收到这类Message,知道consumer关闭或者Message Group关闭(发送一个消息,设置JMSXGroupSeq为-1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jmsTemplate.send(&quot;queue.a&quot;,new MessageCreator() &#123;</div><div class="line">            @Override</div><div class="line">            public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                TextMessage message = session.createTextMessage();</div><div class="line">                message.setStringProperty(&quot;JMXGroupID&quot;,&quot;G1&quot;);</div><div class="line">                return message;</div><div class="line">            &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="消息选择器"><a href="#消息选择器" class="headerlink" title="消息选择器"></a>消息选择器</h2><blockquote>
<p>参考<a href="https://www.cnblogs.com/ywjy/articles/5433826.html" target="_blank" rel="external">https://www.cnblogs.com/ywjy/articles/5433826.html</a></p>
</blockquote>
<p>通过类sql的语法,为consumer指定message的筛选条件。</p>
<p>发送端设置属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jmsTemplate.send(topic1, new MessageCreator() &#123;</div><div class="line">            @Override</div><div class="line">            public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                TextMessage textMessage = session.createTextMessage();</div><div class="line">                textMessage.setIntProperty(&quot;count&quot;,10);</div><div class="line">                return textMessage;</div><div class="line">            &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>消费端过滤属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@JmsListener(destination = &quot;file&quot;,selector = &quot;count &gt; 5&quot;)</div></pre></td></tr></table></figure>
<h2 id="慢消费"><a href="#慢消费" class="headerlink" title="慢消费"></a>慢消费</h2><p>慢消费会在非持久的topic上出现问题,导致消息积压在broker内存中,拖垮整个broker。除了调整客户端prefetchSize,目前AMQ使用Pending Message Limit Strategy来解决这个问题。</p>
<p>Pending Message Limit Strategy(等待消息限制策略)有两种:</p>
<ol>
<li>Constant Pending Message Limit Strategy:</li>
</ol>
<p>limit 大小可以设置为0,-1,&gt;0。0表示不额外增加预存大小,-1表示不增加也不丢弃消息,&gt;0表示需要额外增加的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;constantPendingMessageLimitStrategy limit=&quot;50&quot;&gt;</div></pre></td></tr></table></figure>
<ol>
<li>Prefetch Rate Pending Message Limit Strategy:</li>
</ol>
<p>参数表示扩大目前prefetchSize的多少倍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;PrefetchRatePendingMessageLimitStrategy multiplier=&quot;3&quot;&gt;</div></pre></td></tr></table></figure>
<p>添加配置的位置在destinationPolicy-&gt;policyMap-&gt;policyEntries-&gt;policyEntry中。</p>
<p>消息丢弃策略目前提供三种:</p>
<ol>
<li><p>oldestMessageEvicationStrategy:丢弃最旧的消息</p>
</li>
<li><p>oldestMessageWithLowestPriorityEvicationStrategy:最旧且优先级最低</p>
</li>
<li><p>uniquePropertyMessageEvicationStrategy: 根据消息设置的属性来丢弃消息</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uniquePropertyMessageEvicationStrategy propertyName=&quot;STOCK&quot; /&gt;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/08/JMS-6-Message高级特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/08/JMS-6-Message高级特性/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(6) Message高级特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 12:09:46" itemprop="dateCreated datePublished" datetime="2018-12-08T12:09:46+08:00">2018-12-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:33" itemprop="dateModified" datetime="2018-12-26T09:46:33+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="延时投递与定时投递"><a href="#延时投递与定时投递" class="headerlink" title="延时投递与定时投递"></a>延时投递与定时投递</h2><p>AMQ提供了对消息的定时调度机制,只需要把调度信息设置在message中即可。</p>
<p>首先要在xml中开启设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schedulerSupport=&quot;true&quot;</div></pre></td></tr></table></figure>
<ul>
<li>一共四个属性:</li>
</ul>
<ol>
<li>AMQ_SCHUDULED_DELAY: 延迟投递的时间</li>
<li>AMQ_SCHUDULED_PERIOD: 延迟投递时间间隔</li>
<li>AMQ_SCHUDULED_REPEAT: 重复次数</li>
<li>AMQ_SCHUDULED_CRON: cron表达式</li>
</ol>
<ul>
<li>AMQ也提供了封装的消息类型:org.apache.activemq.scheduledMessage</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jmsTemplate.send(new MessageCreator() &#123;</div><div class="line">                @Override</div><div class="line">                public Message createMessage(Session session) throws JMSException &#123;</div><div class="line">                    TextMessage textMessage = session.createTextMessage();</div><div class="line">                    //设置延时投递 60s</div><div class="line">                    textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY,60*1000);</div><div class="line">                    //重复3次</div><div class="line">                    textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT,3);</div><div class="line">                    return textMessage;</div><div class="line">                &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Blob-Message"><a href="#Blob-Message" class="headerlink" title="Blob Message"></a>Blob Message</h2><p>BlobMessage是用来传递较大的二进制信息,在AMQ的新版本中,默认是关闭的,因为这种方式可能造成安全漏洞。</p>
<p>可以在发送端的url上进行设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://192.168.1.1:61619?jms.blobTransferPolicy.uploadUrl=http://xx.xx.xx.xx/nsfvol/fhms/</div></pre></td></tr></table></figure>
<p>sending blobmessage的方式:</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fxzba3faj1j31880dm3zo.jpg" alt=""></p>
<p>可以看到这里有三种发送blob Message的方式: url、File 或者 Inputstream,这里需要注意的是由于blobMessage是AMQ提供的扩展,所以要将jms的session强转为Amq的session。</p>
<p>文件接收方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@JmsListener(destination = &quot;file&quot;)</div><div class="line">    public void fileQ(Message message) throws IOException, JMSException &#123;</div><div class="line">        if(message instanceof BlobMessage)&#123;</div><div class="line">            BlobMessage blobMessage = (BlobMessage) message;</div><div class="line">            InputStream inputStream = blobMessage.getInputStream();</div><div class="line">            byte[] data = new byte[inputStream.available()];</div><div class="line">            inputStream.read(data);</div><div class="line">            inputStream.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/07/JMS-5-AMQ-Message-Dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/07/JMS-5-AMQ-Message-Dispatch/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(5)-AMQ Message Dispatch</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 15:25:47" itemprop="dateCreated datePublished" datetime="2018-12-07T15:25:47+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:35" itemprop="dateModified" datetime="2018-12-26T09:46:35+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Message-Cursor"><a href="#Message-Cursor" class="headerlink" title="Message Cursor"></a>Message Cursor</h2><p>AMQ发送持久化消息的典型处理方式为,当消费者准备就绪,broker把存储的消息按批次发送给消费者,发送完成后,指针向后移动。这时一种比较理想的方式。在AMQ 5.0版本之后,消息发送开始采用一种混合模式,当消费者活跃时,直接将持久消息发送给消费者,当消费者不活跃时,采用cursor来处理发送消息。</p>
<blockquote>
<p>当消费者活跃,处理能力比较强时,消息的直接发送到消费端</p>
</blockquote>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxy9mb9u2lj30pu0dgjr9.jpg" alt=""></p>
<blockquote>
<p>当消息产生积压,消费者再度活跃时,或者消费者的消费速度比生产速度慢时,消息从pending cursor取出,发送到消费队列。</p>
</blockquote>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxy9tgmrq3j30qi0bqdfq.jpg" alt=""></p>
<p>Message Cursor有三种类型:</p>
<ol>
<li>Store-based</li>
</ol>
<p>AMQ 5.0之后的默认类型,支持持久化和非持久化,内嵌了file-based。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxyazo6b1wj31100k2jri.jpg" alt=""></p>
<ol>
<li>VM</li>
</ol>
<p>这种方式的消息存储在内存中,这种方式处理很快,但是当出现消费端慢消费就可能出现问题。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxybs0h8uzj30vk09u747.jpg" alt=""></p>
<ol>
<li>File-based</li>
</ol>
<p>当内存达到限制,消息就会被存储到文件系统的临时文件中</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxybvbvzfyj30p80iqt8o.jpg" alt=""></p>
<h2 id="分发策略"><a href="#分发策略" class="headerlink" title="分发策略"></a>分发策略</h2><ol>
<li>严格顺序分发</li>
</ol>
<p>AMQ会保证topic consumer以相同的顺序接收来自同一个producer的消息,但有时也需要保证消费者能以相同的顺序消费来自不同topic producer的消息。例如生产者p1 p2 通过topic关联了c1 c2,p1生产了消息1,2,3而p2生产消息4,5,6。这时c1的消费顺序是123456,而c2的消费顺序是456123。如果我们需要严格保证两个c的消费顺序,这时就会需要严格顺序分发。</p>
<p>保证严格顺序的一个负面效果就是性能会降低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;policyEntry topic=&quot;Orders.&gt;&quot;&gt;</div><div class="line">    &lt;dispatchPolicy&gt;</div><div class="line">        &lt;strictOrderDispatchPolicy/&gt;</div><div class="line">    &lt;/dispatchPolicy&gt;</div><div class="line">&lt;/policyEntry&gt;</div></pre></td></tr></table></figure>
<ol>
<li>轮询分发策略</li>
</ol>
<p>在某些情况下,消息的数量比较少,但每次处理消息的时间会比较长,那么在默认的prefetch参数和dispatch policy下,这些消息会倾向于发送到某个consumer上,就会因为负载不均导致处理时间增加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;policyEntry topic=&quot;Orders.&gt;&quot;&gt;</div><div class="line">    &lt;dispatchPolicy&gt;</div><div class="line">        &lt;roundRobinDispatchPolicy/&gt;</div><div class="line">    &lt;/dispatchPolicy&gt;</div><div class="line">&lt;/policyEntry&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/07/JMS-4-AMQ-Destination特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/07/JMS-4-AMQ-Destination特性/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(4)-AMQ Destination特性</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-07 10:18:25" itemprop="dateCreated datePublished" datetime="2018-12-07T10:18:25+08:00">2018-12-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:39" itemprop="dateModified" datetime="2018-12-26T09:46:39+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="wildcards"><a href="#wildcards" class="headerlink" title="wildcards"></a>wildcards</h2><p>wildcards用来支持名字分层体系,它不属于JMS规范,是AMQ的一个扩展。</p>
<p>AMQ支持三种wildcards:</p>
<ol>
<li><p>‘.’, 路径上名字的分隔符</p>
</li>
<li><p>‘*’, 常见的通配符,匹配路径上的所有</p>
</li>
<li><p>‘&gt;’,递归匹配以这个名字开头的dest</p>
</li>
</ol>
<p>例如下面两个dest:</p>
<p>PRICE.STOCK.CN.WANDA<br>PRICE.STOCK.AM.ALIBABA</p>
<ol>
<li>PRICE.&gt; 匹配所有的价格变动</li>
<li>PRICE.STOCK.&gt;匹配所有的股价变动</li>
<li>PRICE.STOCK.CN.* 匹配所有A股变动</li>
<li>PRICE.STOCK.*.ALIBABA 匹配与阿里相关的股价变动</li>
</ol>
<h2 id="组合队列-composite-destination"><a href="#组合队列-composite-destination" class="headerlink" title="组合队列 composite destination"></a>组合队列 composite destination</h2><p>组合队列允许用一个虚拟的dest代表多个dest,这样就可以通过组合队列在一个操作中同时向多个queue发送消息。</p>
<p>不同队列名用’,’隔开。如果有topic有ptp,则需要写明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">public Queue queue()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;queue.a,queue.b&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public Queue queue2()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;queue://queue.a,topic://topic.a&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="delete-inactive-destination"><a href="#delete-inactive-destination" class="headerlink" title="delete inactive destination"></a>delete inactive destination</h2><p>上面的组合队列可以很大程度上方便使用,但是可能会造成创建过多的队列,那么就需要一种功能能够自动删除无用的队列。当然也可以通过控制台或者jms远程删除。</p>
<p>这种方式需要在配置文件进行配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; schedulePeriodForDestinationPurge=&quot;10000&quot;&gt;</div><div class="line"></div><div class="line">&lt;destinationPolicy&gt;</div><div class="line">    &lt;policyMap&gt;</div><div class="line">        &lt;policyEntries&gt;</div><div class="line">                &lt;policyEntry topic=&quot;&gt;&quot; gcInactiveDestinations=&quot;true&quot; inactiveTimeoutBeforeGC=&quot;30000&quot;&gt;</div><div class="line">                &lt;/policyEntry&gt;</div><div class="line">        &lt;/policyEntries&gt;</div><div class="line">    &lt;/policyMap&gt;</div><div class="line">&lt;/destinationPolicy&gt;</div><div class="line"></div><div class="line">&lt;/destinationPolicy&gt;</div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>schedulePeriodForDestinationPurge 设置检查间隔,单位ms</p>
<p>inactiveTimeoutBeforeGC 表示空闲多久会被删除,单位ms</p>
<p>gcInactiveDestinations=true 删除不活动的队列</p>
<h2 id="Destination-options"><a href="#Destination-options" class="headerlink" title="Destination options"></a>Destination options</h2><p>这个特性是AMQ在JMS规范之外提供的特性,以一种url的方式可以对队列进行一些配置。</p>
<ol>
<li><p>consumer.prefechSize: consumer一次可以拉取的最大消息数量</p>
</li>
<li><p>consumer.maximumPendingMessageLimit: 当存在慢消费的情况时,非持久化的topic允许丢弃消息的最大值</p>
</li>
<li><p>consumer.retroactive: 是否为回溯消费者</p>
</li>
<li><p>consumer.dispatchAsync: 是否异步分发,默认为true</p>
</li>
<li><p>consumer.exclusive: 是否为独占消费者,默认false</p>
</li>
<li><p>consumer.priority: 消费者优先级,默认为0</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Queue queue3()&#123;</div><div class="line">        return new ActiveMQQueue(&quot;queue.c?consumer.priority=false&amp;consumer.prefechSize=10&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Visual-Destitation"><a href="#Visual-Destitation" class="headerlink" title="Visual Destitation"></a>Visual Destitation</h2><p>虚拟dest创建的是逻辑dest,客户端和消费端通过它来生产和消费消息,并把它映射到物理dest。AMQ支持两种方式:</p>
<ol>
<li><p>visual topic 虚拟主题</p>
</li>
<li><p>composite destination 组合</p>
</li>
</ol>
<p>虚拟dest的作用体现在哪里呢?</p>
<p>在AMQ,topic只有在持久订阅下才是持久化的,它的每个订阅者都会收到所有的消息。但它存在两个问题:</p>
<ol>
<li><p>同一个应用只能用一个listener去监听topic,而不能使用多个,通过负载均衡来处理消息(当消费端部署了多个节点,那么每个节点都会消费一遍这个消息,而我们理想的情况是a节点处理n条,b节点处理m条)。虽然PTP模式可以解决这个问题,但明显会创建过多的Queue。所以,又要订阅发布,又要消息分组,JMS本身是不支持的。</p>
</li>
<li><p>同一个应用内,消费者failover问题。由于只能有单个持久订阅者,如果这个订阅者离线,那么消息就无法处理,系统健壮性不足。</p>
</li>
</ol>
<p>为了解决这个问题,AMQ提出了visual topic</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Topic topic()&#123;</div><div class="line">        return new ActiveMQTopic(&quot;VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于消费者来说,只需要创建正常的topic,然后以’VirtualTopic’开头。</p>
<p>对于消费端来说,需要将自己视为一个队列,不同的应用使用不同的队列名,即可表示自己是一个消费端的负载均衡。队列名必须以‘Consume’开头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public Queue queue4()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;Consumer.A.VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Bean</div><div class="line">public Queue queue5()&#123;</div><div class="line">    return new ActiveMQQueue(&quot;Consumer.B.VirtualTopic.Orders&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Mirrored-Queues"><a href="#Mirrored-Queues" class="headerlink" title="Mirrored Queues"></a>Mirrored Queues</h2><p>AMQ中每个Queue中的消息只能被一个consumer消费。但有时候你可能希望监视消息流。因此AMQ提供了mirrored queue机制,broker会把发送到某个queue的消息转发到一个名称类似的topic,监视程序只需要监听这个mirrored queue topic。</p>
<p>首先要对broker进行配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot; brokerName=&quot;localhost&quot; dataDirectory=&quot;$&#123;activemq.data&#125;  useMirroredQueues=&quot;true&quot;&gt;</div></pre></td></tr></table></figure>
<p>如果不进行其他配置,默认的mirror topic前缀是 ‘VirtualTopic.Mirror.’,当然也支持自定义格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;destinationInterceptors&gt;</div><div class="line">    &lt;mirroredQueue copyMessage=&quot;true&quot; postPrefix=&quot;.mirror&quot; prefix=&quot;mirror.&quot;&gt;</div><div class="line">&lt;/destinationInterceptors&gt;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/06/JMS-3-JMS结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/06/JMS-3-JMS结构/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(3)-JMS API结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 15:53:11" itemprop="dateCreated datePublished" datetime="2018-12-06T15:53:11+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:43" itemprop="dateModified" datetime="2018-12-26T09:46:43+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxx3glglroj30n40hm0tm.jpg" alt=""></p>
<p>JMS API的结构还是比较简单的。</p>
<p>创建一个JMS的基本步骤是:</p>
<ol>
<li>创建JMS ConnectionFactory</li>
<li>通过ConnectionFactory创建一个Connection</li>
<li>通过Connection创建jms session</li>
<li>创建destination、producer、consumer</li>
<li>发送消息</li>
<li>关闭资源</li>
</ol>
<h2 id="JmsTempate"><a href="#JmsTempate" class="headerlink" title="JmsTempate"></a>JmsTempate</h2><p>在Springboot中一般使用JmsTempate进行操作,所以对照上面的过程,看一下template是如何进行封装的。</p>
<ol>
<li>引入Pom</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<ol>
<li>code</li>
</ol>
<p>首先在启动类上添加注解@EnableJms,会启动一些JMS的自动配置,包括JmsTempate。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public JmsTemplate(ConnectionFactory connectionFactory) &#123;</div><div class="line">		this();</div><div class="line">		setConnectionFactory(connectionFactory);</div><div class="line">		afterPropertiesSet();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>JmsTemplate的构造函数中需要一个ConnectionFactory,因此会先实例化一个ConnectionFactory。也就对应了上面过程中的第一步。</p>
<p>当注入JmsTemplate我们就可以调用send方法进行消息发送,非常简单。但正是因为它封装的太好了,我们反而不容易了解它的具体实现细节,所以进入send方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void send(final Destination destination, final MessageCreator messageCreator) throws JmsException &#123;</div><div class="line">		execute(session -&gt; &#123;</div><div class="line">			doSend(session, destination, messageCreator);</div><div class="line">			return null;</div><div class="line">		&#125;, false);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>send方法调用了内部方法execute,而且我们看到一个关键参数名session,这里是一个lambda表达式,在session内封装了消息和destination,然后丢进execute方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T execute(SessionCallback&lt;T&gt; action, boolean startConnection) throws JmsException &#123;</div><div class="line">		Assert.notNull(action, &quot;Callback object must not be null&quot;);</div><div class="line">		Connection conToClose = null;</div><div class="line">		Session sessionToClose = null;</div><div class="line">		try &#123;</div><div class="line">			Session sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession(</div><div class="line">					obtainConnectionFactory(), this.transactionalResourceFactory, startConnection);</div><div class="line">			if (sessionToUse == null) &#123;</div><div class="line">				conToClose = createConnection();</div><div class="line">				sessionToClose = createSession(conToClose);</div><div class="line">				if (startConnection) &#123;</div><div class="line">					conToClose.start();</div><div class="line">				&#125;</div><div class="line">				sessionToUse = sessionToClose;</div><div class="line">			&#125;</div><div class="line">			if (logger.isDebugEnabled()) &#123;</div><div class="line">				logger.debug(&quot;Executing callback on JMS Session: &quot; + sessionToUse);</div><div class="line">			&#125;</div><div class="line">			return action.doInJms(sessionToUse);</div><div class="line">		&#125;</div><div class="line">		catch (JMSException ex) &#123;</div><div class="line">			throw convertJmsAccessException(ex);</div><div class="line">		&#125;</div><div class="line">		finally &#123;</div><div class="line">			JmsUtils.closeSession(sessionToClose);</div><div class="line">			ConnectionFactoryUtils.releaseConnection(conToClose, getConnectionFactory(), startConnection);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>execute方法创建connection,绑定session。调用doInJms方法将message发送到broker,然后释放资源。</p>
<p>这样粗略的看了一下消息的发送原理。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.shuchang.sc.com/2018/12/06/JMS-2-可靠性保证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuchang">
      <meta itemprop="description" content="多喝热水">
      <meta itemprop="image" content="/images/123.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ShuChang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/06/JMS-2-可靠性保证/" class="post-title-link" itemprop="http://www.shuchang.sc.com/page/3/index.html">JMS(2)-可靠性保证与消息模型</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-06 14:57:26" itemprop="dateCreated datePublished" datetime="2018-12-06T14:57:26+08:00">2018-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-12-26 09:46:47" itemprop="dateModified" datetime="2018-12-26T09:46:47+08:00">2018-12-26</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h2><p>对于一个消息中间件来说,可靠性保证一直是一个重要主题。Jms消息的可靠性保证,通常包含三个阶段: 客户端接收消息/客户端处理消息/客户端ACK</p>
<p>在事务性会话中(jms session),当事务被提交,即发生自动确认。在非事务会话中,消息的确认取决于应答模式:包含三种应答模式:</p>
<ul>
<li>client 客户端手动确认</li>
<li>auto 自动确认</li>
<li>dups_ok 一种延迟确认的模式,个人理解是一种批量签收。可以减少开销,但是可能会造成重复的ack。如果没有仔细研究过原理,不建议使用</li>
</ul>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>JMS消息持久化有两种方式:</p>
<p>PERSISTENT: 持久化模式,消息不会因为broker宕机而丢失,默认模式</p>
<p>NO_PERSISTENT: broker宕机,消息丢失</p>
<p>ActiveMQ内部消息存储默认使用了KahaDB,同时开支持的方式有AMQ,JDBC,Memory。可以在activemq.xml中对KahaDB进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">    &lt;kahaDB directory=&quot;$&#123;activemq.data&#125;/kahadb&quot;/&gt;</div><div class="line">&lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure>
<p>可用属性:</p>
<ol>
<li><p>indexWriteBatchSize: 批量写入磁盘索引的数量,默认1000</p>
</li>
<li><p>indexCacheSize: 内存中缓存索引的page数量,默认1000</p>
</li>
<li><p>enableIndexWriteAsync: 是否异步写出索引,默认false</p>
</li>
<li><p>journalMaxFileLength: 设置每个消息datalog大小,默认32MB</p>
</li>
<li><p>enableJournalDiskSyncs: 如果没有加事务,是否需要写入磁盘。JMS持久化时需要设置为false</p>
</li>
<li><p>cleanUpInterval: 清理过期消息,默认30000</p>
</li>
<li><p>archiveDataLogs: 对于需要删除的文件,不做删除,而是进行压缩。默认为false</p>
</li>
<li><p>directoryArchive: 压缩文件的存放位置</p>
</li>
</ol>
<h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><p>可以设置消息的过期时间,默认是永不过期。</p>
<h2 id="临时目的地"><a href="#临时目的地" class="headerlink" title="临时目的地"></a>临时目的地</h2><p>jms session可以创建临时的queue或者topic,当创建临时目的地的连接断开,临时目的地也就删除。只有创建临时目的地连接的消费者才可以消费这里的信息。</p>
<h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>在JMS客户端中,可以使用本地事务来组合消息的接收和发送,最后使用commit提交或者使用rollback进行回滚。事务提交表示发送者的消息都已经发送,消费者消息都已确认。事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交。</p>
<p>需要注意的是,如果业务是一个请求/回复模式,发送一个消息,同时希望在事务中等待消息的回复,那么程序会被挂起,因为直到事务提交,发送操作才会真正执行。</p>
<p>消息的生产和消费不能再同一个事务中。</p>
<h2 id="消息模型-PTP"><a href="#消息模型-PTP" class="headerlink" title="消息模型-PTP"></a>消息模型-PTP</h2><p>PTP就是一种点对点的模型,一个消费者一个生产者,是一种单播模式。</p>
<p>当session关闭时,如果有一些消息已经收到,但还没有签收,那么当客户端再次连接上时,这些消息还会被再次接收。</p>
<p>如果消费端设置了选择器,那么不符合条件的消息会留在队列中,不会被接收。</p>
<p>队列可以持久保存消息知道消费端收到消息,充分体现异步传输的优势</p>
<h2 id="消息模型-pub-sub"><a href="#消息模型-pub-sub" class="headerlink" title="消息模型-pub/sub"></a>消息模型-pub/sub</h2><p>发布订阅模式,生产者制定一个主题,多个消费端可以订阅这个主题来收到消息,是一种广播模式。</p>
<ol>
<li><p>消息订阅分为持久订阅和非持久订阅:非持久订阅当客户端处于非激活状态时,消息将会消失,永远不能接收到。<br>持久模式则是消费端向JMS注册自身,当消费端宕机,broker会保存这个主题的消息,当消费端上线时,可以得到离线时漏掉的消息。</p>
</li>
<li><p>非持久模式下不能重新派送一个未签收的消息,所以需要设置为持久化模式。</p>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/123.png"
                alt="Shuchang" />
            
              <p class="site-author-name" itemprop="name">Shuchang</p>
              <p class="site-description motion-element" itemprop="description">多喝热水</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">101</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://gitee.com/swiftsc" title="GitHub &rarr; https://gitee.com/swiftsc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/shuchang0403@gmail.com" title="E-Mail &rarr; shuchang0403@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">  <a href="http://www.miitbeian.gov.cn" rel="noopener" target="_blank">浙ICP备17049505号 </a>&copy; 2015 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuchang</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    






  





  

  

  

  

  

  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
